/*
   +----------------------------------------------------------------------+
   | Zend Engine                                                          |
   +----------------------------------------------------------------------+
   | Copyright (c) 1998-2014 Zend Technologies Ltd. (http://www.zend.com) |
   +----------------------------------------------------------------------+
   | This source file is subject to version 2.00 of the Zend license,     |
   | that is bundled with this package in the file LICENSE, and is        |
   | available through the world-wide-web at the following url:           |
   | http://www.zend.com/license/2_00.txt.                                |
   | If you did not receive a copy of the Zend license and are unable to  |
   | obtain it through the world-wide-web, please send a note to          |
   | license@zend.com so we can mail you a copy immediately.              |
   +----------------------------------------------------------------------+
   | Authors: Andi Gutmans <andi@zend.com>                                |
   |          Zeev Suraski <zeev@zend.com>                                |
   |          Dmitry Stogov <dmitry@zend.com>                             |
   +----------------------------------------------------------------------+
*/

#ifdef ZEND_WIN32
# pragma warning(once : 4101)
# pragma warning(once : 6235)
# pragma warning(once : 6237)
# pragma warning(once : 6239)
# pragma warning(once : 6240)
# pragma warning(once : 6285)
# pragma warning(once : 6286)
# pragma warning(once : 6326)
#endif
static user_opcode_handler_t zend_user_opcode_handlers[256] = {
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL,
	(user_opcode_handler_t)NULL
};

static zend_uchar zend_user_opcodes[256] = {0,
	1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,
	17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,
	33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,
	49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,
	65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,
	81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,
	97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,
	113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,
	129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,
	145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,
	161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,
	177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,192,
	193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,
	209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,
	225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,
	241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
};

static opcode_handler_t zend_vm_get_opcode_handler(zend_uchar opcode, zend_op* op);


#undef OPLINE
#undef DCL_OPLINE
#undef USE_OPLINE
#undef LOAD_OPLINE
#undef SAVE_OPLINE
#define OPLINE EX(opline)
#define DCL_OPLINE
#define USE_OPLINE zend_op *opline = EX(opline);
#define LOAD_OPLINE()
#define SAVE_OPLINE()
#undef CHECK_EXCEPTION
#undef HANDLE_EXCEPTION
#undef HANDLE_EXCEPTION_LEAVE
#define CHECK_EXCEPTION() LOAD_OPLINE()
#define HANDLE_EXCEPTION() LOAD_OPLINE(); ZEND_VM_CONTINUE()
#define HANDLE_EXCEPTION_LEAVE() LOAD_OPLINE(); ZEND_VM_LEAVE()
#define LOAD_REGS()
#define ZEND_VM_CONTINUE()         return 0
#define ZEND_VM_RETURN()           return 1
#define ZEND_VM_ENTER()            return 2
#define ZEND_VM_LEAVE()            return 3
#define ZEND_VM_DISPATCH(opcode, opline) return zend_vm_get_opcode_handler(opcode, opline)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);

#define ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_INTERNAL execute_data TSRMLS_CC

ZEND_API void execute_ex(zend_execute_data *execute_data TSRMLS_DC)
{
	DCL_OPLINE
	zend_bool original_in_execution;



	original_in_execution = EG(in_execution);
	EG(in_execution) = 1;

	LOAD_REGS();
	LOAD_OPLINE();

	while (1) {
    	int ret;
#ifdef ZEND_WIN32
		if (EG(timed_out)) {
			zend_timeout(0);
		}
#endif

		if ((ret = OPLINE->handler(execute_data TSRMLS_CC)) > 0) {
			switch (ret) {
				case 1:
					EG(in_execution) = original_in_execution;
					return;
				case 2:
				case 3:
					execute_data = EG(current_execute_data);
					break;
				default:
					break;
			}
		}

	}
	zend_error_noreturn(E_ERROR, "Arrived at end of main loop which shouldn't happen");
}

ZEND_API void zend_execute(zend_op_array *op_array, zval *return_value TSRMLS_DC)
{
	if (EG(exception) != NULL) {
		return;
	} 
	zend_execute_ex(i_create_execute_data_from_op_array(op_array, return_value, EG(active_symbol_table) ? VM_FRAME_TOP_CODE : VM_FRAME_TOP_FUNCTION TSRMLS_CC) TSRMLS_CC);
}

static int ZEND_FASTCALL zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS)
{
	vm_frame_kind frame_kind = EX(frame_kind);

	EG(current_execute_data) = EX(prev_execute_data);

	if (frame_kind == VM_FRAME_NESTED_FUNCTION) {
		i_free_compiled_variables(execute_data TSRMLS_CC);
		if (UNEXPECTED(EX(symbol_table) != NULL)) {
			zend_clean_and_cache_symbol_table(EX(symbol_table) TSRMLS_CC);
		}
		if (UNEXPECTED((EX(op_array)->fn_flags & ZEND_ACC_CLOSURE) != 0) && EX(op_array)->prototype) {
			zval_ptr_dtor((zval*)EX(op_array)->prototype);
		}
		zend_vm_stack_free((char*)execute_data TSRMLS_CC);

		execute_data = EG(current_execute_data);
		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		EG(active_symbol_table) = EX(symbol_table);

		EX(function_state).function = (zend_function *) EX(op_array);
		EX(function_state).arguments = NULL;

		if (Z_OBJ(EG(This))) {
			if (UNEXPECTED(EG(exception) != NULL) && EX(call)->is_ctor_call) {
				if (EX(call)->is_ctor_result_used) {
					Z_DELREF(EG(This));
				}
				if (Z_REFCOUNT(EG(This)) == 1) {
					zend_object_store_ctor_failed(Z_OBJ(EG(This)) TSRMLS_CC);
				}
			}
			zval_ptr_dtor(&EG(This));
		}
		Z_OBJ(EG(This)) = EX(current_this);
		EG(scope) = EX(current_scope);
		EG(called_scope) = EX(current_called_scope);

		EX(call)--;

		zend_vm_stack_clear_multiple(1 TSRMLS_CC);

		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_op *opline = EX(opline);
			zend_throw_exception_internal(NULL TSRMLS_CC);
			if (RETURN_VALUE_USED(opline)) {
				zval_ptr_dtor(EX_VAR(opline->result.var));
			}
			HANDLE_EXCEPTION_LEAVE();
		}

		ZEND_VM_INC_OPCODE();
		ZEND_VM_LEAVE();
	} else if (frame_kind == VM_FRAME_NESTED_CODE) {
		zend_detach_symbol_table(execute_data);
		destroy_op_array(EX(op_array) TSRMLS_CC);
		efree(EX(op_array));
		zend_vm_stack_free((char*)execute_data TSRMLS_CC);

		execute_data = EG(current_execute_data);
		zend_attach_symbol_table(execute_data);
		EX(function_state).function = (zend_function *) EX(op_array);
		EX(function_state).arguments = NULL;
		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION_LEAVE();
		}

		ZEND_VM_INC_OPCODE();
		ZEND_VM_LEAVE();
	} else {
		if (frame_kind == VM_FRAME_TOP_FUNCTION) {
			i_free_compiled_variables(execute_data TSRMLS_CC);
		} else /* if (frame_kind == VM_FRAME_TOP_CODE) */ {
			zend_array *symbol_table = EX(symbol_table);
			zend_execute_data *old_execute_data;

			zend_detach_symbol_table(execute_data);
			old_execute_data = EX(prev_execute_data);
			while (old_execute_data) {
				if (old_execute_data->op_array) {
					if (old_execute_data->symbol_table == symbol_table) {
						zend_attach_symbol_table(old_execute_data);
					}
					break;
				}
				old_execute_data = old_execute_data->prev_execute_data;
			}
		}
		if ((EX(op_array)->fn_flags & ZEND_ACC_CLOSURE) && EX(op_array)->prototype) {
			zval_ptr_dtor((zval*)EX(op_array)->prototype);
		}
		zend_vm_stack_free((char*)execute_data TSRMLS_CC);
		EG(opline_ptr) = NULL;
		ZEND_VM_RETURN();
	}
}

static int ZEND_FASTCALL zend_do_fcall_common_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_bool should_change_scope = 0;
	zend_function *fbc = EX(function_state).function;
	zend_uint num_args;

	SAVE_OPLINE();
	EX(object) = EX(call)->object;
	if (UNEXPECTED((fbc->common.fn_flags & (ZEND_ACC_ABSTRACT|ZEND_ACC_DEPRECATED)) != 0)) {
		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_ABSTRACT) != 0)) {
			zend_error_noreturn(E_ERROR, "Cannot call abstract method %s::%s()", fbc->common.scope->name->val, fbc->common.function_name->val);
		}
		if (UNEXPECTED((fbc->common.fn_flags & ZEND_ACC_DEPRECATED) != 0)) {
			zend_error(E_DEPRECATED, "Function %s%s%s() is deprecated",
				fbc->common.scope ? fbc->common.scope->name->val : "",
				fbc->common.scope ? "::" : "",
				fbc->common.function_name->val);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		}
	}
	if (fbc->common.scope &&
		!(fbc->common.fn_flags & ZEND_ACC_STATIC) &&
		!EX(object)) {

		if (fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
			/* FIXME: output identifiers properly */
			zend_error(E_STRICT, "Non-static method %s::%s() should not be called statically", fbc->common.scope->name->val, fbc->common.function_name->val);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
		} else {
			/* FIXME: output identifiers properly */
			/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
			zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically", fbc->common.scope->name->val, fbc->common.function_name->val);
		}
	}

	if (fbc->type == ZEND_USER_FUNCTION || fbc->common.scope) {
		should_change_scope = 1;
		EX(current_this) = Z_OBJ(EG(This));
		EX(current_scope) = EG(scope);
		EX(current_called_scope) = EG(called_scope);
		Z_OBJ(EG(This)) = EX(object);
//???		EG(scope) = (fbc->type == ZEND_USER_FUNCTION || !EX(object)) ? fbc->common.scope : NULL;
		EG(scope) = fbc->common.scope;
		EG(called_scope) = EX(call)->called_scope;
	}

	if (UNEXPECTED(EX(call)->num_additional_args != 0)) {
		num_args = opline->extended_value + EX(call)->num_additional_args;
		EX(function_state).arguments = zend_vm_stack_push_args(num_args TSRMLS_CC);
	} else {
		zval tmp;

		num_args = opline->extended_value;
		ZVAL_LONG(&tmp, num_args);
		EX(function_state).arguments = zend_vm_stack_top(TSRMLS_C);
		zend_vm_stack_push(&tmp TSRMLS_CC);
	}
	LOAD_OPLINE();

	if (fbc->type == ZEND_INTERNAL_FUNCTION) {
		if (fbc->common.fn_flags & ZEND_ACC_HAS_TYPE_HINTS) {
			zend_uint i;
			zval *p = EX(function_state).arguments - num_args;

			for (i = 0; i < num_args; ++i, ++p) {
				zend_verify_arg_type(fbc, i + 1, p, 0 TSRMLS_CC);
			}
		}

		if (EXPECTED(EG(exception) == NULL)) {
			zval *ret = EX_VAR(opline->result.var);

			ZVAL_NULL(ret);
			Z_VAR_FLAGS_P(ret) = (fbc->common.fn_flags & ZEND_ACC_RETURN_REFERENCE) != 0 ? IS_VAR_RET_REF : 0;

			if (!zend_execute_internal) {
				/* saves one function call if zend_execute_internal is not used */
				fbc->internal_function.handler(num_args, ret TSRMLS_CC);
			} else {
				zend_execute_internal(execute_data, NULL TSRMLS_CC);
			}

			if (!RETURN_VALUE_USED(opline)) {
				zval_ptr_dtor(ret);
			}
		} else if (RETURN_VALUE_USED(opline)) {
			ZVAL_UNDEF(EX_VAR(opline->result.var));
		}
	} else if (fbc->type == ZEND_USER_FUNCTION) {
		zval *return_value = NULL;

		EG(active_symbol_table) = NULL;
		EG(active_op_array) = &fbc->op_array;
		if (RETURN_VALUE_USED(opline)) {
			return_value = EX_VAR(opline->result.var);

			ZVAL_NULL(return_value);
			Z_VAR_FLAGS_P(return_value) = (fbc->common.fn_flags & ZEND_ACC_RETURN_REFERENCE) != 0 ? IS_VAR_RET_REF : 0;
		}

		if (UNEXPECTED((EG(active_op_array)->fn_flags & ZEND_ACC_GENERATOR) != 0)) {
			if (RETURN_VALUE_USED(opline)) {
				zend_generator_create_zval(EG(active_op_array), EX_VAR(opline->result.var) TSRMLS_CC);
			}
		} else if (EXPECTED(zend_execute_ex == execute_ex)) {
			if (EXPECTED(EG(exception) == NULL)) {
				i_create_execute_data_from_op_array(EG(active_op_array), return_value, VM_FRAME_NESTED_FUNCTION TSRMLS_CC);
				ZEND_VM_ENTER();
			}
		} else {
			zend_execute(EG(active_op_array), return_value TSRMLS_CC);
		}

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		if (UNEXPECTED(EG(active_symbol_table) != NULL)) {
			zend_clean_and_cache_symbol_table(EG(active_symbol_table) TSRMLS_CC);
		}
		EG(active_symbol_table) = EX(symbol_table);
	} else { /* ZEND_OVERLOADED_FUNCTION */
		ZVAL_NULL(EX_VAR(opline->result.var));

		/* Not sure what should be done here if it's a static method */
		if (EXPECTED(EX(object) != NULL)) {
			EX(object)->handlers->call_method(fbc->common.function_name, EX(object), num_args, EX_VAR(opline->result.var) TSRMLS_CC);
		} else {
			zend_error_noreturn(E_ERROR, "Cannot call overloaded function for non-object");
		}

		if (fbc->type == ZEND_OVERLOADED_FUNCTION_TEMPORARY) {
			STR_RELEASE(fbc->common.function_name);
		}
		efree(fbc);

		if (!RETURN_VALUE_USED(opline)) {
			zval_ptr_dtor(EX_VAR(opline->result.var));
		} else {
//???			Z_UNSET_ISREF_P(EX_T(opline->result.var).var.ptr);
//???			Z_SET_REFCOUNT_P(EX_T(opline->result.var).var.ptr, 1);
			Z_VAR_FLAGS_P(EX_VAR(opline->result.var)) = 0;
		}
	}

	EX(function_state).function = (zend_function *) EX(op_array);
	EX(function_state).arguments = NULL;

	if (should_change_scope) {
		if (Z_OBJ(EG(This))) {
			if (UNEXPECTED(EG(exception) != NULL) && EX(call)->is_ctor_call) {
				if (EX(call)->is_ctor_result_used) {
					Z_DELREF(EG(This));
				}
				if (Z_REFCOUNT(EG(This)) == 1) {
					zend_object_store_ctor_failed(Z_OBJ(EG(This)) TSRMLS_CC);
				}
			}
			zval_ptr_dtor(&EG(This));
		}
		Z_OBJ(EG(This)) = EX(current_this);
		EG(scope) = EX(current_scope);
		EG(called_scope) = EX(current_called_scope);
	}

	EX(call)--;

	zend_vm_stack_clear_multiple(1 TSRMLS_CC);

	if (UNEXPECTED(EG(exception) != NULL)) {
		zend_throw_exception_internal(NULL TSRMLS_CC);
		if (RETURN_VALUE_USED(opline)) {
			zval_ptr_dtor(EX_VAR(opline->result.var));
		}
		HANDLE_EXCEPTION();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

#if DEBUG_ZEND>=2
	printf("Jumping to %d\n", opline->op1.opline_num);
#endif
	ZEND_VM_SET_OPCODE(opline->op1.jmp_addr);
	ZEND_VM_CONTINUE();
}

static int ZEND_FASTCALL  ZEND_INIT_STRING_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *tmp = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_EMPTY_STRING(tmp);
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	EX(function_state).function = EX(call)->fbc;
	return zend_do_fcall_common_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_GENERATOR_RETURN_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	/* Close the generator to free up resources */
	zend_generator_close(generator, 1 TSRMLS_CC);

	/* Pass execution back to handling code */
	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_SEND_UNPACK_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *args;
	int arg_num;
	SAVE_OPLINE();

	args = get_zval_ptr(opline->op1_type, &opline->op1, execute_data, &free_op1, BP_VAR_R);
	arg_num = opline->op2.num + EX(call)->num_additional_args + 1;

send_again:
	switch (Z_TYPE_P(args)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(args);
			zval *arg;
			zend_string *name;
			zend_ulong index;

			ZEND_VM_STACK_GROW_IF_NEEDED(zend_hash_num_elements(ht));

			ZEND_HASH_FOREACH_KEY_VAL(ht, index, name, arg) {
				if (name) {
					zend_error(E_RECOVERABLE_ERROR, "Cannot unpack array with string keys");
					FREE_OP(free_op1);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}

				if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(arg);
					Z_ADDREF_P(arg);
				} else if (Z_ISREF_P(arg)) {
					ZVAL_DUP(arg, Z_REFVAL_P(arg));
				} else {
					if (Z_REFCOUNTED_P(arg)) Z_ADDREF_P(arg);
				}

				zend_vm_stack_push(arg TSRMLS_CC);
				EX(call)->num_additional_args++;
				arg_num++;
			} ZEND_HASH_FOREACH_END();

			break;
		}
		case IS_OBJECT: {
			zend_class_entry *ce = Z_OBJCE_P(args);
			zend_object_iterator *iter;

			if (!ce || !ce->get_iterator) {
				zend_error(E_WARNING, "Only arrays and Traversables can be unpacked");
				break;
			}

			iter = ce->get_iterator(ce, args, 0 TSRMLS_CC);
			if (UNEXPECTED(!iter)) {
				FREE_OP(free_op1);
				if (!EG(exception)) {
					zend_throw_exception_ex(
						NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name->val
					);
				}
				HANDLE_EXCEPTION();
			}

			if (iter->funcs->rewind) {
				iter->funcs->rewind(iter TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					goto unpack_iter_dtor;
				}
			}

			for (; iter->funcs->valid(iter TSRMLS_CC) == SUCCESS; ++arg_num) {
				zval *arg;

				if (UNEXPECTED(EG(exception) != NULL)) {
					goto unpack_iter_dtor;
				}

				arg = iter->funcs->get_current_data(iter TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					goto unpack_iter_dtor;
				}

				if (iter->funcs->get_current_key) {
					zval key;
					iter->funcs->get_current_key(iter, &key TSRMLS_CC);
					if (UNEXPECTED(EG(exception) != NULL)) {
						goto unpack_iter_dtor;
					}

					if (Z_TYPE(key) == IS_STRING) {
						zend_error(E_RECOVERABLE_ERROR,
							"Cannot unpack Traversable with string keys");
						zval_dtor(&key);
						goto unpack_iter_dtor;
					}

					zval_dtor(&key);
				}

				if (ARG_MUST_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
					zend_error(
						E_WARNING, "Cannot pass by-reference argument %d of %s%s%s()"
						" by unpacking a Traversable, passing by-value instead", arg_num,
						EX(call)->fbc->common.scope ? EX(call)->fbc->common.scope->name->val : "",
						EX(call)->fbc->common.scope ? "::" : "",
						EX(call)->fbc->common.function_name->val
					);
				}

				if (Z_ISREF_P(arg)) {
					ZVAL_DUP(arg, Z_REFVAL_P(arg));
				} else {
					if (Z_REFCOUNTED_P(arg)) Z_ADDREF_P(arg);
				}

				ZEND_VM_STACK_GROW_IF_NEEDED(1);
				zend_vm_stack_push(arg TSRMLS_CC);
				EX(call)->num_additional_args++;

				iter->funcs->move_forward(iter TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					goto unpack_iter_dtor;
				}
			}

unpack_iter_dtor:
			zend_iterator_dtor(iter TSRMLS_CC);
			break;
		}
		case IS_REFERENCE:
			args = Z_REFVAL_P(args);
			goto send_again;
			break;
		default:
			zend_error(E_WARNING, "Only arrays and Traversables can be unpacked");
	}

	FREE_OP(free_op1);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RECV_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_uint arg_num = opline->op1.num;
	zval *arguments = EX(prev_execute_data)->function_state.arguments;
	zend_uint arg_count = Z_LVAL_P(arguments);

	SAVE_OPLINE();
	if (UNEXPECTED(arg_num > arg_count)) {
		zend_verify_missing_arg(execute_data, arg_num TSRMLS_CC);
	} else {
		zval *var_ptr;
		zval *param = arguments - arg_count + arg_num - 1;

		if (UNEXPECTED((EX(op_array)->fn_flags & ZEND_ACC_HAS_TYPE_HINTS) != 0)) {
			zend_verify_arg_type((zend_function *) EX(op_array), arg_num, param, opline->extended_value TSRMLS_CC);
		}
		var_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->result.var TSRMLS_CC);
		if (UNEXPECTED(Z_REFCOUNTED_P(var_ptr))) Z_DELREF_P(var_ptr);
		ZVAL_COPY(var_ptr, param);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RECV_VARIADIC_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_uint arg_num = opline->op1.num;
	zval *arguments = EX(prev_execute_data)->function_state.arguments;
	zend_uint arg_count = Z_LVAL_P(arguments);
	zval *params;

	SAVE_OPLINE();

	params = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->result.var TSRMLS_CC);
	if (UNEXPECTED(Z_REFCOUNTED_P(params))) Z_DELREF_P(params);

	if (arg_num <= arg_count) {
		zval *param = arguments - arg_count + arg_num - 1;
		array_init_size(params, arg_count - arg_num + 1);
		if (UNEXPECTED((EX(op_array)->fn_flags & ZEND_ACC_HAS_TYPE_HINTS) != 0)) {
			do {
				zend_verify_arg_type((zend_function *) EX(op_array), arg_num, param, opline->extended_value TSRMLS_CC);
				zend_hash_next_index_insert(Z_ARRVAL_P(params), param);
				if (Z_REFCOUNTED_P(param)) Z_ADDREF_P(param);
				param++;
			} while (++arg_num <= arg_count);
		} else {
			do {
				zend_hash_next_index_insert(Z_ARRVAL_P(params), param);
				if (Z_REFCOUNTED_P(param)) Z_ADDREF_P(param);
				param++;
			} while (++arg_num <= arg_count);
		}
	} else {
		array_init(params);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_NEW_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval object_zval;
	zend_function *constructor;

	SAVE_OPLINE();
	if (UNEXPECTED((Z_CE_P(EX_VAR(opline->op1.var))->ce_flags & (ZEND_ACC_INTERFACE|ZEND_ACC_IMPLICIT_ABSTRACT_CLASS|ZEND_ACC_EXPLICIT_ABSTRACT_CLASS)) != 0)) {
		if (Z_CE_P(EX_VAR(opline->op1.var))->ce_flags & ZEND_ACC_INTERFACE) {
			zend_error_noreturn(E_ERROR, "Cannot instantiate interface %s", Z_CE_P(EX_VAR(opline->op1.var))->name->val);
		} else if ((Z_CE_P(EX_VAR(opline->op1.var))->ce_flags & ZEND_ACC_TRAIT) == ZEND_ACC_TRAIT) {
			zend_error_noreturn(E_ERROR, "Cannot instantiate trait %s", Z_CE_P(EX_VAR(opline->op1.var))->name->val);
		} else {
			zend_error_noreturn(E_ERROR, "Cannot instantiate abstract class %s", Z_CE_P(EX_VAR(opline->op1.var))->name->val);
		}
	}
	object_init_ex(&object_zval, Z_CE_P(EX_VAR(opline->op1.var)));
	constructor = Z_OBJ_HT(object_zval)->get_constructor(Z_OBJ(object_zval) TSRMLS_CC);

	if (constructor == NULL) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), &object_zval);
		} else {
			zval_ptr_dtor(&object_zval);
		}
		ZEND_VM_JMP(EX(op_array)->opcodes + opline->op2.opline_num);
	} else {
		call_slot *call = EX(call_slots) + opline->extended_value;

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_COPY(EX_VAR(opline->result.var), &object_zval);
		}

		/* We are not handling overloaded classes right now */
		call->fbc = constructor;
		call->object = Z_OBJ(object_zval);
		call->called_scope = Z_CE_P(EX_VAR(opline->op1.var));
		call->num_additional_args = 0;
		call->is_ctor_call = 1;
		call->is_ctor_result_used = RETURN_VALUE_USED(opline);
		EX(call) = call;

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_BEGIN_SILENCE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	ZVAL_LONG(EX_VAR(opline->result.var), EG(error_reporting));
	if (Z_TYPE(EX(old_error_reporting)) == IS_UNDEF) {
		ZVAL_LONG(&EX(old_error_reporting), EG(error_reporting));
	}

	if (EG(error_reporting)) {
		do {
			EG(error_reporting) = 0;
			if (!EG(error_reporting_ini_entry)) {
				zend_ini_entry *p = zend_hash_str_find_ptr(EG(ini_directives), "error_reporting", sizeof("error_reporting")-1);
				if (p) {
					EG(error_reporting_ini_entry) = p;
				} else {
					break;
				}
			}
			if (!EG(error_reporting_ini_entry)->modified) {
				if (!EG(modified_ini_directives)) {
					ALLOC_HASHTABLE(EG(modified_ini_directives));
					zend_hash_init(EG(modified_ini_directives), 8, NULL, NULL, 0);
				}
				if (EXPECTED(zend_hash_str_add_ptr(EG(modified_ini_directives), "error_reporting", sizeof("error_reporting")-1, EG(error_reporting_ini_entry)) != NULL)) {
					EG(error_reporting_ini_entry)->orig_value = EG(error_reporting_ini_entry)->value;
					EG(error_reporting_ini_entry)->orig_value_length = EG(error_reporting_ini_entry)->value_length;
					EG(error_reporting_ini_entry)->orig_modifiable = EG(error_reporting_ini_entry)->modifiable;
					EG(error_reporting_ini_entry)->modified = 1;
				}
			} else if (EG(error_reporting_ini_entry)->value != EG(error_reporting_ini_entry)->orig_value) {
				efree(EG(error_reporting_ini_entry)->value);
			}
			EG(error_reporting_ini_entry)->value = estrndup("0", sizeof("0")-1);
			EG(error_reporting_ini_entry)->value_length = sizeof("0")-1;
		} while (0);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	SAVE_OPLINE();
	zend_error_noreturn(E_ERROR, "Cannot call abstract method %s::%s()", EG(scope)->name->val, EX(op_array)->function_name->val);
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

static int ZEND_FASTCALL  ZEND_EXT_STMT_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	SAVE_OPLINE();
	if (!EG(no_extensions)) {
		zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_statement_handler, EX(op_array) TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	SAVE_OPLINE();
	if (!EG(no_extensions)) {
		zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_fcall_begin_handler, EX(op_array) TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_EXT_FCALL_END_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	SAVE_OPLINE();
	if (!EG(no_extensions)) {
		zend_llist_apply_with_argument(&zend_extensions, (llist_apply_with_arg_func_t) zend_extension_fcall_end_handler, EX(op_array) TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DECLARE_CLASS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	Z_CE_P(EX_VAR(opline->result.var)) = do_bind_class(EX(op_array), opline, EG(class_table), 0 TSRMLS_CC);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	Z_CE_P(EX_VAR(opline->result.var)) = do_bind_inherited_class(EX(op_array), opline, EG(class_table), Z_CE_P(EX_VAR(opline->extended_value)), 0 TSRMLS_CC);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *zce, *orig_zce;

	SAVE_OPLINE();
	if ((zce = zend_hash_find(EG(class_table), Z_STR_P(opline->op2.zv))) == NULL ||
	    ((orig_zce = zend_hash_find(EG(class_table), Z_STR_P(opline->op1.zv))) != NULL &&
	     Z_CE_P(zce) != Z_CE_P(orig_zce))) {
		do_bind_inherited_class(EX(op_array), opline, EG(class_table), Z_CE_P(EX_VAR(opline->extended_value)), 0 TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DECLARE_FUNCTION_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	do_bind_function(EX(op_array), opline, EG(function_table), 0);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_TICKS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (++EG(ticks_count)>=opline->extended_value) {
		EG(ticks_count)=0;
		if (zend_ticks_function) {
			zend_ticks_function(opline->extended_value TSRMLS_CC);
		}
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_EXT_NOP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_NOP_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_TRAIT_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_class_entry *ce = Z_CE_P(EX_VAR(opline->op1.var));
	zend_class_entry *trait;

	SAVE_OPLINE();
	if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
		trait = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
	} else {
		trait = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv),
		                                 opline->op2.zv + 1,
		                                 opline->extended_value TSRMLS_CC);
		if (UNEXPECTED(trait == NULL)) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
		if (!((trait->ce_flags & ZEND_ACC_TRAIT) == ZEND_ACC_TRAIT)) {
			zend_error_noreturn(E_ERROR, "%s cannot use %s - it is not a trait", ce->name->val, trait->name->val);
		}
		CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), trait);
	}

	zend_do_implement_trait(ce, trait TSRMLS_CC);

 	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BIND_TRAITS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_class_entry *ce = Z_CE_P(EX_VAR(opline->op1.var));

	SAVE_OPLINE();
	zend_do_bind_traits(ce TSRMLS_CC);
 	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_HANDLE_EXCEPTION_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_uint op_num = EG(opline_before_exception)-EG(active_op_array)->opcodes;
	int i;
	zend_uint catch_op_num = 0, finally_op_num = 0, finally_op_end = 0;
	zval *stack_frame;

	/* Figure out where the next stack frame (which maybe contains pushed
	 * arguments that have to be dtor'ed) starts */
	stack_frame = zend_vm_stack_frame_base(execute_data);

	/* If the exception was thrown during a function call there might be
	 * arguments pushed to the stack that have to be dtor'ed. */
	while (zend_vm_stack_top(TSRMLS_C) != stack_frame) {
		zval *stack_zval_p = zend_vm_stack_pop(TSRMLS_C);
		zval_ptr_dtor(stack_zval_p);
	}

	for (i=0; i<EG(active_op_array)->last_try_catch; i++) {
		if (EG(active_op_array)->try_catch_array[i].try_op > op_num) {
			/* further blocks will not be relevant... */
			break;
		}
		if (op_num < EG(active_op_array)->try_catch_array[i].catch_op) {
			catch_op_num = EX(op_array)->try_catch_array[i].catch_op;
		}
		if (op_num < EG(active_op_array)->try_catch_array[i].finally_op) {
			finally_op_num = EX(op_array)->try_catch_array[i].finally_op;
		}
		if (op_num >= EG(active_op_array)->try_catch_array[i].finally_op &&
				op_num < EG(active_op_array)->try_catch_array[i].finally_end) {
			finally_op_end = EG(active_op_array)->try_catch_array[i].finally_end;
		}
	}

	if (EX(call) >= EX(call_slots)) {
		call_slot *call = EX(call);
		do {
			if (call->object) {
				if (call->is_ctor_call) {
					if (call->is_ctor_result_used) {
						GC_REFCOUNT(call->object)--;
					}
					if (GC_REFCOUNT(call->object) == 1) {
						zend_object_store_ctor_failed(call->object TSRMLS_CC);
					}
				}
				OBJ_RELEASE(call->object);
			}
			call--;
		} while (call >= EX(call_slots));
		EX(call) = NULL;
	}

	for (i=0; i<EX(op_array)->last_brk_cont; i++) {
		if (EX(op_array)->brk_cont_array[i].start < 0) {
			continue;
		} else if (EX(op_array)->brk_cont_array[i].start > op_num) {
			/* further blocks will not be relevant... */
			break;
		} else if (op_num < EX(op_array)->brk_cont_array[i].brk) {
			if (!catch_op_num ||
			    catch_op_num >= EX(op_array)->brk_cont_array[i].brk) {
				zend_op *brk_opline = &EX(op_array)->opcodes[EX(op_array)->brk_cont_array[i].brk];

				switch (brk_opline->opcode) {
					case ZEND_SWITCH_FREE:
						if (!(brk_opline->extended_value & EXT_TYPE_FREE_ON_RETURN)) {
							zval_ptr_dtor(EX_VAR(brk_opline->op1.var));
						}
						break;
					case ZEND_FREE:
						if (!(brk_opline->extended_value & EXT_TYPE_FREE_ON_RETURN)) {
							zval_dtor(EX_VAR(brk_opline->op1.var));
						}
						break;
				}
			}
		}
	}

	/* restore previous error_reporting value */
	if (!EG(error_reporting) && Z_TYPE(EX(old_error_reporting)) != IS_UNDEF && Z_LVAL(EX(old_error_reporting)) != 0) {
		zval restored_error_reporting;
		zend_string *key;

		ZVAL_LONG(&restored_error_reporting, Z_LVAL(EX(old_error_reporting)));
		convert_to_string(&restored_error_reporting);
		key = STR_INIT("error_reporting", sizeof("error_reporting")-1, 0);
		zend_alter_ini_entry_ex(key, Z_STRVAL(restored_error_reporting), Z_STRLEN(restored_error_reporting), ZEND_INI_USER, ZEND_INI_STAGE_RUNTIME, 1 TSRMLS_CC);
		STR_FREE(key);
		zval_dtor(&restored_error_reporting);
	}
	ZVAL_UNDEF(&EX(old_error_reporting));

	if (finally_op_num && (!catch_op_num || catch_op_num >= finally_op_num)) {
		if (EX(delayed_exception)) {
			zend_exception_set_previous(EG(exception), EX(delayed_exception) TSRMLS_CC);
		}
		EX(delayed_exception) = EG(exception);
		EG(exception) = NULL;
		EX(fast_ret) = NULL;
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[finally_op_num]);
		ZEND_VM_CONTINUE();
	} else if (catch_op_num) {
		if (finally_op_end && catch_op_num > finally_op_end) {
			/* we are going out of current finally scope */
			if (EX(delayed_exception)) {
				zend_exception_set_previous(EG(exception), EX(delayed_exception) TSRMLS_CC);
				EX(delayed_exception) = NULL;
			}
		}
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[catch_op_num]);
		ZEND_VM_CONTINUE();
	} else {
		if (EX(delayed_exception)) {
			zend_exception_set_previous(EG(exception), EX(delayed_exception) TSRMLS_CC);
			EX(delayed_exception) = NULL;
		}
		if (UNEXPECTED((EX(op_array)->fn_flags & ZEND_ACC_GENERATOR) != 0)) {
			return ZEND_GENERATOR_RETURN_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		} else {
			return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}
}

static int ZEND_FASTCALL  ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	zend_verify_abstract_class(Z_CE_P(EX_VAR(opline->op1.var)) TSRMLS_CC);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_USER_OPCODE_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	int ret;

	SAVE_OPLINE();
	ret = zend_user_opcode_handlers[opline->opcode](ZEND_OPCODE_HANDLER_ARGS_PASSTHRU_INTERNAL);
	LOAD_OPLINE();

	switch (ret) {
		case ZEND_USER_OPCODE_CONTINUE:
			ZEND_VM_CONTINUE();
		case ZEND_USER_OPCODE_RETURN:
			if (UNEXPECTED((EX(op_array)->fn_flags & ZEND_ACC_GENERATOR) != 0)) {
				return ZEND_GENERATOR_RETURN_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			} else {
				return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			}
		case ZEND_USER_OPCODE_ENTER:
			ZEND_VM_ENTER();
		case ZEND_USER_OPCODE_LEAVE:
			ZEND_VM_LEAVE();
		case ZEND_USER_OPCODE_DISPATCH:
			ZEND_VM_DISPATCH(opline->opcode, opline);
		default:
			ZEND_VM_DISPATCH((zend_uchar)(ret & 0xff), opline);
	}
}

static int ZEND_FASTCALL  ZEND_DISCARD_EXCEPTION_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	if (EX(delayed_exception) != NULL) {
		/* discard the previously thrown exception */
		OBJ_RELEASE(EX(delayed_exception));
		EX(delayed_exception) = NULL;
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FAST_CALL_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (opline->extended_value &&
	    UNEXPECTED(EG(prev_exception) != NULL)) {
	    /* in case of unhandled exception jump to catch block instead of finally */
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE();
	}
	EX(fast_ret) = opline + 1;
	EX(delayed_exception) = NULL;
	ZEND_VM_SET_OPCODE(opline->op1.jmp_addr);
	ZEND_VM_CONTINUE();
}

static int ZEND_FASTCALL  ZEND_FAST_RET_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	if (EX(fast_ret)) {
		ZEND_VM_SET_OPCODE(EX(fast_ret));
		ZEND_VM_CONTINUE();
	} else {
		/* special case for unhandled exceptions */
		USE_OPLINE

		if (opline->extended_value == ZEND_FAST_RET_TO_FINALLY) {
			ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
			ZEND_VM_CONTINUE();
		} else {
			EG(exception) = EX(delayed_exception);
			EX(delayed_exception) = NULL;
			if (opline->extended_value == ZEND_FAST_RET_TO_CATCH) {
				ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
				ZEND_VM_CONTINUE();
			} else if (UNEXPECTED((EX(op_array)->fn_flags & ZEND_ACC_GENERATOR) != 0)) {
				return ZEND_GENERATOR_RETURN_SPEC_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			} else {
				return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
			}
		}
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_CLASS_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_CONST == IS_UNUSED) {
		Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(NULL, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {

		zval *class_name = opline->op2.zv;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(class_name))) {
				Z_CE_P(EX_VAR(opline->result.var)) = CACHED_PTR(Z_CACHE_SLOT_P(class_name));
			} else {
				Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class_by_name(Z_STR_P(class_name), opline->op2.zv + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(Z_CACHE_SLOT_P(class_name), Z_CE_P(EX_VAR(opline->result.var)));
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			Z_CE_P(EX_VAR(opline->result.var)) = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(Z_STR_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name_ptr, *function_name, *func;
	call_slot *call = EX(call_slots) + opline->result.num;

	if (IS_CONST == IS_CONST) {
		function_name_ptr = function_name = (zval*)(opline->op2.zv+1);
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
			call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
		} else if (UNEXPECTED((func = zend_hash_find(EG(function_table), Z_STR_P(function_name))) == NULL)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			call->fbc = Z_FUNC_P(func);
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), call->fbc);
		}

		call->object = NULL;
		call->called_scope = NULL;
		call->num_additional_args = 0;
		call->is_ctor_call = 0;
		EX(call) = call;

		/*CHECK_EXCEPTION();*/
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_string *lcname;


		SAVE_OPLINE();
		function_name_ptr = function_name = opline->op2.zv;

		ZVAL_DEREF(function_name);
		if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
			if (Z_STRVAL_P(function_name)[0] == '\\') {
				lcname = STR_ALLOC(Z_STRLEN_P(function_name) - 1, 0);
				zend_str_tolower_copy(lcname->val, Z_STRVAL_P(function_name) + 1, Z_STRLEN_P(function_name) - 1);
			} else {
				lcname = STR_ALLOC(Z_STRLEN_P(function_name), 0);
				zend_str_tolower_copy(lcname->val, Z_STRVAL_P(function_name), Z_STRLEN_P(function_name));
			}
			if (UNEXPECTED((func = zend_hash_find(EG(function_table), lcname)) == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(function_name));
			}
			STR_FREE(lcname);

			call->fbc = Z_FUNC_P(func);
			call->object = NULL;
			call->called_scope = NULL;
			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_CONST != IS_CONST && IS_CONST != IS_TMP_VAR &&
		    EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT) &&
			Z_OBJ_HANDLER_P(function_name, get_closure) &&
			Z_OBJ_HANDLER_P(function_name, get_closure)(function_name, &call->called_scope, &call->fbc, &call->object TSRMLS_CC) == SUCCESS) {
			if (call->object) {
				GC_REFCOUNT(call->object)++;
			}
			if (IS_CONST == IS_VAR && 0 && Z_REFCOUNT_P(function_name) == 1 &&
			    call->fbc->common.fn_flags & ZEND_ACC_CLOSURE) {
				/* Delay closure destruction until its invocation */
				call->fbc->common.prototype = (zend_function*)function_name_ptr;
			} else {

			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_CONST != IS_CONST &&
				EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY) &&
				zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2) {
			zval *obj;
			zval *method;

			obj = zend_hash_index_find(Z_ARRVAL_P(function_name), 0);
			method = zend_hash_index_find(Z_ARRVAL_P(function_name), 1);

			if (!obj || !method) {
				zend_error_noreturn(E_ERROR, "Array callback has to contain indices 0 and 1");
			}

			if (Z_TYPE_P(obj) != IS_STRING && Z_TYPE_P(obj) != IS_OBJECT) {
				zend_error_noreturn(E_ERROR, "First array member is not a valid class name or object");
			}

			if (Z_TYPE_P(method) != IS_STRING) {
				zend_error_noreturn(E_ERROR, "Second array member is not a valid method");
			}

			if (Z_TYPE_P(obj) == IS_STRING) {
				call->object = NULL;
				call->called_scope = zend_fetch_class_by_name(Z_STR_P(obj), NULL, 0 TSRMLS_CC);
				if (UNEXPECTED(call->called_scope == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}

				if (call->called_scope->get_static_method) {
					call->fbc = call->called_scope->get_static_method(call->called_scope, Z_STR_P(method) TSRMLS_CC);
				} else {
					call->fbc = zend_std_get_static_method(call->called_scope, Z_STR_P(method), NULL TSRMLS_CC);
				}
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", call->called_scope->name->val, Z_STRVAL_P(method));
				}
			} else {
				call->called_scope = Z_OBJCE_P(obj);
				call->object = Z_OBJ_P(obj);

				call->fbc = Z_OBJ_HT_P(obj)->get_method(&call->object, Z_STR_P(method), NULL TSRMLS_CC);
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(method));
				}

				if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
					call->object = NULL;
				} else {
					GC_REFCOUNT(call->object)++; /* For $this pointer */
				}
			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Function name must be a string");
			ZEND_VM_NEXT_OPCODE(); /* Never reached */
		}
	}
}


static int ZEND_FASTCALL  ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *func_name;
	zval *func;
	call_slot *call = EX(call_slots) + opline->result.num;

	func_name = opline->op2.zv + 1;
	if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
		call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
	} else if ((func = zend_hash_find(EG(function_table), Z_STR_P(func_name))) == NULL) {
		func_name++;
		if (UNEXPECTED((func = zend_hash_find(EG(function_table), Z_STR_P(func_name))) == NULL)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			call->fbc = Z_FUNC_P(func);
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), call->fbc);
		}
	} else {
		call->fbc = Z_FUNC_P(func);
		CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), call->fbc);
	}

	call->object = NULL;
	call->called_scope = NULL;
	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RECV_INIT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_uint arg_num = opline->op1.num;
	zval *arguments = EX(prev_execute_data)->function_state.arguments;
	zend_uint arg_count = Z_LVAL_P(arguments);
	zval *var_ptr;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->result.var TSRMLS_CC);
	if (UNEXPECTED(Z_REFCOUNTED_P(var_ptr))) Z_DELREF_P(var_ptr);
	if (arg_num > arg_count) {
		ZVAL_COPY_VALUE(var_ptr, opline->op2.zv);
		if (Z_OPT_CONSTANT_P(var_ptr)) {
			zval_update_constant(var_ptr, 0 TSRMLS_CC);
		} else {
			/* IS_CONST can't be IS_OBJECT, IS_RESOURCE or IS_REFERENCE */
			if (UNEXPECTED(Z_OPT_COPYABLE_P(var_ptr))) {
				_zval_copy_ctor_func(var_ptr ZEND_FILE_LINE_CC);
			}
		}
	} else {
		zval *param = arguments - arg_count + arg_num - 1;
		ZVAL_COPY(var_ptr, param);
	}

	if (UNEXPECTED((EX(op_array)->fn_flags & ZEND_ACC_HAS_TYPE_HINTS) != 0)) {
		zend_verify_arg_type((zend_function *) EX(op_array), arg_num, var_ptr, opline->extended_value TSRMLS_CC);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BRK_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_brk_cont_element *el;

	SAVE_OPLINE();
	el = zend_brk_cont(Z_LVAL_P(opline->op2.zv), opline->op1.opline_num,
	                   EX(op_array), execute_data TSRMLS_CC);
	ZEND_VM_JMP(EX(op_array)->opcodes + el->brk);
}

static int ZEND_FASTCALL  ZEND_CONT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_brk_cont_element *el;

	SAVE_OPLINE();
	el = zend_brk_cont(Z_LVAL_P(opline->op2.zv), opline->op1.opline_num,
	                   EX(op_array), execute_data TSRMLS_CC);
	ZEND_VM_JMP(EX(op_array)->opcodes + el->cont);
}

static int ZEND_FASTCALL  ZEND_GOTO_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_op *brk_opline;
	USE_OPLINE
	zend_brk_cont_element *el;

	SAVE_OPLINE();
	el = zend_brk_cont(Z_LVAL_P(opline->op2.zv), opline->extended_value,
 	                   EX(op_array), execute_data TSRMLS_CC);

	brk_opline = EX(op_array)->opcodes + el->brk;

	switch (brk_opline->opcode) {
		case ZEND_SWITCH_FREE:
			if (!(brk_opline->extended_value & EXT_TYPE_FREE_ON_RETURN)) {
				zval_ptr_dtor(EX_VAR(brk_opline->op1.var));
			}
			break;
		case ZEND_FREE:
			if (!(brk_opline->extended_value & EXT_TYPE_FREE_ON_RETURN)) {
				zval_dtor(EX_VAR(brk_opline->op1.var));
			}
			break;
	}
	ZEND_VM_JMP(opline->op1.jmp_addr);
}

static int ZEND_FASTCALL  ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_class_entry *ce = Z_CE_P(EX_VAR(opline->op1.var));
	zend_class_entry *iface;

	SAVE_OPLINE();
	if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
		iface = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
	} else {
		iface = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, opline->extended_value TSRMLS_CC);
		if (UNEXPECTED(iface == NULL)) {
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		}
		CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), iface);
	}

	if (UNEXPECTED((iface->ce_flags & ZEND_ACC_INTERFACE) == 0)) {
		zend_error_noreturn(E_ERROR, "%s cannot implement %s - it is not an interface", ce->name->val, iface->name->val);
	}
	zend_do_implement_interface(ce, iface TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_CLASS_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_TMP_VAR == IS_UNUSED) {
		Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(NULL, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_op2;
		zval *class_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (IS_TMP_VAR == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(class_name))) {
				Z_CE_P(EX_VAR(opline->result.var)) = CACHED_PTR(Z_CACHE_SLOT_P(class_name));
			} else {
				Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class_by_name(Z_STR_P(class_name), opline->op2.zv + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(Z_CACHE_SLOT_P(class_name), Z_CE_P(EX_VAR(opline->result.var)));
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			Z_CE_P(EX_VAR(opline->result.var)) = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(Z_STR_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		zval_dtor(free_op2.var);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name_ptr, *function_name, *func;
	call_slot *call = EX(call_slots) + opline->result.num;

	if (IS_TMP_VAR == IS_CONST) {
		function_name_ptr = function_name = (zval*)(opline->op2.zv+1);
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
			call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
		} else if (UNEXPECTED((func = zend_hash_find(EG(function_table), Z_STR_P(function_name))) == NULL)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			call->fbc = Z_FUNC_P(func);
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), call->fbc);
		}

		call->object = NULL;
		call->called_scope = NULL;
		call->num_additional_args = 0;
		call->is_ctor_call = 0;
		EX(call) = call;

		/*CHECK_EXCEPTION();*/
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_string *lcname;
		zend_free_op free_op2;

		SAVE_OPLINE();
		function_name_ptr = function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		ZVAL_DEREF(function_name);
		if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
			if (Z_STRVAL_P(function_name)[0] == '\\') {
				lcname = STR_ALLOC(Z_STRLEN_P(function_name) - 1, 0);
				zend_str_tolower_copy(lcname->val, Z_STRVAL_P(function_name) + 1, Z_STRLEN_P(function_name) - 1);
			} else {
				lcname = STR_ALLOC(Z_STRLEN_P(function_name), 0);
				zend_str_tolower_copy(lcname->val, Z_STRVAL_P(function_name), Z_STRLEN_P(function_name));
			}
			if (UNEXPECTED((func = zend_hash_find(EG(function_table), lcname)) == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(function_name));
			}
			STR_FREE(lcname);
			zval_dtor(free_op2.var);

			call->fbc = Z_FUNC_P(func);
			call->object = NULL;
			call->called_scope = NULL;
			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_TMP_VAR != IS_CONST && IS_TMP_VAR != IS_TMP_VAR &&
		    EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT) &&
			Z_OBJ_HANDLER_P(function_name, get_closure) &&
			Z_OBJ_HANDLER_P(function_name, get_closure)(function_name, &call->called_scope, &call->fbc, &call->object TSRMLS_CC) == SUCCESS) {
			if (call->object) {
				GC_REFCOUNT(call->object)++;
			}
			if (IS_TMP_VAR == IS_VAR && 1 && Z_REFCOUNT_P(function_name) == 1 &&
			    call->fbc->common.fn_flags & ZEND_ACC_CLOSURE) {
				/* Delay closure destruction until its invocation */
				call->fbc->common.prototype = (zend_function*)function_name_ptr;
			} else {
				zval_dtor(free_op2.var);
			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_TMP_VAR != IS_CONST &&
				EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY) &&
				zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2) {
			zval *obj;
			zval *method;

			obj = zend_hash_index_find(Z_ARRVAL_P(function_name), 0);
			method = zend_hash_index_find(Z_ARRVAL_P(function_name), 1);

			if (!obj || !method) {
				zend_error_noreturn(E_ERROR, "Array callback has to contain indices 0 and 1");
			}

			if (Z_TYPE_P(obj) != IS_STRING && Z_TYPE_P(obj) != IS_OBJECT) {
				zend_error_noreturn(E_ERROR, "First array member is not a valid class name or object");
			}

			if (Z_TYPE_P(method) != IS_STRING) {
				zend_error_noreturn(E_ERROR, "Second array member is not a valid method");
			}

			if (Z_TYPE_P(obj) == IS_STRING) {
				call->object = NULL;
				call->called_scope = zend_fetch_class_by_name(Z_STR_P(obj), NULL, 0 TSRMLS_CC);
				if (UNEXPECTED(call->called_scope == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}

				if (call->called_scope->get_static_method) {
					call->fbc = call->called_scope->get_static_method(call->called_scope, Z_STR_P(method) TSRMLS_CC);
				} else {
					call->fbc = zend_std_get_static_method(call->called_scope, Z_STR_P(method), NULL TSRMLS_CC);
				}
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", call->called_scope->name->val, Z_STRVAL_P(method));
				}
			} else {
				call->called_scope = Z_OBJCE_P(obj);
				call->object = Z_OBJ_P(obj);

				call->fbc = Z_OBJ_HT_P(obj)->get_method(&call->object, Z_STR_P(method), NULL TSRMLS_CC);
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(method));
				}

				if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
					call->object = NULL;
				} else {
					GC_REFCOUNT(call->object)++; /* For $this pointer */
				}
			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			zval_dtor(free_op2.var);
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Function name must be a string");
			ZEND_VM_NEXT_OPCODE(); /* Never reached */
		}
	}
}


static int ZEND_FASTCALL  ZEND_FETCH_CLASS_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_VAR == IS_UNUSED) {
		Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(NULL, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_free_op free_op2;
		zval *class_name = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(class_name))) {
				Z_CE_P(EX_VAR(opline->result.var)) = CACHED_PTR(Z_CACHE_SLOT_P(class_name));
			} else {
				Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class_by_name(Z_STR_P(class_name), opline->op2.zv + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(Z_CACHE_SLOT_P(class_name), Z_CE_P(EX_VAR(opline->result.var)));
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			Z_CE_P(EX_VAR(opline->result.var)) = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(Z_STR_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		zval_ptr_dtor_nogc(free_op2.var);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name_ptr, *function_name, *func;
	call_slot *call = EX(call_slots) + opline->result.num;

	if (IS_VAR == IS_CONST) {
		function_name_ptr = function_name = (zval*)(opline->op2.zv+1);
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
			call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
		} else if (UNEXPECTED((func = zend_hash_find(EG(function_table), Z_STR_P(function_name))) == NULL)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			call->fbc = Z_FUNC_P(func);
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), call->fbc);
		}

		call->object = NULL;
		call->called_scope = NULL;
		call->num_additional_args = 0;
		call->is_ctor_call = 0;
		EX(call) = call;

		/*CHECK_EXCEPTION();*/
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_string *lcname;
		zend_free_op free_op2;

		SAVE_OPLINE();
		function_name_ptr = function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		ZVAL_DEREF(function_name);
		if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
			if (Z_STRVAL_P(function_name)[0] == '\\') {
				lcname = STR_ALLOC(Z_STRLEN_P(function_name) - 1, 0);
				zend_str_tolower_copy(lcname->val, Z_STRVAL_P(function_name) + 1, Z_STRLEN_P(function_name) - 1);
			} else {
				lcname = STR_ALLOC(Z_STRLEN_P(function_name), 0);
				zend_str_tolower_copy(lcname->val, Z_STRVAL_P(function_name), Z_STRLEN_P(function_name));
			}
			if (UNEXPECTED((func = zend_hash_find(EG(function_table), lcname)) == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(function_name));
			}
			STR_FREE(lcname);
			zval_ptr_dtor_nogc(free_op2.var);

			call->fbc = Z_FUNC_P(func);
			call->object = NULL;
			call->called_scope = NULL;
			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_VAR != IS_CONST && IS_VAR != IS_TMP_VAR &&
		    EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT) &&
			Z_OBJ_HANDLER_P(function_name, get_closure) &&
			Z_OBJ_HANDLER_P(function_name, get_closure)(function_name, &call->called_scope, &call->fbc, &call->object TSRMLS_CC) == SUCCESS) {
			if (call->object) {
				GC_REFCOUNT(call->object)++;
			}
			if (IS_VAR == IS_VAR && (free_op2.var != NULL) && Z_REFCOUNT_P(function_name) == 1 &&
			    call->fbc->common.fn_flags & ZEND_ACC_CLOSURE) {
				/* Delay closure destruction until its invocation */
				call->fbc->common.prototype = (zend_function*)function_name_ptr;
			} else {
				zval_ptr_dtor_nogc(free_op2.var);
			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_VAR != IS_CONST &&
				EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY) &&
				zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2) {
			zval *obj;
			zval *method;

			obj = zend_hash_index_find(Z_ARRVAL_P(function_name), 0);
			method = zend_hash_index_find(Z_ARRVAL_P(function_name), 1);

			if (!obj || !method) {
				zend_error_noreturn(E_ERROR, "Array callback has to contain indices 0 and 1");
			}

			if (Z_TYPE_P(obj) != IS_STRING && Z_TYPE_P(obj) != IS_OBJECT) {
				zend_error_noreturn(E_ERROR, "First array member is not a valid class name or object");
			}

			if (Z_TYPE_P(method) != IS_STRING) {
				zend_error_noreturn(E_ERROR, "Second array member is not a valid method");
			}

			if (Z_TYPE_P(obj) == IS_STRING) {
				call->object = NULL;
				call->called_scope = zend_fetch_class_by_name(Z_STR_P(obj), NULL, 0 TSRMLS_CC);
				if (UNEXPECTED(call->called_scope == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}

				if (call->called_scope->get_static_method) {
					call->fbc = call->called_scope->get_static_method(call->called_scope, Z_STR_P(method) TSRMLS_CC);
				} else {
					call->fbc = zend_std_get_static_method(call->called_scope, Z_STR_P(method), NULL TSRMLS_CC);
				}
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", call->called_scope->name->val, Z_STRVAL_P(method));
				}
			} else {
				call->called_scope = Z_OBJCE_P(obj);
				call->object = Z_OBJ_P(obj);

				call->fbc = Z_OBJ_HT_P(obj)->get_method(&call->object, Z_STR_P(method), NULL TSRMLS_CC);
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(method));
				}

				if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
					call->object = NULL;
				} else {
					GC_REFCOUNT(call->object)++; /* For $this pointer */
				}
			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			zval_ptr_dtor_nogc(free_op2.var);
			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Function name must be a string");
			ZEND_VM_NEXT_OPCODE(); /* Never reached */
		}
	}
}


static int ZEND_FASTCALL  ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_UNUSED == IS_UNUSED) {
		Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(NULL, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {

		zval *class_name = NULL;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(class_name))) {
				Z_CE_P(EX_VAR(opline->result.var)) = CACHED_PTR(Z_CACHE_SLOT_P(class_name));
			} else {
				Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class_by_name(Z_STR_P(class_name), opline->op2.zv + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(Z_CACHE_SLOT_P(class_name), Z_CE_P(EX_VAR(opline->result.var)));
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			Z_CE_P(EX_VAR(opline->result.var)) = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(Z_STR_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_CLASS_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (EG(exception)) {
		zend_exception_save(TSRMLS_C);
	}
	if (IS_CV == IS_UNUSED) {
		Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(NULL, opline->extended_value TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {

		zval *class_name = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		if (IS_CV == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(class_name))) {
				Z_CE_P(EX_VAR(opline->result.var)) = CACHED_PTR(Z_CACHE_SLOT_P(class_name));
			} else {
				Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class_by_name(Z_STR_P(class_name), opline->op2.zv + 1, opline->extended_value TSRMLS_CC);
				CACHE_PTR(Z_CACHE_SLOT_P(class_name), Z_CE_P(EX_VAR(opline->result.var)));
			}
		} else if (Z_TYPE_P(class_name) == IS_OBJECT) {
			Z_CE_P(EX_VAR(opline->result.var)) = Z_OBJCE_P(class_name);
		} else if (Z_TYPE_P(class_name) == IS_STRING) {
			Z_CE_P(EX_VAR(opline->result.var)) = zend_fetch_class(Z_STR_P(class_name), opline->extended_value TSRMLS_CC);
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Class name must be a valid object or a string");
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name_ptr, *function_name, *func;
	call_slot *call = EX(call_slots) + opline->result.num;

	if (IS_CV == IS_CONST) {
		function_name_ptr = function_name = (zval*)(opline->op2.zv+1);
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
			call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
		} else if (UNEXPECTED((func = zend_hash_find(EG(function_table), Z_STR_P(function_name))) == NULL)) {
			SAVE_OPLINE();
			zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(opline->op2.zv));
		} else {
			call->fbc = Z_FUNC_P(func);
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), call->fbc);
		}

		call->object = NULL;
		call->called_scope = NULL;
		call->num_additional_args = 0;
		call->is_ctor_call = 0;
		EX(call) = call;

		/*CHECK_EXCEPTION();*/
		ZEND_VM_NEXT_OPCODE();
	} else {
		zend_string *lcname;


		SAVE_OPLINE();
		function_name_ptr = function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		ZVAL_DEREF(function_name);
		if (EXPECTED(Z_TYPE_P(function_name) == IS_STRING)) {
			if (Z_STRVAL_P(function_name)[0] == '\\') {
				lcname = STR_ALLOC(Z_STRLEN_P(function_name) - 1, 0);
				zend_str_tolower_copy(lcname->val, Z_STRVAL_P(function_name) + 1, Z_STRLEN_P(function_name) - 1);
			} else {
				lcname = STR_ALLOC(Z_STRLEN_P(function_name), 0);
				zend_str_tolower_copy(lcname->val, Z_STRVAL_P(function_name), Z_STRLEN_P(function_name));
			}
			if (UNEXPECTED((func = zend_hash_find(EG(function_table), lcname)) == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(function_name));
			}
			STR_FREE(lcname);

			call->fbc = Z_FUNC_P(func);
			call->object = NULL;
			call->called_scope = NULL;
			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_CV != IS_CONST && IS_CV != IS_TMP_VAR &&
		    EXPECTED(Z_TYPE_P(function_name) == IS_OBJECT) &&
			Z_OBJ_HANDLER_P(function_name, get_closure) &&
			Z_OBJ_HANDLER_P(function_name, get_closure)(function_name, &call->called_scope, &call->fbc, &call->object TSRMLS_CC) == SUCCESS) {
			if (call->object) {
				GC_REFCOUNT(call->object)++;
			}
			if (IS_CV == IS_VAR && 0 && Z_REFCOUNT_P(function_name) == 1 &&
			    call->fbc->common.fn_flags & ZEND_ACC_CLOSURE) {
				/* Delay closure destruction until its invocation */
				call->fbc->common.prototype = (zend_function*)function_name_ptr;
			} else {

			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else if (IS_CV != IS_CONST &&
				EXPECTED(Z_TYPE_P(function_name) == IS_ARRAY) &&
				zend_hash_num_elements(Z_ARRVAL_P(function_name)) == 2) {
			zval *obj;
			zval *method;

			obj = zend_hash_index_find(Z_ARRVAL_P(function_name), 0);
			method = zend_hash_index_find(Z_ARRVAL_P(function_name), 1);

			if (!obj || !method) {
				zend_error_noreturn(E_ERROR, "Array callback has to contain indices 0 and 1");
			}

			if (Z_TYPE_P(obj) != IS_STRING && Z_TYPE_P(obj) != IS_OBJECT) {
				zend_error_noreturn(E_ERROR, "First array member is not a valid class name or object");
			}

			if (Z_TYPE_P(method) != IS_STRING) {
				zend_error_noreturn(E_ERROR, "Second array member is not a valid method");
			}

			if (Z_TYPE_P(obj) == IS_STRING) {
				call->object = NULL;
				call->called_scope = zend_fetch_class_by_name(Z_STR_P(obj), NULL, 0 TSRMLS_CC);
				if (UNEXPECTED(call->called_scope == NULL)) {
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}

				if (call->called_scope->get_static_method) {
					call->fbc = call->called_scope->get_static_method(call->called_scope, Z_STR_P(method) TSRMLS_CC);
				} else {
					call->fbc = zend_std_get_static_method(call->called_scope, Z_STR_P(method), NULL TSRMLS_CC);
				}
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", call->called_scope->name->val, Z_STRVAL_P(method));
				}
			} else {
				call->called_scope = Z_OBJCE_P(obj);
				call->object = Z_OBJ_P(obj);

				call->fbc = Z_OBJ_HT_P(obj)->get_method(&call->object, Z_STR_P(method), NULL TSRMLS_CC);
				if (UNEXPECTED(call->fbc == NULL)) {
					zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(method));
				}

				if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
					call->object = NULL;
				} else {
					GC_REFCOUNT(call->object)++; /* For $this pointer */
				}
			}

			call->num_additional_args = 0;
			call->is_ctor_call = 0;
			EX(call) = call;

			CHECK_EXCEPTION();
			ZEND_VM_NEXT_OPCODE();
		} else {
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			zend_error_noreturn(E_ERROR, "Function name must be a string");
			ZEND_VM_NEXT_OPCODE(); /* Never reached */
		}
	}
}


static int ZEND_FASTCALL  ZEND_BW_NOT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_not_function(EX_VAR(opline->result.var),
		opline->op1.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_NOT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_not_function(EX_VAR(opline->result.var),
		opline->op1.zv TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ECHO_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *z;

	SAVE_OPLINE();
	z = opline->op1.zv;

	zend_print_variable(z);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRINT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_LONG(EX_VAR(opline->result.var), 1);
	return ZEND_ECHO_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_JMPZ_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int ret;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val TSRMLS_CC);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (!ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int ret;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val TSRMLS_CC);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPZNZ_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val TSRMLS_CC);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (EXPECTED(retval != 0)) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on true to %d\n", opline->extended_value);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	} else {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on false to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
}

static int ZEND_FASTCALL  ZEND_JMPZ_EX_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val TSRMLS_CC);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	ZVAL_BOOL(EX_VAR(opline->result.var), retval);
	if (!retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_EX_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = opline->op1.zv;

	if (IS_CONST == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val TSRMLS_CC);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	ZVAL_BOOL(EX_VAR(opline->result.var), retval);
	if (retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DO_FCALL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *fname = opline->op1.zv;
	zval *func;
	call_slot *call = EX(call_slots) + opline->op2.num;

	if (CACHED_PTR(Z_CACHE_SLOT_P(fname))) {
		EX(function_state).function = CACHED_PTR(Z_CACHE_SLOT_P(fname));
	} else if (UNEXPECTED((func = zend_hash_find(EG(function_table), Z_STR_P(fname))) == NULL)) {
	    SAVE_OPLINE();
		zend_error_noreturn(E_ERROR, "Call to undefined function %s()", Z_STRVAL_P(fname));
	} else {
		EX(function_state).function = Z_FUNC_P(func);
		CACHE_PTR(Z_CACHE_SLOT_P(fname), EX(function_state).function);
	}

	call->fbc = EX(function_state).function;
	call->object = NULL;
	call->called_scope = NULL;
	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	return zend_do_fcall_common_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_RETURN_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;


	SAVE_OPLINE();
	retval_ptr = opline->op1.zv;

	if (!EX(return_value)) {

	} else {
		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
			if (IS_CONST != IS_TMP_VAR) {
				zval_opt_copy_ctor(EX(return_value));
			}

		} else if (Z_ISREF_P(retval_ptr)) {
			ZVAL_DUP(EX(return_value), Z_REFVAL_P(retval_ptr));

		} else {
			ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
			if (IS_CONST == IS_CV) {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) Z_ADDREF_P(retval_ptr);
			}
		}
	}
	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;


	SAVE_OPLINE();

	do {
		if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR ||
		    (IS_CONST == IS_VAR && opline->extended_value == ZEND_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = opline->op1.zv;
			if (!EX(return_value)) {
				if (IS_CONST == IS_TMP_VAR) {

				}
			} else if (!0) { /* Not a temp var */
				ZVAL_DUP(EX(return_value), retval_ptr);
			} else {
				ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
			}
			break;
		}

		retval_ptr = NULL;

		if (IS_CONST == IS_VAR && UNEXPECTED(Z_TYPE_P(retval_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot return string offsets by reference");
		}

		if (IS_CONST == IS_VAR && !Z_ISREF_P(retval_ptr)) {
			if (opline->extended_value == ZEND_RETURNS_FUNCTION &&
			    (Z_VAR_FLAGS_P(retval_ptr) & IS_VAR_RET_REF)) {
			} else {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EX(return_value)) {
					zval tmp;
					ZVAL_DUP(&tmp, retval_ptr);
					ZVAL_NEW_REF(EX(return_value), &tmp);
				}
				break;
			}
		}

		if (EX(return_value)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			ZVAL_COPY(EX(return_value), retval_ptr);
		}
	} while (0);

	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_THROW_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval exception;


	SAVE_OPLINE();
	value = opline->op1.zv;

	if (IS_CONST == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Can only throw objects");
	}

	zend_exception_save(TSRMLS_C);
	if (IS_CONST == IS_CONST) {
		ZVAL_DUP(&exception, value);
		value = &exception;
	} else if (IS_CONST != IS_TMP_VAR) {
		if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
	}

	zend_throw_exception_object(value TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);

	HANDLE_EXCEPTION();
}

static int ZEND_FASTCALL  ZEND_SEND_VAL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (opline->extended_value == ZEND_DO_FCALL_BY_NAME) {
		int arg_num = opline->op2.num + EX(call)->num_additional_args;
		if (ARG_MUST_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
			zend_error_noreturn(E_ERROR, "Cannot pass parameter %d by reference", arg_num);
		}
	}

	{
		zval *top;
		zval *value;


		value = opline->op1.zv;
		top = zend_vm_stack_top_inc(TSRMLS_C);
		ZVAL_COPY_VALUE(top, value);
		if (!0) {
			zval_opt_copy_ctor(top);
		}

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *retval = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	/* PHP 3.0 returned "" for false and 1 for true, here we use 0 and 1 for now */
	ZVAL_BOOL(retval, i_zend_is_true(opline->op1.zv TSRMLS_CC));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CLONE_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = opline->op1.zv;

	if (IS_CONST == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name->val);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name->val, EG(scope) ? EG(scope)->name->val : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name->val, EG(scope) ? EG(scope)->name->val : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		ZVAL_OBJ(EX_VAR(opline->result.var), clone_call(obj TSRMLS_CC));
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(EX_VAR(opline->result.var));
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CAST_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr, *expr_ptr;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	expr = expr_ptr = opline->op1.zv;
	if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		ZVAL_DEREF(expr);
	}
	if (Z_TYPE_P(expr) == opline->extended_value) {
		ZVAL_COPY_VALUE(result, expr);
		if (IS_CONST == IS_CONST || expr != expr_ptr) {
			zval_opt_copy_ctor(result);

		} else if (IS_CONST == IS_CV) {
			if (Z_OPT_REFCOUNTED_P(expr)) Z_ADDREF_P(expr);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (opline->extended_value != IS_STRING) {
		ZVAL_COPY_VALUE(result, expr);
		if (!0) {
			zval_opt_copy_ctor(result);
		}
	}

	switch (opline->extended_value) {
		case IS_NULL:
			convert_to_null(result);
			break;
		case IS_BOOL:
			convert_to_boolean(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		case IS_DOUBLE:
			convert_to_double(result);
			break;
		case IS_STRING: {
			zval var_copy;
			int use_copy;

			zend_make_printable_zval(expr, &var_copy, &use_copy);
			if (use_copy) {
				ZVAL_COPY_VALUE(result, &var_copy);
				if (0) {

				}
			} else {
				ZVAL_COPY_VALUE(result, expr);
				if (!0) {
					zval_opt_copy_ctor(result);
				}
			}
			break;
		}
		case IS_ARRAY:
			convert_to_array(result);
			break;
		case IS_OBJECT:
			convert_to_object(result);
			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_op_array *new_op_array=NULL;

	zval *inc_filename;
	zval tmp_inc_filename;
	zend_bool failure_retval=0;

	SAVE_OPLINE();
	inc_filename = opline->op1.zv;

	ZVAL_UNDEF(&tmp_inc_filename);
	if (Z_TYPE_P(inc_filename) != IS_STRING) {
		ZVAL_DUP(&tmp_inc_filename, inc_filename);
		convert_to_string(&tmp_inc_filename);
		inc_filename = &tmp_inc_filename;
	}

	if (opline->extended_value != ZEND_EVAL && strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)) {
		if (opline->extended_value == ZEND_INCLUDE_ONCE || opline->extended_value == ZEND_INCLUDE) {
			zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		} else {
			zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		}
	} else {
		switch (opline->extended_value) {
			case ZEND_INCLUDE_ONCE:
			case ZEND_REQUIRE_ONCE: {
					zend_file_handle file_handle;
					char *resolved_path;

					resolved_path = zend_resolve_path(Z_STRVAL_P(inc_filename), Z_STRLEN_P(inc_filename) TSRMLS_CC);
					if (resolved_path) {
						failure_retval = zend_hash_str_exists(&EG(included_files), resolved_path, strlen(resolved_path));
					} else {
						resolved_path = Z_STRVAL_P(inc_filename);
					}

					if (failure_retval) {
						/* do nothing, file already included */
					} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {

						if (!file_handle.opened_path) {
							file_handle.opened_path = estrdup(resolved_path);
						}

						if (zend_hash_str_add_empty_element(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path))) {
							new_op_array = zend_compile_file(&file_handle, (opline->extended_value==ZEND_INCLUDE_ONCE?ZEND_INCLUDE:ZEND_REQUIRE) TSRMLS_CC);
							zend_destroy_file_handle(&file_handle TSRMLS_CC);
						} else {
							zend_file_handle_dtor(&file_handle TSRMLS_CC);
							failure_retval=1;
						}
					} else {
						if (opline->extended_value == ZEND_INCLUDE_ONCE) {
							zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						} else {
							zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						}
					}
					if (resolved_path != Z_STRVAL_P(inc_filename)) {
						efree(resolved_path);
					}
				}
				break;
			case ZEND_INCLUDE:
			case ZEND_REQUIRE:
				new_op_array = compile_filename(opline->extended_value, inc_filename TSRMLS_CC);
				break;
			case ZEND_EVAL: {
					char *eval_desc = zend_make_compiled_string_description("eval()'d code" TSRMLS_CC);

					new_op_array = zend_compile_string(inc_filename, eval_desc TSRMLS_CC);
					efree(eval_desc);
				}
				break;
			EMPTY_SWITCH_DEFAULT_CASE()
		}
	}
	if (Z_TYPE(tmp_inc_filename) != IS_UNDEF) {
		zval_ptr_dtor(&tmp_inc_filename);
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		HANDLE_EXCEPTION();
	} else if (EXPECTED(new_op_array != NULL)) {
		zval *return_value = NULL;

		EG(active_op_array) = new_op_array;
		if (RETURN_VALUE_USED(opline)) {
			return_value = EX_VAR(opline->result.var);
		}

		EX(function_state).function = (zend_function *) new_op_array;
		EX(object) = NULL;

		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		if (EXPECTED(zend_execute_ex == execute_ex)) {
		    i_create_execute_data_from_op_array(new_op_array, return_value, VM_FRAME_NESTED_CODE TSRMLS_CC);
			ZEND_VM_ENTER();
		} else {
			zend_execute(new_op_array, return_value TSRMLS_CC);
		}

		EX(function_state).function = (zend_function *) EX(op_array);

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		destroy_op_array(new_op_array TSRMLS_CC);
		efree(new_op_array);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}

	} else if (RETURN_VALUE_USED(opline)) {
		ZVAL_BOOL(EX_VAR(opline->result.var), failure_retval);
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FE_RESET_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *array_ptr, *array_ref, iterator;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	zend_class_entry *ce = NULL;
	zend_bool is_empty = 0;

	SAVE_OPLINE();

	if ((IS_CONST == IS_CV || IS_CONST == IS_VAR) &&
	    (opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
		array_ptr = array_ref = NULL;
		ZVAL_DEREF(array_ptr);
		if (Z_TYPE_P(array_ptr) == IS_ARRAY) {
			if (!Z_ISREF_P(array_ref)) {
				SEPARATE_ZVAL(array_ptr);
				array_ref = array_ptr;
				if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
					ZVAL_NEW_REF(array_ptr, array_ptr);
					array_ref = array_ptr;
					array_ptr = Z_REFVAL_P(array_ptr);
				}
			}
			if (Z_REFCOUNTED_P(array_ref)) Z_ADDREF_P(array_ref);
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			if(Z_OBJ_HT_P(array_ptr)->get_class_entry == NULL) {
				zend_error(E_WARNING, "foreach() cannot iterate over objects without PHP class");
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}

			ce = Z_OBJCE_P(array_ptr);
			if (!ce || ce->get_iterator == NULL) {
				if (!Z_ISREF_P(array_ref)) {
					SEPARATE_ZVAL(array_ptr);
				}
				Z_ADDREF_P(array_ptr);
			}
			array_ref = array_ptr;
		} else {
			if (Z_REFCOUNTED_P(array_ref)) Z_ADDREF_P(array_ref);
		}
	} else {
		array_ptr = array_ref = opline->op1.zv;
		ZVAL_DEREF(array_ptr);
		if (0) { /* IS_TMP_VAR */
			zval tmp;

			ZVAL_COPY_VALUE(&tmp, array_ptr);
			array_ptr = &tmp;
			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
				ce = Z_OBJCE_P(array_ptr);
				if (ce && ce->get_iterator) {
					Z_DELREF_P(array_ref);
				}
			}
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			ce = Z_OBJCE_P(array_ptr);
			if (!ce || !ce->get_iterator) {
				if (IS_CONST == IS_CV) {
					Z_ADDREF_P(array_ref);
				}
			}
		} else if (Z_REFCOUNTED_P(array_ref)) {
			if (IS_CONST == IS_CONST ||
			           (IS_CONST == IS_CV &&
			            !Z_ISREF_P(array_ref) &&
			            Z_REFCOUNT_P(array_ref) > 1) ||
			           (IS_CONST == IS_VAR &&
			            !Z_ISREF_P(array_ref) &&
			            Z_REFCOUNT_P(array_ref) > 2)) {
				zval tmp;

				if (IS_CONST == IS_VAR) {
					Z_DELREF_P(array_ref);
				}
				ZVAL_DUP(&tmp, array_ref);
				array_ptr = array_ref = &tmp;
			} else if (IS_CONST == IS_CV) {
				if (Z_ISREF_P(array_ref) && Z_REFCOUNT_P(array_ref) == 1) {
					ZVAL_UNREF(array_ref);
					array_ptr = array_ref;
				}
				Z_ADDREF_P(array_ref);
			}
		}
	}

	if (ce && ce->get_iterator) {
		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);

		if (IS_CONST == IS_VAR && !(opline->extended_value & ZEND_FE_RESET_VARIABLE)) {

		}
		if (iter && EXPECTED(EG(exception) == NULL)) {
			ZVAL_OBJ(&iterator, &iter->std);
			array_ptr = array_ref = &iterator;
		} else {
			if (IS_CONST == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

			}
			if (!EG(exception)) {
				zend_throw_exception_ex(NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name->val);
			}
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}
	}

	ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);

	if (iter) {
		iter->index = 0;
		if (iter->funcs->rewind) {
			iter->funcs->rewind(iter TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(array_ref);
				if (IS_CONST == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

				}
				HANDLE_EXCEPTION();
			}
		}
		is_empty = iter->funcs->valid(iter TSRMLS_CC) != SUCCESS;
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(array_ref);
			if (IS_CONST == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

			}
			HANDLE_EXCEPTION();
		}
		iter->index = -1; /* will be set to 0 before using next handler */
	} else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {
		zend_hash_internal_pointer_reset(fe_ht);
		if (ce) {
			zend_object *zobj = Z_OBJ_P(array_ptr);
			while (zend_hash_has_more_elements(fe_ht) == SUCCESS) {
				zend_string *str_key;
				ulong int_key;
				zend_uchar key_type;

				key_type = zend_hash_get_current_key(fe_ht, &str_key, &int_key, 0);
				if (key_type != HASH_KEY_NON_EXISTENT &&
					(key_type == HASH_KEY_IS_LONG ||
				     zend_check_property_access(zobj, str_key TSRMLS_CC) == SUCCESS)) {
					break;
				}
				zend_hash_move_forward(fe_ht);
			}
		}
		is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;
		zend_hash_get_pointer(fe_ht, (HashPointer*)EX_VAR((opline+2)->op1.var));
	} else {
		zend_error(E_WARNING, "Invalid argument supplied for foreach()");
		is_empty = 1;
	}

	if (IS_CONST == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

	}
	if (is_empty) {
		ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
	} else {
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_EXIT_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0 || (IS_CONST != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_CONST != IS_UNUSED) {

		zval *ptr = opline->op1.zv;

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}

	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

static int ZEND_FASTCALL  ZEND_JMP_SET_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = opline->op1.zv;

	if (i_zend_is_true(value TSRMLS_CC)) {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
		if (!0) {
			zval_opt_copy_ctor(EX_VAR(opline->result.var));
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = opline->op1.zv;

	if (i_zend_is_true(value TSRMLS_CC)) {
		if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		} else {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
			if (!0) {
				zval_opt_copy_ctor(EX_VAR(opline->result.var));
			}
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = opline->op1.zv;

	ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
	if (!0) {
		zval_opt_copy_ctor(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = opline->op1.zv;

	if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	} else {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
		if (!0) {
			zval_opt_copy_ctor(EX_VAR(opline->result.var));
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CONST_CONST(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *varname;
	zval *retval;
	zval tmp_varname;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = opline->op1.zv;

	ZVAL_UNDEF(&tmp_varname);
 	if (IS_CONST != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_DUP_DEREF(&tmp_varname, varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CONST != IS_CONST) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		retval = zend_std_get_static_property(ce, Z_STR_P(varname), 0, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		retval = zend_hash_find(target_symbol_table, Z_STR_P(varname));
		if (retval == NULL) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = EX_VAR(opline->result.var);
					ZVAL_NULL(retval);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					retval = zend_hash_update(target_symbol_table, Z_STR_P(varname), &EG(uninitialized_zval));
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
		} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
			retval = Z_INDIRECT_P(retval);
			if (Z_TYPE_P(retval) == IS_UNDEF) {
				switch (type) {
					case BP_VAR_R:
					case BP_VAR_UNSET:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_IS:
						retval = EX_VAR(opline->result.var);
						ZVAL_NULL(retval);
						break;
					case BP_VAR_RW:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_W:
						ZVAL_NULL(retval);
						break;
					EMPTY_SWITCH_DEFAULT_CASE()
				}
			}
		}
		if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) == ZEND_FETCH_STATIC) {
			zval_update_constant(retval, (void*) 1 TSRMLS_CC);
		} else if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) != ZEND_FETCH_GLOBAL_LOCK) {

		}
	}

	if (IS_CONST != IS_CONST) {
		zval_dtor(&tmp_varname);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY(EX_VAR(opline->result.var), retval);
	} else {
		if (/*type == BP_VAR_W &&*/ (opline->extended_value & ZEND_FETCH_MAKE_REF)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
		}
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_CONST(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_CONST(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_CONST(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		return zend_fetch_var_address_helper_SPEC_CONST_CONST(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		return zend_fetch_var_address_helper_SPEC_CONST_CONST(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_CONST(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_CONST(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = opline->op1.zv;
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);

	if (IS_CONST != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_TMP_VAR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = opline->op1.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_ARRAY)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {

		zval *value = zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

		ZVAL_COPY(EX_VAR(opline->result.var), value);

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
			ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
		} else {
			ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), ce);
		}
		call->called_scope = ce;
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_CONST == IS_CONST &&
	    CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
		call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
	} else if (IS_CONST != IS_CONST &&
	           IS_CONST == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce))) {
		/* do nothing */
	} else if (IS_CONST != IS_UNUSED) {


		function_name = opline->op2.zv;
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
 			}
		}

		if (ce->get_static_method) {
			call->fbc = ce->get_static_method(ce, Z_STR_P(function_name) TSRMLS_CC);
		} else {
			call->fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_CONST == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
		}
		if (UNEXPECTED(call->fbc == NULL)) {
			zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name->val, Z_STRVAL_P(function_name));
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
		    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
			if (IS_CONST == IS_CONST) {
				CACHE_PTR(Z_CACHE_SLOT_P(function_name), call->fbc);
			} else {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), ce, call->fbc);
			}
		}
		if (IS_CONST != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (Z_OBJ(EG(This)) && Z_OBJCE(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name->val);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (Z_OBJ(EG(This)) &&
		    Z_OBJ_HT(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			}
		}
		call->object = Z_OBJ(EG(This));
		if (call->object) {
			GC_REFCOUNT(call->object)++;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 opline->op1.zv,
				 opline->op2.zv TSRMLS_CC));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_CONSTANT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_CONST == IS_UNUSED) {
		zend_constant *c;
		zval *retval;

		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
			c = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
		} else if ((c = zend_quick_get_constant(opline->op2.zv + 1, opline->extended_value TSRMLS_CC)) == NULL) {
			if ((opline->extended_value & IS_CONSTANT_UNQUALIFIED) != 0) {
				char *actual = (char *)zend_memrchr(Z_STRVAL_P(opline->op2.zv), '\\', Z_STRLEN_P(opline->op2.zv));
				if(!actual) {
					actual = Z_STRVAL_P(opline->op2.zv);
				} else {
					actual++;
				}
				/* non-qualified constant - allow text substitution */
				zend_error(E_NOTICE, "Use of undefined constant %s - assumed '%s'", actual, actual);
				ZVAL_STRINGL(EX_VAR(opline->result.var), actual, Z_STRLEN_P(opline->op2.zv)-(actual - Z_STRVAL_P(opline->op2.zv)));
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else {
				zend_error_noreturn(E_ERROR, "Undefined constant '%s'", Z_STRVAL_P(opline->op2.zv));
			}
		} else {
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), c);
		}
		retval = EX_VAR(opline->result.var);
		ZVAL_DUP(retval, &c->value);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		/* class constant */
		zend_class_entry *ce;
		zval *value;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				value = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				ZVAL_DUP(EX_VAR(opline->result.var), value);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, opline->extended_value TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op1.var));
			if ((value = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce)) != NULL) {
				ZVAL_DUP(EX_VAR(opline->result.var), value);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
		}

		if (EXPECTED((value = zend_hash_find(&ce->constants_table, Z_STR_P(opline->op2.zv))) != NULL)) {
			if (Z_ISREF_P(value)) {
				value = Z_REFVAL_P(value);
			}
			if (Z_CONSTANT_P(value)) {
				zend_class_entry *old_scope = EG(scope);

				EG(scope) = ce;
				zval_update_constant(value, (void *) 1 TSRMLS_CC);
				EG(scope) = old_scope;
			}
			if (IS_CONST == IS_CONST) {
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), value);
			} else {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce, value);
			}
			ZVAL_DUP(EX_VAR(opline->result.var), value);
		} else if (Z_STRLEN_P(opline->op2.zv) == sizeof("class")-1 && memcmp(Z_STRVAL_P(opline->op2.zv), "class", sizeof("class") - 1) == 0) {
			/* "class" is assigned as a case-sensitive keyword from zend_do_resolve_class_name */
			ZVAL_STR(EX_VAR(opline->result.var), ce->name);
			STR_ADDREF(ce->name);
		} else {
			zend_error_noreturn(E_ERROR, "Undefined class constant '%s'", Z_STRVAL_P(opline->op2.zv));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		expr_ptr = NULL;
		if (IS_CONST == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = opline->op1.zv;
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_CONST == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_CONST == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CONST != IS_UNUSED) {

		zval *offset = opline->op2.zv;
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_CONST != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;

	zend_bool tmp_is_dup = 0;

	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
	    ZVAL_COPY_VALUE(&tmp, EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->op1.var));
		zval_ptr_dtor(&tmp);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = opline->op1.zv;

	if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_DUP(&tmp, varname);
		convert_to_string(&tmp);
		varname = &tmp;
		tmp_is_dup = 1;
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		ZVAL_COPY(&tmp, varname);
		varname = &tmp;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_CONST != IS_CONST && tmp_is_dup) {
						zval_dtor(&tmp);
					} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
						zval_ptr_dtor(&tmp);
					}

					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		zend_std_unset_static_property(ce, Z_STR_P(varname), ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_hash_del_ind(target_symbol_table, Z_STR_P(varname));
	}

	if (IS_CONST != IS_CONST && tmp_is_dup) {
		zval_dtor(&tmp);
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		zval_ptr_dtor(&tmp);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_UNDEF) {
			value = EX_VAR(opline->op1.var);
			ZVAL_DEREF(value);
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = opline->op1.zv;

		if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_DUP(&tmp, varname);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_CONST != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_CONST == IS_CONST) {
				if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
					ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				} else {
					ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op2.var));
			}
			value = zend_std_get_static_property(ce, Z_STR_P(varname), 1, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if ((value = zend_hash_find(target_symbol_table, Z_STR_P(varname))) == NULL) {
				isset = 0;
			}
		}

		if (IS_CONST != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_P(value) != IS_NULL) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(value TSRMLS_CC)) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *name;
	zval *val;
	zend_constant c;

	SAVE_OPLINE();
	name  = opline->op1.zv;
	val   = opline->op2.zv;

	ZVAL_COPY_VALUE(&c.value, val);
	if (Z_OPT_CONSTANT(c.value)) {
		if (Z_TYPE_P(val) == IS_CONSTANT_ARRAY) {
			zval_opt_copy_ctor(&c.value);
		}
		zval_update_constant(&c.value, NULL TSRMLS_CC);
	} else {
		/* IS_CONST can't be IS_OBJECT, IS_RESOURCE or IS_REFERENCE */
		if (UNEXPECTED(Z_OPT_COPYABLE(c.value))) {
			_zval_copy_ctor_func(&c.value ZEND_FILE_LINE_CC);
		}
	}
	c.flags = CONST_CS; /* non persistent, case sensetive */
	c.name = STR_DUP(Z_STR_P(name), 0);
	c.module_number = PHP_USER_CONSTANT;

	if (zend_register_constant(&c TSRMLS_CC) == FAILURE) {
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CONST_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_CONST == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_CONST == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_CONST == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_CONST == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;

	SAVE_OPLINE();
	container = opline->op1.zv;
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CONST != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
			ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
		} else {
			ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), ce);
		}
		call->called_scope = ce;
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_TMP_VAR == IS_CONST &&
	    CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
		call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
	} else if (IS_CONST != IS_CONST &&
	           IS_TMP_VAR == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce))) {
		/* do nothing */
	} else if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;

		function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		if (IS_TMP_VAR != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
 			}
		}

		if (ce->get_static_method) {
			call->fbc = ce->get_static_method(ce, Z_STR_P(function_name) TSRMLS_CC);
		} else {
			call->fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_TMP_VAR == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
		}
		if (UNEXPECTED(call->fbc == NULL)) {
			zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name->val, Z_STRVAL_P(function_name));
		}
		if (IS_TMP_VAR == IS_CONST &&
		    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
		    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
			if (IS_CONST == IS_CONST) {
				CACHE_PTR(Z_CACHE_SLOT_P(function_name), call->fbc);
			} else {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), ce, call->fbc);
			}
		}
		if (IS_TMP_VAR != IS_CONST) {
			zval_dtor(free_op2.var);
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (Z_OBJ(EG(This)) && Z_OBJCE(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name->val);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (Z_OBJ(EG(This)) &&
		    Z_OBJ_HT(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			}
		}
		call->object = Z_OBJ(EG(This));
		if (call->object) {
			GC_REFCOUNT(call->object)++;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 opline->op1.zv,
				 _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		expr_ptr = NULL;
		if (IS_CONST == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = opline->op1.zv;
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_CONST == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_CONST == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_TMP_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}
		zval_dtor(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CONST_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_CONST == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_CONST == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_TMP_VAR == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_TMP_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CONST_VAR(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *varname;
	zval *retval;
	zval tmp_varname;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = opline->op1.zv;

	ZVAL_UNDEF(&tmp_varname);
 	if (IS_CONST != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_DUP_DEREF(&tmp_varname, varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CONST != IS_CONST) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		retval = zend_std_get_static_property(ce, Z_STR_P(varname), 0, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		retval = zend_hash_find(target_symbol_table, Z_STR_P(varname));
		if (retval == NULL) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = EX_VAR(opline->result.var);
					ZVAL_NULL(retval);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					retval = zend_hash_update(target_symbol_table, Z_STR_P(varname), &EG(uninitialized_zval));
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
		} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
			retval = Z_INDIRECT_P(retval);
			if (Z_TYPE_P(retval) == IS_UNDEF) {
				switch (type) {
					case BP_VAR_R:
					case BP_VAR_UNSET:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_IS:
						retval = EX_VAR(opline->result.var);
						ZVAL_NULL(retval);
						break;
					case BP_VAR_RW:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_W:
						ZVAL_NULL(retval);
						break;
					EMPTY_SWITCH_DEFAULT_CASE()
				}
			}
		}
		if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) == ZEND_FETCH_STATIC) {
			zval_update_constant(retval, (void*) 1 TSRMLS_CC);
		} else if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) != ZEND_FETCH_GLOBAL_LOCK) {

		}
	}

	if (IS_CONST != IS_CONST) {
		zval_dtor(&tmp_varname);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY(EX_VAR(opline->result.var), retval);
	} else {
		if (/*type == BP_VAR_W &&*/ (opline->extended_value & ZEND_FETCH_MAKE_REF)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
		}
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_VAR(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_VAR(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_VAR(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		return zend_fetch_var_address_helper_SPEC_CONST_VAR(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		return zend_fetch_var_address_helper_SPEC_CONST_VAR(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_VAR(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_VAR(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;

	SAVE_OPLINE();
	container = opline->op1.zv;
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_CONST != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
			ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
		} else {
			ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), ce);
		}
		call->called_scope = ce;
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_VAR == IS_CONST &&
	    CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
		call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
	} else if (IS_CONST != IS_CONST &&
	           IS_VAR == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce))) {
		/* do nothing */
	} else if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;

		function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		if (IS_VAR != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
 			}
		}

		if (ce->get_static_method) {
			call->fbc = ce->get_static_method(ce, Z_STR_P(function_name) TSRMLS_CC);
		} else {
			call->fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_VAR == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
		}
		if (UNEXPECTED(call->fbc == NULL)) {
			zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name->val, Z_STRVAL_P(function_name));
		}
		if (IS_VAR == IS_CONST &&
		    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
		    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
			if (IS_CONST == IS_CONST) {
				CACHE_PTR(Z_CACHE_SLOT_P(function_name), call->fbc);
			} else {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), ce, call->fbc);
			}
		}
		if (IS_VAR != IS_CONST) {
			zval_ptr_dtor_nogc(free_op2.var);
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (Z_OBJ(EG(This)) && Z_OBJCE(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name->val);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (Z_OBJ(EG(This)) &&
		    Z_OBJ_HT(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			}
		}
		call->object = Z_OBJ(EG(This));
		if (call->object) {
			GC_REFCOUNT(call->object)++;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 opline->op1.zv,
				 _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		expr_ptr = NULL;
		if (IS_CONST == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = opline->op1.zv;
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_CONST == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_CONST == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}
		zval_ptr_dtor_nogc(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;

	zend_bool tmp_is_dup = 0;

	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
	    ZVAL_COPY_VALUE(&tmp, EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->op1.var));
		zval_ptr_dtor(&tmp);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = opline->op1.zv;

	if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_DUP(&tmp, varname);
		convert_to_string(&tmp);
		varname = &tmp;
		tmp_is_dup = 1;
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		ZVAL_COPY(&tmp, varname);
		varname = &tmp;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_CONST != IS_CONST && tmp_is_dup) {
						zval_dtor(&tmp);
					} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
						zval_ptr_dtor(&tmp);
					}

					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		zend_std_unset_static_property(ce, Z_STR_P(varname), ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_hash_del_ind(target_symbol_table, Z_STR_P(varname));
	}

	if (IS_CONST != IS_CONST && tmp_is_dup) {
		zval_dtor(&tmp);
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		zval_ptr_dtor(&tmp);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_UNDEF) {
			value = EX_VAR(opline->op1.var);
			ZVAL_DEREF(value);
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = opline->op1.zv;

		if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_DUP(&tmp, varname);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_VAR != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_VAR == IS_CONST) {
				if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
					ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				} else {
					ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op2.var));
			}
			value = zend_std_get_static_property(ce, Z_STR_P(varname), 1, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if ((value = zend_hash_find(target_symbol_table, Z_STR_P(varname))) == NULL) {
				isset = 0;
			}
		}

		if (IS_CONST != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_P(value) != IS_NULL) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(value TSRMLS_CC)) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CONST_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_CONST == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_CONST == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_VAR == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));
			zval_ptr_dtor_nogc(free_op2.var);
		} else {
			if (IS_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CONST_UNUSED(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *varname;
	zval *retval;
	zval tmp_varname;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = opline->op1.zv;

	ZVAL_UNDEF(&tmp_varname);
 	if (IS_CONST != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_DUP_DEREF(&tmp_varname, varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CONST != IS_CONST) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		retval = zend_std_get_static_property(ce, Z_STR_P(varname), 0, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		retval = zend_hash_find(target_symbol_table, Z_STR_P(varname));
		if (retval == NULL) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = EX_VAR(opline->result.var);
					ZVAL_NULL(retval);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					retval = zend_hash_update(target_symbol_table, Z_STR_P(varname), &EG(uninitialized_zval));
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
		} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
			retval = Z_INDIRECT_P(retval);
			if (Z_TYPE_P(retval) == IS_UNDEF) {
				switch (type) {
					case BP_VAR_R:
					case BP_VAR_UNSET:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_IS:
						retval = EX_VAR(opline->result.var);
						ZVAL_NULL(retval);
						break;
					case BP_VAR_RW:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_W:
						ZVAL_NULL(retval);
						break;
					EMPTY_SWITCH_DEFAULT_CASE()
				}
			}
		}
		if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) == ZEND_FETCH_STATIC) {
			zval_update_constant(retval, (void*) 1 TSRMLS_CC);
		} else if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) != ZEND_FETCH_GLOBAL_LOCK) {

		}
	}

	if (IS_CONST != IS_CONST) {
		zval_dtor(&tmp_varname);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY(EX_VAR(opline->result.var), retval);
	} else {
		if (/*type == BP_VAR_W &&*/ (opline->extended_value & ZEND_FETCH_MAKE_REF)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
		}
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CONST_UNUSED(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
			ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
		} else {
			ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), ce);
		}
		call->called_scope = ce;
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_UNUSED == IS_CONST &&
	    CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
		call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
	} else if (IS_CONST != IS_CONST &&
	           IS_UNUSED == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce))) {
		/* do nothing */
	} else if (IS_UNUSED != IS_UNUSED) {


		function_name = NULL;
		if (IS_UNUSED != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
 			}
		}

		if (ce->get_static_method) {
			call->fbc = ce->get_static_method(ce, Z_STR_P(function_name) TSRMLS_CC);
		} else {
			call->fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_UNUSED == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
		}
		if (UNEXPECTED(call->fbc == NULL)) {
			zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name->val, Z_STRVAL_P(function_name));
		}
		if (IS_UNUSED == IS_CONST &&
		    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
		    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
			if (IS_CONST == IS_CONST) {
				CACHE_PTR(Z_CACHE_SLOT_P(function_name), call->fbc);
			} else {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), ce, call->fbc);
			}
		}
		if (IS_UNUSED != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (Z_OBJ(EG(This)) && Z_OBJCE(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name->val);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (Z_OBJ(EG(This)) &&
		    Z_OBJ_HT(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			}
		}
		call->object = Z_OBJ(EG(This));
		if (call->object) {
			GC_REFCOUNT(call->object)++;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		expr_ptr = NULL;
		if (IS_CONST == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = opline->op1.zv;
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_CONST == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_CONST == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_UNUSED != IS_UNUSED) {

		zval *offset = NULL;
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_UNUSED != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;

	zend_bool tmp_is_dup = 0;

	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
	    ZVAL_COPY_VALUE(&tmp, EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->op1.var));
		zval_ptr_dtor(&tmp);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = opline->op1.zv;

	if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_DUP(&tmp, varname);
		convert_to_string(&tmp);
		varname = &tmp;
		tmp_is_dup = 1;
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		ZVAL_COPY(&tmp, varname);
		varname = &tmp;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_CONST != IS_CONST && tmp_is_dup) {
						zval_dtor(&tmp);
					} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
						zval_ptr_dtor(&tmp);
					}

					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		zend_std_unset_static_property(ce, Z_STR_P(varname), ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_hash_del_ind(target_symbol_table, Z_STR_P(varname));
	}

	if (IS_CONST != IS_CONST && tmp_is_dup) {
		zval_dtor(&tmp);
	} else if (IS_CONST == IS_VAR || IS_CONST == IS_CV) {
		zval_ptr_dtor(&tmp);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CONST == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_UNDEF) {
			value = EX_VAR(opline->op1.var);
			ZVAL_DEREF(value);
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = opline->op1.zv;

		if (IS_CONST != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_DUP(&tmp, varname);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_UNUSED != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_UNUSED == IS_CONST) {
				if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
					ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				} else {
					ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op2.var));
			}
			value = zend_std_get_static_property(ce, Z_STR_P(varname), 1, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if ((value = zend_hash_find(target_symbol_table, Z_STR_P(varname))) == NULL) {
				isset = 0;
			}
		}

		if (IS_CONST != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_P(value) != IS_NULL) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(value TSRMLS_CC)) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *zfunc;

	SAVE_OPLINE();

	if (UNEXPECTED((zfunc = zend_hash_find(EG(function_table), Z_STR_P(opline->op1.zv))) == NULL) ||
	    UNEXPECTED(Z_FUNC_P(zfunc)->type != ZEND_USER_FUNCTION)) {
		zend_error_noreturn(E_ERROR, "Base lambda function for closure not found");
	}

	zend_create_closure(EX_VAR(opline->result.var), Z_FUNC_P(zfunc), EG(scope), Z_OBJ(EG(This)) ? &EG(This) : NULL TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CONST_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_CONST == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_CONST == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_UNUSED == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_UNUSED == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		opline->op1.zv,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = opline->op1.zv;
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);

	if (IS_CONST != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_CONST == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
			ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
		} else {
			ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), ce);
		}
		call->called_scope = ce;
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_CONST == IS_CONST &&
	    IS_CV == IS_CONST &&
	    CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
		call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
	} else if (IS_CONST != IS_CONST &&
	           IS_CV == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce))) {
		/* do nothing */
	} else if (IS_CV != IS_UNUSED) {


		function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
 			}
		}

		if (ce->get_static_method) {
			call->fbc = ce->get_static_method(ce, Z_STR_P(function_name) TSRMLS_CC);
		} else {
			call->fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_CV == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
		}
		if (UNEXPECTED(call->fbc == NULL)) {
			zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name->val, Z_STRVAL_P(function_name));
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
		    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
			if (IS_CONST == IS_CONST) {
				CACHE_PTR(Z_CACHE_SLOT_P(function_name), call->fbc);
			} else {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), ce, call->fbc);
			}
		}
		if (IS_CV != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (Z_OBJ(EG(This)) && Z_OBJCE(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name->val);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (Z_OBJ(EG(This)) &&
		    Z_OBJ_HT(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			}
		}
		call->object = Z_OBJ(EG(This));
		if (call->object) {
			GC_REFCOUNT(call->object)++;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CATCH_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_class_entry *ce, *catch_ce;
	zend_object *exception;

	SAVE_OPLINE();
	/* Check whether an exception has been thrown, if not, jump over code */
	zend_exception_restore(TSRMLS_C);
	if (EG(exception) == NULL) {
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
	if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
		catch_ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
	} else {
		catch_ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, ZEND_FETCH_CLASS_NO_AUTOLOAD TSRMLS_CC);

		CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), catch_ce);
	}
	ce = zend_get_class_entry(EG(exception) TSRMLS_CC);

#ifdef HAVE_DTRACE
	if (DTRACE_EXCEPTION_CAUGHT_ENABLED()) {
		DTRACE_EXCEPTION_CAUGHT((char *)ce->name);
	}
#endif /* HAVE_DTRACE */

	if (ce != catch_ce) {
		if (!instanceof_function(ce, catch_ce TSRMLS_CC)) {
			if (opline->result.num) {
				zend_throw_exception_internal(NULL TSRMLS_CC);
				HANDLE_EXCEPTION();
			}
			ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
			ZEND_VM_CONTINUE(); /* CHECK_ME */
		}
	}

	exception = EG(exception);
	if (Z_REFCOUNTED_P(EX_VAR(opline->op2.var))) {
		zval_ptr_dtor(EX_VAR(opline->op2.var));
	}
	ZVAL_OBJ(EX_VAR(opline->op2.var), EG(exception));
	if (UNEXPECTED(EG(exception) != exception)) {
		GC_REFCOUNT(EG(exception))++;
		HANDLE_EXCEPTION();
	} else {
		EG(exception) = NULL;
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 opline->op1.zv,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {
		expr_ptr = NULL;
		if (IS_CONST == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = opline->op1.zv;
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_CONST == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_CONST == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CV != IS_UNUSED) {

		zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_CV != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_CONST == IS_VAR || IS_CONST == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_CONST == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CONST != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CONST_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CONST != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CONST == IS_CONST || IS_CONST == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = opline->op1.zv;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_CONST == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CONST == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = opline->op1.zv;

			/* Consts, temporary variables and references need copying */
			if (IS_CONST == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_CONST == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_CONST == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_CV == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_CV == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_BW_NOT_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_not_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_NOT_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_not_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ECHO_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *z;

	SAVE_OPLINE();
	z = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	zend_print_variable(z);

	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRINT_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_LONG(EX_VAR(opline->result.var), 1);
	return ZEND_ECHO_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_JMPZ_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val TSRMLS_CC);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (!ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val TSRMLS_CC);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPZNZ_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val TSRMLS_CC);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (EXPECTED(retval != 0)) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on true to %d\n", opline->extended_value);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	} else {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on false to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
}

static int ZEND_FASTCALL  ZEND_JMPZ_EX_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val TSRMLS_CC);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	ZVAL_BOOL(EX_VAR(opline->result.var), retval);
	if (!retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_EX_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val TSRMLS_CC);
		zval_dtor(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	ZVAL_BOOL(EX_VAR(opline->result.var), retval);
	if (retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FREE_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_TMP_VAR) {
		zval_dtor(EX_VAR(opline->op1.var));
	} else {
		zval_ptr_dtor(EX_VAR(opline->op1.var));
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RETURN_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zend_free_op free_op1;

	SAVE_OPLINE();
	retval_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (!EX(return_value)) {
		zval_dtor(free_op1.var);
	} else {
		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
			if (IS_TMP_VAR != IS_TMP_VAR) {
				zval_opt_copy_ctor(EX(return_value));
			}

		} else if (Z_ISREF_P(retval_ptr)) {
			ZVAL_DUP(EX(return_value), Z_REFVAL_P(retval_ptr));

		} else {
			ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
			if (IS_TMP_VAR == IS_CV) {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) Z_ADDREF_P(retval_ptr);
			}
		}
	}
	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zend_free_op free_op1;

	SAVE_OPLINE();

	do {
		if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR ||
		    (IS_TMP_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			if (!EX(return_value)) {
				if (IS_TMP_VAR == IS_TMP_VAR) {
					zval_dtor(free_op1.var);
				}
			} else if (!1) { /* Not a temp var */
				ZVAL_DUP(EX(return_value), retval_ptr);
			} else {
				ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
			}
			break;
		}

		retval_ptr = NULL;

		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(retval_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot return string offsets by reference");
		}

		if (IS_TMP_VAR == IS_VAR && !Z_ISREF_P(retval_ptr)) {
			if (opline->extended_value == ZEND_RETURNS_FUNCTION &&
			    (Z_VAR_FLAGS_P(retval_ptr) & IS_VAR_RET_REF)) {
			} else {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EX(return_value)) {
					zval tmp;
					ZVAL_DUP(&tmp, retval_ptr);
					ZVAL_NEW_REF(EX(return_value), &tmp);
				}
				break;
			}
		}

		if (EX(return_value)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			ZVAL_COPY(EX(return_value), retval_ptr);
		}
	} while (0);

	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_THROW_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval exception;
	zend_free_op free_op1;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Can only throw objects");
	}

	zend_exception_save(TSRMLS_C);
	if (IS_TMP_VAR == IS_CONST) {
		ZVAL_DUP(&exception, value);
		value = &exception;
	} else if (IS_TMP_VAR != IS_TMP_VAR) {
		if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
	}

	zend_throw_exception_object(value TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);

	HANDLE_EXCEPTION();
}

static int ZEND_FASTCALL  ZEND_SEND_VAL_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (opline->extended_value == ZEND_DO_FCALL_BY_NAME) {
		int arg_num = opline->op2.num + EX(call)->num_additional_args;
		if (ARG_MUST_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
			zend_error_noreturn(E_ERROR, "Cannot pass parameter %d by reference", arg_num);
		}
	}

	{
		zval *top;
		zval *value;
		zend_free_op free_op1;

		value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		top = zend_vm_stack_top_inc(TSRMLS_C);
		ZVAL_COPY_VALUE(top, value);
		if (!1) {
			zval_opt_copy_ctor(top);
		}

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *retval = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	/* PHP 3.0 returned "" for false and 1 for true, here we use 0 and 1 for now */
	ZVAL_BOOL(retval, i_zend_is_true(_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CLONE_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name->val);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name->val, EG(scope) ? EG(scope)->name->val : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name->val, EG(scope) ? EG(scope)->name->val : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		ZVAL_OBJ(EX_VAR(opline->result.var), clone_call(obj TSRMLS_CC));
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(EX_VAR(opline->result.var));
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CAST_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr, *expr_ptr;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	expr = expr_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		ZVAL_DEREF(expr);
	}
	if (Z_TYPE_P(expr) == opline->extended_value) {
		ZVAL_COPY_VALUE(result, expr);
		if (IS_TMP_VAR == IS_CONST || expr != expr_ptr) {
			zval_opt_copy_ctor(result);

		} else if (IS_TMP_VAR == IS_CV) {
			if (Z_OPT_REFCOUNTED_P(expr)) Z_ADDREF_P(expr);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (opline->extended_value != IS_STRING) {
		ZVAL_COPY_VALUE(result, expr);
		if (!1) {
			zval_opt_copy_ctor(result);
		}
	}

	switch (opline->extended_value) {
		case IS_NULL:
			convert_to_null(result);
			break;
		case IS_BOOL:
			convert_to_boolean(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		case IS_DOUBLE:
			convert_to_double(result);
			break;
		case IS_STRING: {
			zval var_copy;
			int use_copy;

			zend_make_printable_zval(expr, &var_copy, &use_copy);
			if (use_copy) {
				ZVAL_COPY_VALUE(result, &var_copy);
				if (1) {
					zval_dtor(free_op1.var);
				}
			} else {
				ZVAL_COPY_VALUE(result, expr);
				if (!1) {
					zval_opt_copy_ctor(result);
				}
			}
			break;
		}
		case IS_ARRAY:
			convert_to_array(result);
			break;
		case IS_OBJECT:
			convert_to_object(result);
			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_op_array *new_op_array=NULL;
	zend_free_op free_op1;
	zval *inc_filename;
	zval tmp_inc_filename;
	zend_bool failure_retval=0;

	SAVE_OPLINE();
	inc_filename = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_UNDEF(&tmp_inc_filename);
	if (Z_TYPE_P(inc_filename) != IS_STRING) {
		ZVAL_DUP(&tmp_inc_filename, inc_filename);
		convert_to_string(&tmp_inc_filename);
		inc_filename = &tmp_inc_filename;
	}

	if (opline->extended_value != ZEND_EVAL && strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)) {
		if (opline->extended_value == ZEND_INCLUDE_ONCE || opline->extended_value == ZEND_INCLUDE) {
			zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		} else {
			zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		}
	} else {
		switch (opline->extended_value) {
			case ZEND_INCLUDE_ONCE:
			case ZEND_REQUIRE_ONCE: {
					zend_file_handle file_handle;
					char *resolved_path;

					resolved_path = zend_resolve_path(Z_STRVAL_P(inc_filename), Z_STRLEN_P(inc_filename) TSRMLS_CC);
					if (resolved_path) {
						failure_retval = zend_hash_str_exists(&EG(included_files), resolved_path, strlen(resolved_path));
					} else {
						resolved_path = Z_STRVAL_P(inc_filename);
					}

					if (failure_retval) {
						/* do nothing, file already included */
					} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {

						if (!file_handle.opened_path) {
							file_handle.opened_path = estrdup(resolved_path);
						}

						if (zend_hash_str_add_empty_element(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path))) {
							new_op_array = zend_compile_file(&file_handle, (opline->extended_value==ZEND_INCLUDE_ONCE?ZEND_INCLUDE:ZEND_REQUIRE) TSRMLS_CC);
							zend_destroy_file_handle(&file_handle TSRMLS_CC);
						} else {
							zend_file_handle_dtor(&file_handle TSRMLS_CC);
							failure_retval=1;
						}
					} else {
						if (opline->extended_value == ZEND_INCLUDE_ONCE) {
							zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						} else {
							zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						}
					}
					if (resolved_path != Z_STRVAL_P(inc_filename)) {
						efree(resolved_path);
					}
				}
				break;
			case ZEND_INCLUDE:
			case ZEND_REQUIRE:
				new_op_array = compile_filename(opline->extended_value, inc_filename TSRMLS_CC);
				break;
			case ZEND_EVAL: {
					char *eval_desc = zend_make_compiled_string_description("eval()'d code" TSRMLS_CC);

					new_op_array = zend_compile_string(inc_filename, eval_desc TSRMLS_CC);
					efree(eval_desc);
				}
				break;
			EMPTY_SWITCH_DEFAULT_CASE()
		}
	}
	if (Z_TYPE(tmp_inc_filename) != IS_UNDEF) {
		zval_ptr_dtor(&tmp_inc_filename);
	}
	zval_dtor(free_op1.var);
	if (UNEXPECTED(EG(exception) != NULL)) {
		HANDLE_EXCEPTION();
	} else if (EXPECTED(new_op_array != NULL)) {
		zval *return_value = NULL;

		EG(active_op_array) = new_op_array;
		if (RETURN_VALUE_USED(opline)) {
			return_value = EX_VAR(opline->result.var);
		}

		EX(function_state).function = (zend_function *) new_op_array;
		EX(object) = NULL;

		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		if (EXPECTED(zend_execute_ex == execute_ex)) {
		    i_create_execute_data_from_op_array(new_op_array, return_value, VM_FRAME_NESTED_CODE TSRMLS_CC);
			ZEND_VM_ENTER();
		} else {
			zend_execute(new_op_array, return_value TSRMLS_CC);
		}

		EX(function_state).function = (zend_function *) EX(op_array);

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		destroy_op_array(new_op_array TSRMLS_CC);
		efree(new_op_array);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}

	} else if (RETURN_VALUE_USED(opline)) {
		ZVAL_BOOL(EX_VAR(opline->result.var), failure_retval);
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FE_RESET_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *array_ptr, *array_ref, iterator;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	zend_class_entry *ce = NULL;
	zend_bool is_empty = 0;

	SAVE_OPLINE();

	if ((IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) &&
	    (opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
		array_ptr = array_ref = NULL;
		ZVAL_DEREF(array_ptr);
		if (Z_TYPE_P(array_ptr) == IS_ARRAY) {
			if (!Z_ISREF_P(array_ref)) {
				SEPARATE_ZVAL(array_ptr);
				array_ref = array_ptr;
				if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
					ZVAL_NEW_REF(array_ptr, array_ptr);
					array_ref = array_ptr;
					array_ptr = Z_REFVAL_P(array_ptr);
				}
			}
			if (Z_REFCOUNTED_P(array_ref)) Z_ADDREF_P(array_ref);
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			if(Z_OBJ_HT_P(array_ptr)->get_class_entry == NULL) {
				zend_error(E_WARNING, "foreach() cannot iterate over objects without PHP class");
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}

			ce = Z_OBJCE_P(array_ptr);
			if (!ce || ce->get_iterator == NULL) {
				if (!Z_ISREF_P(array_ref)) {
					SEPARATE_ZVAL(array_ptr);
				}
				Z_ADDREF_P(array_ptr);
			}
			array_ref = array_ptr;
		} else {
			if (Z_REFCOUNTED_P(array_ref)) Z_ADDREF_P(array_ref);
		}
	} else {
		array_ptr = array_ref = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		ZVAL_DEREF(array_ptr);
		if (1) { /* IS_TMP_VAR */
			zval tmp;

			ZVAL_COPY_VALUE(&tmp, array_ptr);
			array_ptr = &tmp;
			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
				ce = Z_OBJCE_P(array_ptr);
				if (ce && ce->get_iterator) {
					Z_DELREF_P(array_ref);
				}
			}
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			ce = Z_OBJCE_P(array_ptr);
			if (!ce || !ce->get_iterator) {
				if (IS_TMP_VAR == IS_CV) {
					Z_ADDREF_P(array_ref);
				}
			}
		} else if (Z_REFCOUNTED_P(array_ref)) {
			if (IS_TMP_VAR == IS_CONST ||
			           (IS_TMP_VAR == IS_CV &&
			            !Z_ISREF_P(array_ref) &&
			            Z_REFCOUNT_P(array_ref) > 1) ||
			           (IS_TMP_VAR == IS_VAR &&
			            !Z_ISREF_P(array_ref) &&
			            Z_REFCOUNT_P(array_ref) > 2)) {
				zval tmp;

				if (IS_TMP_VAR == IS_VAR) {
					Z_DELREF_P(array_ref);
				}
				ZVAL_DUP(&tmp, array_ref);
				array_ptr = array_ref = &tmp;
			} else if (IS_TMP_VAR == IS_CV) {
				if (Z_ISREF_P(array_ref) && Z_REFCOUNT_P(array_ref) == 1) {
					ZVAL_UNREF(array_ref);
					array_ptr = array_ref;
				}
				Z_ADDREF_P(array_ref);
			}
		}
	}

	if (ce && ce->get_iterator) {
		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);

		if (IS_TMP_VAR == IS_VAR && !(opline->extended_value & ZEND_FE_RESET_VARIABLE)) {

		}
		if (iter && EXPECTED(EG(exception) == NULL)) {
			ZVAL_OBJ(&iterator, &iter->std);
			array_ptr = array_ref = &iterator;
		} else {
			if (IS_TMP_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

			}
			if (!EG(exception)) {
				zend_throw_exception_ex(NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name->val);
			}
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}
	}

	ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);

	if (iter) {
		iter->index = 0;
		if (iter->funcs->rewind) {
			iter->funcs->rewind(iter TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(array_ref);
				if (IS_TMP_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

				}
				HANDLE_EXCEPTION();
			}
		}
		is_empty = iter->funcs->valid(iter TSRMLS_CC) != SUCCESS;
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(array_ref);
			if (IS_TMP_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

			}
			HANDLE_EXCEPTION();
		}
		iter->index = -1; /* will be set to 0 before using next handler */
	} else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {
		zend_hash_internal_pointer_reset(fe_ht);
		if (ce) {
			zend_object *zobj = Z_OBJ_P(array_ptr);
			while (zend_hash_has_more_elements(fe_ht) == SUCCESS) {
				zend_string *str_key;
				ulong int_key;
				zend_uchar key_type;

				key_type = zend_hash_get_current_key(fe_ht, &str_key, &int_key, 0);
				if (key_type != HASH_KEY_NON_EXISTENT &&
					(key_type == HASH_KEY_IS_LONG ||
				     zend_check_property_access(zobj, str_key TSRMLS_CC) == SUCCESS)) {
					break;
				}
				zend_hash_move_forward(fe_ht);
			}
		}
		is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;
		zend_hash_get_pointer(fe_ht, (HashPointer*)EX_VAR((opline+2)->op1.var));
	} else {
		zend_error(E_WARNING, "Invalid argument supplied for foreach()");
		is_empty = 1;
	}

	if (IS_TMP_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

	}
	if (is_empty) {
		ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
	} else {
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_EXIT_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0 || (IS_TMP_VAR != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;
		zval *ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}
		zval_dtor(free_op1.var);
	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

static int ZEND_FASTCALL  ZEND_END_SILENCE_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval restored_error_reporting;

	SAVE_OPLINE();
	if (!EG(error_reporting) && Z_LVAL_P(EX_VAR(opline->op1.var)) != 0) {
		ZVAL_LONG(&restored_error_reporting, Z_LVAL_P(EX_VAR(opline->op1.var)));
		EG(error_reporting) = Z_LVAL(restored_error_reporting);
		convert_to_string(&restored_error_reporting);
		if (EXPECTED(EG(error_reporting_ini_entry) != NULL)) {
			if (EXPECTED(EG(error_reporting_ini_entry)->modified &&
			    EG(error_reporting_ini_entry)->value != EG(error_reporting_ini_entry)->orig_value)) {
				efree(EG(error_reporting_ini_entry)->value);
			}
			EG(error_reporting_ini_entry)->value = estrndup(Z_STRVAL(restored_error_reporting), Z_STRLEN(restored_error_reporting));
			EG(error_reporting_ini_entry)->value_length = Z_STRLEN(restored_error_reporting);
		}
		zval_dtor(&restored_error_reporting);
	}
//???	if (EX(old_error_reporting) == EX_VAR(opline->op1.var)) {
//???		EX(old_error_reporting) = NULL;
//???	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMP_SET_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (i_zend_is_true(value TSRMLS_CC)) {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
		if (!1) {
			zval_opt_copy_ctor(EX_VAR(opline->result.var));
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (i_zend_is_true(value TSRMLS_CC)) {
		if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		} else {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
			if (!1) {
				zval_opt_copy_ctor(EX_VAR(opline->result.var));
			}
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
	if (!1) {
		zval_opt_copy_ctor(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	} else {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
		if (!1) {
			zval_opt_copy_ctor(EX_VAR(opline->result.var));
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INSTANCEOF_SPEC_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (Z_TYPE_P(expr) == IS_OBJECT && Z_OBJ_HT_P(expr)->get_class_entry) {
		result = instanceof_function(Z_OBJCE_P(expr), Z_CE_P(EX_VAR(opline->op2.var)) TSRMLS_CC);
	} else {
		result = 0;
	}
	ZVAL_BOOL(EX_VAR(opline->result.var), result);
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_TMP_CONST(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval *retval;
	zval tmp_varname;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_UNDEF(&tmp_varname);
 	if (IS_TMP_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_DUP_DEREF(&tmp_varname, varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_TMP_VAR != IS_CONST) {
						zval_dtor(&tmp_varname);
					}
					zval_dtor(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		retval = zend_std_get_static_property(ce, Z_STR_P(varname), 0, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
		zval_dtor(free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		retval = zend_hash_find(target_symbol_table, Z_STR_P(varname));
		if (retval == NULL) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = EX_VAR(opline->result.var);
					ZVAL_NULL(retval);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					retval = zend_hash_update(target_symbol_table, Z_STR_P(varname), &EG(uninitialized_zval));
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
		} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
			retval = Z_INDIRECT_P(retval);
			if (Z_TYPE_P(retval) == IS_UNDEF) {
				switch (type) {
					case BP_VAR_R:
					case BP_VAR_UNSET:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_IS:
						retval = EX_VAR(opline->result.var);
						ZVAL_NULL(retval);
						break;
					case BP_VAR_RW:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_W:
						ZVAL_NULL(retval);
						break;
					EMPTY_SWITCH_DEFAULT_CASE()
				}
			}
		}
		if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) == ZEND_FETCH_STATIC) {
			zval_update_constant(retval, (void*) 1 TSRMLS_CC);
		} else if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) != ZEND_FETCH_GLOBAL_LOCK) {
			zval_dtor(free_op1.var);
		}
	}

	if (IS_TMP_VAR != IS_CONST) {
		zval_dtor(&tmp_varname);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY(EX_VAR(opline->result.var), retval);
	} else {
		if (/*type == BP_VAR_W &&*/ (opline->extended_value & ZEND_FETCH_MAKE_REF)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
		}
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_CONST(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_CONST(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_CONST(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		return zend_fetch_var_address_helper_SPEC_TMP_CONST(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		return zend_fetch_var_address_helper_SPEC_TMP_CONST(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_CONST(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_CONST(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);

	if (IS_TMP_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_dtor(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_TMP_VAR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_ARRAY)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {

		zval *value = zend_fetch_dimension_address_inner(Z_ARRVAL_P(container), opline->op2.zv, IS_CONST, BP_VAR_R TSRMLS_CC);

		ZVAL_COPY(EX_VAR(opline->result.var), value);

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_CHAR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *str = EX_VAR(opline->result.var);

	SAVE_OPLINE();

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_char_to_string */
		ZVAL_EMPTY_STRING(str);
	}

	add_char_to_string(str, str, opline->op2.zv);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *str = EX_VAR(opline->result.var);

	SAVE_OPLINE();

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		ZVAL_EMPTY_STRING(str);
	}

	add_string_to_string(str, str, opline->op2.zv);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_free_op free_op1;
	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = opline->op2.zv;

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_CONST != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_CONST == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 opline->op2.zv TSRMLS_CC));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		expr_ptr = NULL;
		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_TMP_VAR == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_TMP_VAR == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CONST != IS_UNUSED) {

		zval *offset = opline->op2.zv;
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_CONST != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;
	zend_bool tmp_is_dup = 0;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
	    ZVAL_COPY_VALUE(&tmp, EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->op1.var));
		zval_ptr_dtor(&tmp);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_DUP(&tmp, varname);
		convert_to_string(&tmp);
		varname = &tmp;
		tmp_is_dup = 1;
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		ZVAL_COPY(&tmp, varname);
		varname = &tmp;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_TMP_VAR != IS_CONST && tmp_is_dup) {
						zval_dtor(&tmp);
					} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
						zval_ptr_dtor(&tmp);
					}
					zval_dtor(free_op1.var);
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		zend_std_unset_static_property(ce, Z_STR_P(varname), ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_hash_del_ind(target_symbol_table, Z_STR_P(varname));
	}

	if (IS_TMP_VAR != IS_CONST && tmp_is_dup) {
		zval_dtor(&tmp);
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		zval_ptr_dtor(&tmp);
	}
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_UNDEF) {
			value = EX_VAR(opline->op1.var);
			ZVAL_DEREF(value);
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_DUP(&tmp, varname);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_CONST != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_CONST == IS_CONST) {
				if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
					ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				} else {
					ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op2.var));
			}
			value = zend_std_get_static_property(ce, Z_STR_P(varname), 1, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if ((value = zend_hash_find(target_symbol_table, Z_STR_P(varname))) == NULL) {
				isset = 0;
			}
		}

		if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_dtor(free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_P(value) != IS_NULL) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(value TSRMLS_CC)) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_TMP_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_TMP_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_TMP_VAR == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_CONST == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_CONST == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_TMP_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_dtor(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_VAR_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *str = EX_VAR(opline->result.var);
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		ZVAL_EMPTY_STRING(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		ZVAL_DEREF(var);
		if (Z_TYPE_P(var) != IS_STRING) {
			zend_make_printable_zval(var, &var_copy, &use_copy);

			if (use_copy) {
				var = &var_copy;
			}
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_free_op free_op1, free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_TMP_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_TMP_VAR == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_dtor(free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		expr_ptr = NULL;
		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_TMP_VAR == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_TMP_VAR == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_TMP_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}
		zval_dtor(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_TMP_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_TMP_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_TMP_VAR == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_TMP_VAR == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_TMP_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_TMP_VAR(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval *retval;
	zval tmp_varname;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_UNDEF(&tmp_varname);
 	if (IS_TMP_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_DUP_DEREF(&tmp_varname, varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_TMP_VAR != IS_CONST) {
						zval_dtor(&tmp_varname);
					}
					zval_dtor(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		retval = zend_std_get_static_property(ce, Z_STR_P(varname), 0, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
		zval_dtor(free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		retval = zend_hash_find(target_symbol_table, Z_STR_P(varname));
		if (retval == NULL) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = EX_VAR(opline->result.var);
					ZVAL_NULL(retval);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					retval = zend_hash_update(target_symbol_table, Z_STR_P(varname), &EG(uninitialized_zval));
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
		} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
			retval = Z_INDIRECT_P(retval);
			if (Z_TYPE_P(retval) == IS_UNDEF) {
				switch (type) {
					case BP_VAR_R:
					case BP_VAR_UNSET:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_IS:
						retval = EX_VAR(opline->result.var);
						ZVAL_NULL(retval);
						break;
					case BP_VAR_RW:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_W:
						ZVAL_NULL(retval);
						break;
					EMPTY_SWITCH_DEFAULT_CASE()
				}
			}
		}
		if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) == ZEND_FETCH_STATIC) {
			zval_update_constant(retval, (void*) 1 TSRMLS_CC);
		} else if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) != ZEND_FETCH_GLOBAL_LOCK) {
			zval_dtor(free_op1.var);
		}
	}

	if (IS_TMP_VAR != IS_CONST) {
		zval_dtor(&tmp_varname);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY(EX_VAR(opline->result.var), retval);
	} else {
		if (/*type == BP_VAR_W &&*/ (opline->extended_value & ZEND_FETCH_MAKE_REF)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
		}
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_VAR(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_VAR(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_VAR(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		return zend_fetch_var_address_helper_SPEC_TMP_VAR(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		return zend_fetch_var_address_helper_SPEC_TMP_VAR(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_VAR(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_VAR(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_TMP_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_dtor(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_VAR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *str = EX_VAR(opline->result.var);
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		ZVAL_EMPTY_STRING(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		ZVAL_DEREF(var);
		if (Z_TYPE_P(var) != IS_STRING) {
			zend_make_printable_zval(var, &var_copy, &use_copy);

			if (use_copy) {
				var = &var_copy;
			}
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */
	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_free_op free_op1, free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_VAR == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor_nogc(free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		expr_ptr = NULL;
		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_TMP_VAR == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_TMP_VAR == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}
		zval_ptr_dtor_nogc(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;
	zend_bool tmp_is_dup = 0;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
	    ZVAL_COPY_VALUE(&tmp, EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->op1.var));
		zval_ptr_dtor(&tmp);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_DUP(&tmp, varname);
		convert_to_string(&tmp);
		varname = &tmp;
		tmp_is_dup = 1;
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		ZVAL_COPY(&tmp, varname);
		varname = &tmp;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_TMP_VAR != IS_CONST && tmp_is_dup) {
						zval_dtor(&tmp);
					} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
						zval_ptr_dtor(&tmp);
					}
					zval_dtor(free_op1.var);
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		zend_std_unset_static_property(ce, Z_STR_P(varname), ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_hash_del_ind(target_symbol_table, Z_STR_P(varname));
	}

	if (IS_TMP_VAR != IS_CONST && tmp_is_dup) {
		zval_dtor(&tmp);
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		zval_ptr_dtor(&tmp);
	}
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_UNDEF) {
			value = EX_VAR(opline->op1.var);
			ZVAL_DEREF(value);
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_DUP(&tmp, varname);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_VAR != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_VAR == IS_CONST) {
				if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
					ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				} else {
					ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op2.var));
			}
			value = zend_std_get_static_property(ce, Z_STR_P(varname), 1, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if ((value = zend_hash_find(target_symbol_table, Z_STR_P(varname))) == NULL) {
				isset = 0;
			}
		}

		if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_dtor(free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_P(value) != IS_NULL) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(value TSRMLS_CC)) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_TMP_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_TMP_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_TMP_VAR == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_VAR == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));
			zval_ptr_dtor_nogc(free_op2.var);
		} else {
			if (IS_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_TMP_UNUSED(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval *retval;
	zval tmp_varname;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_UNDEF(&tmp_varname);
 	if (IS_TMP_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_DUP_DEREF(&tmp_varname, varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_TMP_VAR != IS_CONST) {
						zval_dtor(&tmp_varname);
					}
					zval_dtor(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		retval = zend_std_get_static_property(ce, Z_STR_P(varname), 0, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
		zval_dtor(free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		retval = zend_hash_find(target_symbol_table, Z_STR_P(varname));
		if (retval == NULL) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = EX_VAR(opline->result.var);
					ZVAL_NULL(retval);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					retval = zend_hash_update(target_symbol_table, Z_STR_P(varname), &EG(uninitialized_zval));
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
		} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
			retval = Z_INDIRECT_P(retval);
			if (Z_TYPE_P(retval) == IS_UNDEF) {
				switch (type) {
					case BP_VAR_R:
					case BP_VAR_UNSET:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_IS:
						retval = EX_VAR(opline->result.var);
						ZVAL_NULL(retval);
						break;
					case BP_VAR_RW:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_W:
						ZVAL_NULL(retval);
						break;
					EMPTY_SWITCH_DEFAULT_CASE()
				}
			}
		}
		if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) == ZEND_FETCH_STATIC) {
			zval_update_constant(retval, (void*) 1 TSRMLS_CC);
		} else if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) != ZEND_FETCH_GLOBAL_LOCK) {
			zval_dtor(free_op1.var);
		}
	}

	if (IS_TMP_VAR != IS_CONST) {
		zval_dtor(&tmp_varname);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY(EX_VAR(opline->result.var), retval);
	} else {
		if (/*type == BP_VAR_W &&*/ (opline->extended_value & ZEND_FETCH_MAKE_REF)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
		}
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_TMP_UNUSED(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		expr_ptr = NULL;
		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_TMP_VAR == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_TMP_VAR == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_UNUSED != IS_UNUSED) {

		zval *offset = NULL;
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_UNUSED != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;
	zend_bool tmp_is_dup = 0;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
	    ZVAL_COPY_VALUE(&tmp, EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->op1.var));
		zval_ptr_dtor(&tmp);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_DUP(&tmp, varname);
		convert_to_string(&tmp);
		varname = &tmp;
		tmp_is_dup = 1;
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		ZVAL_COPY(&tmp, varname);
		varname = &tmp;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_TMP_VAR != IS_CONST && tmp_is_dup) {
						zval_dtor(&tmp);
					} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
						zval_ptr_dtor(&tmp);
					}
					zval_dtor(free_op1.var);
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		zend_std_unset_static_property(ce, Z_STR_P(varname), ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_hash_del_ind(target_symbol_table, Z_STR_P(varname));
	}

	if (IS_TMP_VAR != IS_CONST && tmp_is_dup) {
		zval_dtor(&tmp);
	} else if (IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) {
		zval_ptr_dtor(&tmp);
	}
	zval_dtor(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_TMP_VAR == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_UNDEF) {
			value = EX_VAR(opline->op1.var);
			ZVAL_DEREF(value);
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_TMP_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_DUP(&tmp, varname);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_UNUSED != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_UNUSED == IS_CONST) {
				if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
					ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				} else {
					ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op2.var));
			}
			value = zend_std_get_static_property(ce, Z_STR_P(varname), 1, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if ((value = zend_hash_find(target_symbol_table, Z_STR_P(varname))) == NULL) {
				isset = 0;
			}
		}

		if (IS_TMP_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_dtor(free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_P(value) != IS_NULL) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(value TSRMLS_CC)) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_TMP_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_TMP_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_TMP_VAR == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_UNUSED == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_UNUSED == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_dtor(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);

	if (IS_TMP_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_dtor(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_VAR_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *str = EX_VAR(opline->result.var);
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_TMP_VAR == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		ZVAL_EMPTY_STRING(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		ZVAL_DEREF(var);
		if (Z_TYPE_P(var) != IS_STRING) {
			zend_make_printable_zval(var, &var_copy, &use_copy);

			if (use_copy) {
				var = &var_copy;
			}
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_free_op free_op1;
	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_CV != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_CV == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {
		expr_ptr = NULL;
		if (IS_TMP_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (1) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_TMP_VAR == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_TMP_VAR == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CV != IS_UNUSED) {

		zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_CV != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_TMP_VAR == IS_VAR || IS_TMP_VAR == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_TMP_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_TMP_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_TMP_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_TMP_VAR == IS_CONST || IS_TMP_VAR == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!1) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_TMP_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_TMP_VAR == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = _get_zval_ptr_tmp(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_TMP_VAR == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_TMP_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_TMP_VAR == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_CV == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_CV == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_BW_NOT_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_not_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_NOT_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_not_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *var_ptr;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (UNEXPECTED(Z_ISREF_P(var_ptr))) {
		var_ptr = Z_REFVAL_P(var_ptr);
	} else {
		SEPARATE_ZVAL(var_ptr);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_P(var_ptr, get)
	   && Z_OBJ_HANDLER_P(var_ptr, set)) {
		/* proxy object */
		zval rv;
		zval *val = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_increment_function(val);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(val);
	} else {
		fast_increment_function(var_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *var_ptr;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (UNEXPECTED(Z_ISREF_P(var_ptr))) {
		var_ptr = Z_REFVAL_P(var_ptr);
	} else {
		SEPARATE_ZVAL(var_ptr);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_P(var_ptr, get)
	   && Z_OBJ_HANDLER_P(var_ptr, set)) {
		/* proxy object */
		zval rv;
		zval *val = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_decrement_function(val);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(val);
	} else {
		fast_decrement_function(var_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *var_ptr, *retval;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		ZVAL_NULL(EX_VAR(opline->result.var));
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	retval = EX_VAR(opline->result.var);

	if (UNEXPECTED(Z_ISREF_P(var_ptr))) {
		var_ptr = Z_REFVAL_P(var_ptr);
		ZVAL_DUP(retval, var_ptr);
	} else {
		ZVAL_DUP(retval, var_ptr);
		SEPARATE_ZVAL(var_ptr);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_P(var_ptr, get)
	   && Z_OBJ_HANDLER_P(var_ptr, set)) {
		/* proxy object */
		zval rv;
		zval *val = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_increment_function(val);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(val);
	} else {
		fast_increment_function(var_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_DEC_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *var_ptr, *retval;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		ZVAL_NULL(EX_VAR(opline->result.var));
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	retval = EX_VAR(opline->result.var);

	if (UNEXPECTED(Z_ISREF_P(var_ptr))) {
		var_ptr = Z_REFVAL_P(var_ptr);
		ZVAL_DUP(retval, var_ptr);
	} else {
		ZVAL_DUP(retval, var_ptr);
		SEPARATE_ZVAL(var_ptr);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_P(var_ptr, get)
	   && Z_OBJ_HANDLER_P(var_ptr, set)) {
		/* proxy object */
		zval rv;
		zval *val = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_decrement_function(val);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(val);
	} else {
		fast_decrement_function(var_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ECHO_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *z;

	SAVE_OPLINE();
	z = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	zend_print_variable(z);

	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRINT_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_LONG(EX_VAR(opline->result.var), 1);
	return ZEND_ECHO_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_JMPZ_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (!ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPZNZ_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (EXPECTED(retval != 0)) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on true to %d\n", opline->extended_value);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	} else {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on false to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
}

static int ZEND_FASTCALL  ZEND_JMPZ_EX_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	ZVAL_BOOL(EX_VAR(opline->result.var), retval);
	if (!retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_EX_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op1.var);
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	ZVAL_BOOL(EX_VAR(opline->result.var), retval);
	if (retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FREE_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_VAR == IS_TMP_VAR) {
		zval_dtor(EX_VAR(opline->op1.var));
	} else {
		zval_ptr_dtor(EX_VAR(opline->op1.var));
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RETURN_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zend_free_op free_op1;

	SAVE_OPLINE();
	retval_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (!EX(return_value)) {
		zval_ptr_dtor_nogc(free_op1.var);
	} else {
		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
			if (IS_VAR != IS_TMP_VAR) {
				zval_opt_copy_ctor(EX(return_value));
			}
			zval_ptr_dtor_nogc(free_op1.var);
		} else if (Z_ISREF_P(retval_ptr)) {
			ZVAL_DUP(EX(return_value), Z_REFVAL_P(retval_ptr));
			zval_ptr_dtor_nogc(free_op1.var);
		} else {
			ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
			if (IS_VAR == IS_CV) {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) Z_ADDREF_P(retval_ptr);
			}
		}
	}
	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;
	zend_free_op free_op1;

	SAVE_OPLINE();

	do {
		if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR ||
		    (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
			if (!EX(return_value)) {
				if (IS_VAR == IS_TMP_VAR) {
					zval_ptr_dtor_nogc(free_op1.var);
				}
			} else if (!0) { /* Not a temp var */
				ZVAL_DUP(EX(return_value), retval_ptr);
			} else {
				ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
			}
			break;
		}

		retval_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(retval_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot return string offsets by reference");
		}

		if (IS_VAR == IS_VAR && !Z_ISREF_P(retval_ptr)) {
			if (opline->extended_value == ZEND_RETURNS_FUNCTION &&
			    (Z_VAR_FLAGS_P(retval_ptr) & IS_VAR_RET_REF)) {
			} else {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EX(return_value)) {
					zval tmp;
					ZVAL_DUP(&tmp, retval_ptr);
					ZVAL_NEW_REF(EX(return_value), &tmp);
				}
				break;
			}
		}

		if (EX(return_value)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			ZVAL_COPY(EX(return_value), retval_ptr);
		}
	} while (0);

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_THROW_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval exception;
	zend_free_op free_op1;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Can only throw objects");
	}

	zend_exception_save(TSRMLS_C);
	if (IS_VAR == IS_CONST) {
		ZVAL_DUP(&exception, value);
		value = &exception;
	} else if (IS_VAR != IS_TMP_VAR) {
		if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
	}

	zend_throw_exception_object(value TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);
	zval_ptr_dtor_nogc(free_op1.var);
	HANDLE_EXCEPTION();
}

static int ZEND_FASTCALL zend_send_by_var_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *top;
	zend_free_op free_op1;

	varptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	top = zend_vm_stack_top_inc(TSRMLS_C);
	if (Z_ISREF_P(varptr)) {
		ZVAL_DUP(top, Z_REFVAL_P(varptr));
		zval_ptr_dtor_nogc(free_op1.var);
	} else {
		if (IS_VAR == IS_CV) {
			if (Z_REFCOUNTED_P(varptr)) Z_ADDREF_P(varptr);
		}
		ZVAL_COPY_VALUE(top, varptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varptr;
	int arg_num;

	SAVE_OPLINE();
	if (opline->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) { /* Had function_ptr at compile_time */
		if (!(opline->extended_value & ZEND_ARG_SEND_BY_REF)) {
			return zend_send_by_var_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	} else {
		arg_num = opline->op2.num + EX(call)->num_additional_args;
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
			return zend_send_by_var_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}

	varptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if ((!(opline->extended_value & ZEND_ARG_SEND_FUNCTION) ||
	     (Z_VAR_FLAGS_P(varptr) & IS_VAR_RET_REF)) &&
	    ((!Z_REFCOUNTED_P(varptr) && Z_TYPE_P(varptr) != IS_STRING) ||
	     Z_ISREF_P(varptr) ||
	     Z_TYPE_P(varptr) == IS_OBJECT ||
	     (Z_REFCOUNTED_P(varptr) && Z_REFCOUNT_P(varptr) == 1))) {

		if (Z_ISREF_P(varptr)) {
			if (IS_VAR == IS_CV) {
				Z_ADDREF_P(varptr);
			}
		} else {
			ZVAL_NEW_REF(varptr, varptr);
			if (IS_VAR == IS_CV) {
				Z_ADDREF_P(varptr);
			}
		}
		zend_vm_stack_push(varptr TSRMLS_CC);
	} else {
		zval val;

		if ((opline->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) ?
			!(opline->extended_value & ZEND_ARG_SEND_SILENT) :
			!ARG_MAY_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
			zend_error(E_STRICT, "Only variables should be passed by reference");
		}
		ZVAL_COPY_VALUE(&val, varptr);
		if (!0) {
			zval_opt_copy_ctor(&val);
		}
		zval_ptr_dtor_nogc(free_op1.var);
		zend_vm_stack_push(&val TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEND_REF_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varptr;

	SAVE_OPLINE();
	varptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(varptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Only variables can be passed by reference");
	}

	if (IS_VAR == IS_VAR && UNEXPECTED(varptr == &EG(error_zval))) {
		zend_vm_stack_push(&EG(uninitialized_zval) TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (opline->extended_value == ZEND_DO_FCALL_BY_NAME &&
	    EX(function_state).function->type == ZEND_INTERNAL_FUNCTION) {
		int arg_num = opline->op2.num + EX(call)->num_additional_args;
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
			return zend_send_by_var_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}

	if (Z_ISREF_P(varptr)) {
		Z_ADDREF_P(varptr);
	} else if (IS_VAR == IS_VAR &&
		EXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {
		zval tmp;
		ZVAL_COPY_VALUE(&tmp, varptr);
		varptr = &tmp;
		SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr);
	} else {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr);
		Z_ADDREF_P(varptr);
	}

	zend_vm_stack_push(varptr TSRMLS_CC);

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEND_VAR_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (opline->extended_value == ZEND_DO_FCALL_BY_NAME) {
		int arg_num = opline->op2.num + EX(call)->num_additional_args;
		if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
			return ZEND_SEND_REF_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}
	SAVE_OPLINE();
	return zend_send_by_var_helper_SPEC_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_BOOL_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *retval = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	/* PHP 3.0 returned "" for false and 1 for true, here we use 0 and 1 for now */
	ZVAL_BOOL(retval, i_zend_is_true(_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SWITCH_FREE_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	zval_ptr_dtor(EX_VAR(opline->op1.var));
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CLONE_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name->val);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name->val, EG(scope) ? EG(scope)->name->val : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name->val, EG(scope) ? EG(scope)->name->val : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		ZVAL_OBJ(EX_VAR(opline->result.var), clone_call(obj TSRMLS_CC));
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(EX_VAR(opline->result.var));
		}
	}
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CAST_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr, *expr_ptr;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	expr = expr_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		ZVAL_DEREF(expr);
	}
	if (Z_TYPE_P(expr) == opline->extended_value) {
		ZVAL_COPY_VALUE(result, expr);
		if (IS_VAR == IS_CONST || expr != expr_ptr) {
			zval_opt_copy_ctor(result);
			zval_ptr_dtor_nogc(free_op1.var);
		} else if (IS_VAR == IS_CV) {
			if (Z_OPT_REFCOUNTED_P(expr)) Z_ADDREF_P(expr);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (opline->extended_value != IS_STRING) {
		ZVAL_COPY_VALUE(result, expr);
		if (!0) {
			zval_opt_copy_ctor(result);
		}
	}

	switch (opline->extended_value) {
		case IS_NULL:
			convert_to_null(result);
			break;
		case IS_BOOL:
			convert_to_boolean(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		case IS_DOUBLE:
			convert_to_double(result);
			break;
		case IS_STRING: {
			zval var_copy;
			int use_copy;

			zend_make_printable_zval(expr, &var_copy, &use_copy);
			if (use_copy) {
				ZVAL_COPY_VALUE(result, &var_copy);
				if (0) {
					zval_ptr_dtor_nogc(free_op1.var);
				}
			} else {
				ZVAL_COPY_VALUE(result, expr);
				if (!0) {
					zval_opt_copy_ctor(result);
				}
			}
			break;
		}
		case IS_ARRAY:
			convert_to_array(result);
			break;
		case IS_OBJECT:
			convert_to_object(result);
			break;
	}
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_op_array *new_op_array=NULL;
	zend_free_op free_op1;
	zval *inc_filename;
	zval tmp_inc_filename;
	zend_bool failure_retval=0;

	SAVE_OPLINE();
	inc_filename = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_UNDEF(&tmp_inc_filename);
	if (Z_TYPE_P(inc_filename) != IS_STRING) {
		ZVAL_DUP(&tmp_inc_filename, inc_filename);
		convert_to_string(&tmp_inc_filename);
		inc_filename = &tmp_inc_filename;
	}

	if (opline->extended_value != ZEND_EVAL && strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)) {
		if (opline->extended_value == ZEND_INCLUDE_ONCE || opline->extended_value == ZEND_INCLUDE) {
			zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		} else {
			zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		}
	} else {
		switch (opline->extended_value) {
			case ZEND_INCLUDE_ONCE:
			case ZEND_REQUIRE_ONCE: {
					zend_file_handle file_handle;
					char *resolved_path;

					resolved_path = zend_resolve_path(Z_STRVAL_P(inc_filename), Z_STRLEN_P(inc_filename) TSRMLS_CC);
					if (resolved_path) {
						failure_retval = zend_hash_str_exists(&EG(included_files), resolved_path, strlen(resolved_path));
					} else {
						resolved_path = Z_STRVAL_P(inc_filename);
					}

					if (failure_retval) {
						/* do nothing, file already included */
					} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {

						if (!file_handle.opened_path) {
							file_handle.opened_path = estrdup(resolved_path);
						}

						if (zend_hash_str_add_empty_element(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path))) {
							new_op_array = zend_compile_file(&file_handle, (opline->extended_value==ZEND_INCLUDE_ONCE?ZEND_INCLUDE:ZEND_REQUIRE) TSRMLS_CC);
							zend_destroy_file_handle(&file_handle TSRMLS_CC);
						} else {
							zend_file_handle_dtor(&file_handle TSRMLS_CC);
							failure_retval=1;
						}
					} else {
						if (opline->extended_value == ZEND_INCLUDE_ONCE) {
							zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						} else {
							zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						}
					}
					if (resolved_path != Z_STRVAL_P(inc_filename)) {
						efree(resolved_path);
					}
				}
				break;
			case ZEND_INCLUDE:
			case ZEND_REQUIRE:
				new_op_array = compile_filename(opline->extended_value, inc_filename TSRMLS_CC);
				break;
			case ZEND_EVAL: {
					char *eval_desc = zend_make_compiled_string_description("eval()'d code" TSRMLS_CC);

					new_op_array = zend_compile_string(inc_filename, eval_desc TSRMLS_CC);
					efree(eval_desc);
				}
				break;
			EMPTY_SWITCH_DEFAULT_CASE()
		}
	}
	if (Z_TYPE(tmp_inc_filename) != IS_UNDEF) {
		zval_ptr_dtor(&tmp_inc_filename);
	}
	zval_ptr_dtor_nogc(free_op1.var);
	if (UNEXPECTED(EG(exception) != NULL)) {
		HANDLE_EXCEPTION();
	} else if (EXPECTED(new_op_array != NULL)) {
		zval *return_value = NULL;

		EG(active_op_array) = new_op_array;
		if (RETURN_VALUE_USED(opline)) {
			return_value = EX_VAR(opline->result.var);
		}

		EX(function_state).function = (zend_function *) new_op_array;
		EX(object) = NULL;

		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		if (EXPECTED(zend_execute_ex == execute_ex)) {
		    i_create_execute_data_from_op_array(new_op_array, return_value, VM_FRAME_NESTED_CODE TSRMLS_CC);
			ZEND_VM_ENTER();
		} else {
			zend_execute(new_op_array, return_value TSRMLS_CC);
		}

		EX(function_state).function = (zend_function *) EX(op_array);

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		destroy_op_array(new_op_array TSRMLS_CC);
		efree(new_op_array);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}

	} else if (RETURN_VALUE_USED(opline)) {
		ZVAL_BOOL(EX_VAR(opline->result.var), failure_retval);
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FE_RESET_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *array_ptr, *array_ref, iterator;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	zend_class_entry *ce = NULL;
	zend_bool is_empty = 0;

	SAVE_OPLINE();

	if ((IS_VAR == IS_CV || IS_VAR == IS_VAR) &&
	    (opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
		array_ptr = array_ref = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		ZVAL_DEREF(array_ptr);
		if (Z_TYPE_P(array_ptr) == IS_ARRAY) {
			if (!Z_ISREF_P(array_ref)) {
				SEPARATE_ZVAL(array_ptr);
				array_ref = array_ptr;
				if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
					ZVAL_NEW_REF(array_ptr, array_ptr);
					array_ref = array_ptr;
					array_ptr = Z_REFVAL_P(array_ptr);
				}
			}
			if (Z_REFCOUNTED_P(array_ref)) Z_ADDREF_P(array_ref);
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			if(Z_OBJ_HT_P(array_ptr)->get_class_entry == NULL) {
				zend_error(E_WARNING, "foreach() cannot iterate over objects without PHP class");
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}

			ce = Z_OBJCE_P(array_ptr);
			if (!ce || ce->get_iterator == NULL) {
				if (!Z_ISREF_P(array_ref)) {
					SEPARATE_ZVAL(array_ptr);
				}
				Z_ADDREF_P(array_ptr);
			}
			array_ref = array_ptr;
		} else {
			if (Z_REFCOUNTED_P(array_ref)) Z_ADDREF_P(array_ref);
		}
	} else {
		array_ptr = array_ref = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		ZVAL_DEREF(array_ptr);
		if (0) { /* IS_TMP_VAR */
			zval tmp;

			ZVAL_COPY_VALUE(&tmp, array_ptr);
			array_ptr = &tmp;
			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
				ce = Z_OBJCE_P(array_ptr);
				if (ce && ce->get_iterator) {
					Z_DELREF_P(array_ref);
				}
			}
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			ce = Z_OBJCE_P(array_ptr);
			if (!ce || !ce->get_iterator) {
				if (IS_VAR == IS_CV) {
					Z_ADDREF_P(array_ref);
				}
			}
		} else if (Z_REFCOUNTED_P(array_ref)) {
			if (IS_VAR == IS_CONST ||
			           (IS_VAR == IS_CV &&
			            !Z_ISREF_P(array_ref) &&
			            Z_REFCOUNT_P(array_ref) > 1) ||
			           (IS_VAR == IS_VAR &&
			            !Z_ISREF_P(array_ref) &&
			            Z_REFCOUNT_P(array_ref) > 2)) {
				zval tmp;

				if (IS_VAR == IS_VAR) {
					Z_DELREF_P(array_ref);
				}
				ZVAL_DUP(&tmp, array_ref);
				array_ptr = array_ref = &tmp;
			} else if (IS_VAR == IS_CV) {
				if (Z_ISREF_P(array_ref) && Z_REFCOUNT_P(array_ref) == 1) {
					ZVAL_UNREF(array_ref);
					array_ptr = array_ref;
				}
				Z_ADDREF_P(array_ref);
			}
		}
	}

	if (ce && ce->get_iterator) {
		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);

		if (IS_VAR == IS_VAR && !(opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
			zval_ptr_dtor_nogc(free_op1.var);
		}
		if (iter && EXPECTED(EG(exception) == NULL)) {
			ZVAL_OBJ(&iterator, &iter->std);
			array_ptr = array_ref = &iterator;
		} else {
			if (IS_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {
				if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
			}
			if (!EG(exception)) {
				zend_throw_exception_ex(NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name->val);
			}
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}
	}

	ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);

	if (iter) {
		iter->index = 0;
		if (iter->funcs->rewind) {
			iter->funcs->rewind(iter TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(array_ref);
				if (IS_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {
					if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
				}
				HANDLE_EXCEPTION();
			}
		}
		is_empty = iter->funcs->valid(iter TSRMLS_CC) != SUCCESS;
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(array_ref);
			if (IS_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {
				if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
			}
			HANDLE_EXCEPTION();
		}
		iter->index = -1; /* will be set to 0 before using next handler */
	} else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {
		zend_hash_internal_pointer_reset(fe_ht);
		if (ce) {
			zend_object *zobj = Z_OBJ_P(array_ptr);
			while (zend_hash_has_more_elements(fe_ht) == SUCCESS) {
				zend_string *str_key;
				ulong int_key;
				zend_uchar key_type;

				key_type = zend_hash_get_current_key(fe_ht, &str_key, &int_key, 0);
				if (key_type != HASH_KEY_NON_EXISTENT &&
					(key_type == HASH_KEY_IS_LONG ||
				     zend_check_property_access(zobj, str_key TSRMLS_CC) == SUCCESS)) {
					break;
				}
				zend_hash_move_forward(fe_ht);
			}
		}
		is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;
		zend_hash_get_pointer(fe_ht, (HashPointer*)EX_VAR((opline+2)->op1.var));
	} else {
		zend_error(E_WARNING, "Invalid argument supplied for foreach()");
		is_empty = 1;
	}

	if (IS_VAR == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	}
	if (is_empty) {
		ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
	} else {
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_FE_FETCH_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *array, *array_ref;
	zval *value;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	zval *key = NULL;

	array = array_ref = EX_VAR(opline->op1.var);
	ZVAL_DEREF(array);
	if (opline->extended_value & ZEND_FE_FETCH_WITH_KEY) {
		key = EX_VAR((opline+1)->result.var);
	}

	SAVE_OPLINE();

	switch (zend_iterator_unwrap(array, &iter TSRMLS_CC)) {
		default:
		case ZEND_ITER_INVALID:
			zend_error(E_WARNING, "Invalid argument supplied for foreach()");
			ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);

		case ZEND_ITER_PLAIN_OBJECT: {
			zend_object *zobj = Z_OBJ_P(array);
			int key_type;
			zend_string *str_key;
			zend_ulong int_key;

			fe_ht = Z_OBJPROP_P(array);
			zend_hash_set_pointer(fe_ht, (HashPointer*)EX_VAR((opline+1)->op1.var));
			while (1) {
				if ((value = zend_hash_get_current_data(fe_ht)) == NULL) {
					/* reached end of iteration */
					ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
				}

				if (Z_TYPE_P(value) == IS_INDIRECT) {
					value = Z_INDIRECT_P(value);
					if (Z_TYPE_P(value) == IS_UNDEF) {
						zend_hash_move_forward(fe_ht);
						continue;
					}
				}

				key_type = zend_hash_get_current_key(fe_ht, &str_key, &int_key, 0);

				zend_hash_move_forward(fe_ht);
				if (key_type == HASH_KEY_IS_LONG ||
				    zend_check_property_access(zobj, str_key TSRMLS_CC) == SUCCESS) {
					break;
				}
			}

			if (key) {
				if (key_type == HASH_KEY_IS_LONG) {
					ZVAL_LONG(key, int_key);
				} else {
					const char *class_name, *prop_name;
					int prop_name_len;
					zend_unmangle_property_name_ex(
						str_key->val, str_key->len, &class_name, &prop_name, &prop_name_len
					);
					ZVAL_STRINGL(key, prop_name, prop_name_len);
				}
			}

			zend_hash_get_pointer(fe_ht, (HashPointer*)EX_VAR((opline+1)->op1.var));
			break;
		}

		case ZEND_ITER_PLAIN_ARRAY:
			fe_ht = Z_ARRVAL_P(array);
			zend_hash_set_pointer(fe_ht, (HashPointer*)EX_VAR((opline+1)->op1.var));
			if ((value = zend_hash_get_current_data(fe_ht)) == NULL) {
				/* reached end of iteration */
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}
			if (key) {
				zend_hash_get_current_key_zval(fe_ht, key);
			}
			zend_hash_move_forward(fe_ht);
			zend_hash_get_pointer(fe_ht, (HashPointer*)EX_VAR((opline+1)->op1.var));
			break;

		case ZEND_ITER_OBJECT:
			/* !iter happens from exception */
			if (iter && ++iter->index > 0) {
				/* This could cause an endless loop if index becomes zero again.
				 * In case that ever happens we need an additional flag. */
				iter->funcs->move_forward(iter TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					zval_ptr_dtor(array_ref);
					HANDLE_EXCEPTION();
				}
			}
			/* If index is zero we come from FE_RESET and checked valid() already. */
			if (!iter || (iter->index > 0 && iter->funcs->valid(iter TSRMLS_CC) == FAILURE)) {
				/* reached end of iteration */
				if (UNEXPECTED(EG(exception) != NULL)) {
					zval_ptr_dtor(array_ref);
					HANDLE_EXCEPTION();
				}
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}
			value = iter->funcs->get_current_data(iter TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(array_ref);
				HANDLE_EXCEPTION();
			}
			if (!value) {
				/* failure in get_current_data */
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}
			if (key) {
				if (iter->funcs->get_current_key) {
					iter->funcs->get_current_key(iter, key TSRMLS_CC);
					if (UNEXPECTED(EG(exception) != NULL)) {
						zval_ptr_dtor(array_ref);
						HANDLE_EXCEPTION();
					}
				} else {
					ZVAL_LONG(key, iter->index);
				}
			}
			break;
	}

	if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(value);
	}
	ZVAL_COPY(EX_VAR(opline->result.var), value);

	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_EXIT_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0 || (IS_VAR != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;
		zval *ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}
		zval_ptr_dtor_nogc(free_op1.var);
	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

static int ZEND_FASTCALL  ZEND_JMP_SET_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (i_zend_is_true(value TSRMLS_CC)) {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
		if (!0) {
			zval_opt_copy_ctor(EX_VAR(opline->result.var));
		}
		zval_ptr_dtor_nogc(free_op1.var);
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (i_zend_is_true(value TSRMLS_CC)) {
		if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		} else {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
			if (!0) {
				zval_opt_copy_ctor(EX_VAR(opline->result.var));
			}
		}
		zval_ptr_dtor_nogc(free_op1.var);
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
	if (!0) {
		zval_opt_copy_ctor(EX_VAR(opline->result.var));
	}
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	} else {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
		if (!0) {
			zval_opt_copy_ctor(EX_VAR(opline->result.var));
		}
	}

	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INSTANCEOF_SPEC_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (Z_TYPE_P(expr) == IS_OBJECT && Z_OBJ_HT_P(expr)->get_class_entry) {
		result = instanceof_function(Z_OBJCE_P(expr), Z_CE_P(EX_VAR(opline->op2.var)) TSRMLS_CC);
	} else {
		result = 0;
	}
	ZVAL_BOOL(EX_VAR(opline->result.var), result);
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data1;
	zval *object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *property = opline->op2.zv;
	zval *value;
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = opline->op2.zv;

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_CONST TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:

	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_VAR_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = opline->op2.zv;
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CONST(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CONST(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CONST(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CONST(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CONST(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CONST(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CONST(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CONST(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CONST(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CONST(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CONST(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CONST(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CONST(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_VAR_CONST(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = opline->op2.zv;
	retval = EX_VAR(opline->result.var);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(retval);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(zptr);
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(retval, zptr);
			}
		}
	}

	if (!have_get_ptr) {
		zval rv;

		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(z);
			incdec_op(z);
			ZVAL_COPY_VALUE(retval, z);
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(retval, opline);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(retval);
			}
		}
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_CONST(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_CONST(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_VAR_CONST(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = opline->op2.zv;
	retval = EX_VAR(opline->result.var);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_DUP(retval, zptr);

			incdec_op(zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval rv;
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
			zval z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			ZVAL_DUP(retval, z);
			ZVAL_DUP(&z_copy, z);
			incdec_op(&z_copy);
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, &z_copy, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_CONST(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_CONST(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_VAR_CONST(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval *retval;
	zval tmp_varname;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_UNDEF(&tmp_varname);
 	if (IS_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_DUP_DEREF(&tmp_varname, varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_VAR != IS_CONST) {
						zval_dtor(&tmp_varname);
					}
					zval_ptr_dtor_nogc(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		retval = zend_std_get_static_property(ce, Z_STR_P(varname), 0, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		retval = zend_hash_find(target_symbol_table, Z_STR_P(varname));
		if (retval == NULL) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = EX_VAR(opline->result.var);
					ZVAL_NULL(retval);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					retval = zend_hash_update(target_symbol_table, Z_STR_P(varname), &EG(uninitialized_zval));
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
		} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
			retval = Z_INDIRECT_P(retval);
			if (Z_TYPE_P(retval) == IS_UNDEF) {
				switch (type) {
					case BP_VAR_R:
					case BP_VAR_UNSET:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_IS:
						retval = EX_VAR(opline->result.var);
						ZVAL_NULL(retval);
						break;
					case BP_VAR_RW:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_W:
						ZVAL_NULL(retval);
						break;
					EMPTY_SWITCH_DEFAULT_CASE()
				}
			}
		}
		if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) == ZEND_FETCH_STATIC) {
			zval_update_constant(retval, (void*) 1 TSRMLS_CC);
		} else if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) != ZEND_FETCH_GLOBAL_LOCK) {
			zval_ptr_dtor_nogc(free_op1.var);
		}
	}

	if (IS_VAR != IS_CONST) {
		zval_dtor(&tmp_varname);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY(EX_VAR(opline->result.var), retval);
	} else {
		if (/*type == BP_VAR_W &&*/ (opline->extended_value & ZEND_FETCH_MAKE_REF)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
		}
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_CONST(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_CONST(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_CONST(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		return zend_fetch_var_address_helper_SPEC_VAR_CONST(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		return zend_fetch_var_address_helper_SPEC_VAR_CONST(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_CONST(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_CONST(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);

	if (IS_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_ptr_dtor_nogc(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (EXPECTED(opline->extended_value == 0)) {
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);
	} else {
		zend_fetch_dimension_address_W_ref(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);
	}

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_RW(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read_IS(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zend_free_op free_op1;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}

		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	} else {
		if (IS_CONST == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);

		zval_ptr_dtor_nogc(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_UNSET(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_VAR_CONST(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_VAR_CONST(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = opline->op2.zv;

	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, (opline->extended_value & ZEND_FETCH_MAKE_REF) != 0 TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = opline->op2.zv;
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_RW, 0 TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;

		SAVE_OPLINE();
		property = opline->op2.zv;
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, 0 TSRMLS_CC);

		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_VAR_CONST(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container, *property, *retval_ptr;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = opline->op2.zv;

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_UNSET, 0 TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *object;
	zval *property_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property_name = opline->op2.zv;

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (UNEXPECTED(Z_ISREF_P(object_ptr)) && Z_TYPE_P(Z_REFVAL_P(object_ptr)) == IS_OBJECT) {
		object_ptr = Z_REFVAL_P(object_ptr);
	}
	if (Z_TYPE_P(object_ptr) == IS_OBJECT) {

		zval *property_name = opline->op2.zv;

		zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);

	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = opline->op2.zv;
		zval *variable_ptr;

		zend_fetch_dimension_address_W(EX_VAR((opline+1)->op2.var), object_ptr, dim, IS_CONST TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
			zend_assign_to_string_offset(variable_ptr, value, (opline+1)->op1_type, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
		} else if (UNEXPECTED(variable_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
			FREE_OP_VAR_PTR(free_op_data2);
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(EX_VAR(opline->result.var), value);
			}
			FREE_OP_VAR_PTR(free_op_data2);
		}
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = opline->op2.zv;
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
		zend_assign_to_string_offset(variable_ptr, value, IS_CONST, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
	} else if (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		if (IS_CONST == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
		} else if (IS_CONST == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_free_op free_op1;
	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = opline->op2.zv;

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_CONST != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_CONST == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
			ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
		} else {
			ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), ce);
		}
		call->called_scope = ce;
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_CONST == IS_CONST &&
	    CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
		call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
	} else if (IS_VAR != IS_CONST &&
	           IS_CONST == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce))) {
		/* do nothing */
	} else if (IS_CONST != IS_UNUSED) {


		function_name = opline->op2.zv;
		if (IS_CONST != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
 			}
		}

		if (ce->get_static_method) {
			call->fbc = ce->get_static_method(ce, Z_STR_P(function_name) TSRMLS_CC);
		} else {
			call->fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_CONST == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
		}
		if (UNEXPECTED(call->fbc == NULL)) {
			zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name->val, Z_STRVAL_P(function_name));
		}
		if (IS_CONST == IS_CONST &&
		    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
		    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
			if (IS_VAR == IS_CONST) {
				CACHE_PTR(Z_CACHE_SLOT_P(function_name), call->fbc);
			} else {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), ce, call->fbc);
			}
		}
		if (IS_CONST != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (Z_OBJ(EG(This)) && Z_OBJCE(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name->val);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (Z_OBJ(EG(This)) &&
		    Z_OBJ_HT(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			}
		}
		call->object = Z_OBJ(EG(This));
		if (call->object) {
			GC_REFCOUNT(call->object)++;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 opline->op2.zv TSRMLS_CC));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_CONSTANT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_VAR == IS_UNUSED) {
		zend_constant *c;
		zval *retval;

		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
			c = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
		} else if ((c = zend_quick_get_constant(opline->op2.zv + 1, opline->extended_value TSRMLS_CC)) == NULL) {
			if ((opline->extended_value & IS_CONSTANT_UNQUALIFIED) != 0) {
				char *actual = (char *)zend_memrchr(Z_STRVAL_P(opline->op2.zv), '\\', Z_STRLEN_P(opline->op2.zv));
				if(!actual) {
					actual = Z_STRVAL_P(opline->op2.zv);
				} else {
					actual++;
				}
				/* non-qualified constant - allow text substitution */
				zend_error(E_NOTICE, "Use of undefined constant %s - assumed '%s'", actual, actual);
				ZVAL_STRINGL(EX_VAR(opline->result.var), actual, Z_STRLEN_P(opline->op2.zv)-(actual - Z_STRVAL_P(opline->op2.zv)));
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else {
				zend_error_noreturn(E_ERROR, "Undefined constant '%s'", Z_STRVAL_P(opline->op2.zv));
			}
		} else {
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), c);
		}
		retval = EX_VAR(opline->result.var);
		ZVAL_DUP(retval, &c->value);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		/* class constant */
		zend_class_entry *ce;
		zval *value;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				value = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				ZVAL_DUP(EX_VAR(opline->result.var), value);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, opline->extended_value TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op1.var));
			if ((value = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce)) != NULL) {
				ZVAL_DUP(EX_VAR(opline->result.var), value);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
		}

		if (EXPECTED((value = zend_hash_find(&ce->constants_table, Z_STR_P(opline->op2.zv))) != NULL)) {
			if (Z_ISREF_P(value)) {
				value = Z_REFVAL_P(value);
			}
			if (Z_CONSTANT_P(value)) {
				zend_class_entry *old_scope = EG(scope);

				EG(scope) = ce;
				zval_update_constant(value, (void *) 1 TSRMLS_CC);
				EG(scope) = old_scope;
			}
			if (IS_VAR == IS_CONST) {
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), value);
			} else {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce, value);
			}
			ZVAL_DUP(EX_VAR(opline->result.var), value);
		} else if (Z_STRLEN_P(opline->op2.zv) == sizeof("class")-1 && memcmp(Z_STRVAL_P(opline->op2.zv), "class", sizeof("class") - 1) == 0) {
			/* "class" is assigned as a case-sensitive keyword from zend_do_resolve_class_name */
			ZVAL_STR(EX_VAR(opline->result.var), ce->name);
			STR_ADDREF(ce->name);
		} else {
			zend_error_noreturn(E_ERROR, "Undefined class constant '%s'", Z_STRVAL_P(opline->op2.zv));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_VAR == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;
			zval_ptr_dtor_nogc(free_op1.var);
		} else if (IS_VAR == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CONST != IS_UNUSED) {

		zval *offset = opline->op2.zv;
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_CONST != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;
	zend_bool tmp_is_dup = 0;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
	    ZVAL_COPY_VALUE(&tmp, EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->op1.var));
		zval_ptr_dtor(&tmp);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_DUP(&tmp, varname);
		convert_to_string(&tmp);
		varname = &tmp;
		tmp_is_dup = 1;
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		ZVAL_COPY(&tmp, varname);
		varname = &tmp;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_VAR != IS_CONST && tmp_is_dup) {
						zval_dtor(&tmp);
					} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
						zval_ptr_dtor(&tmp);
					}
					zval_ptr_dtor_nogc(free_op1.var);
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		zend_std_unset_static_property(ce, Z_STR_P(varname), ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_hash_del_ind(target_symbol_table, Z_STR_P(varname));
	}

	if (IS_VAR != IS_CONST && tmp_is_dup) {
		zval_dtor(&tmp);
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		zval_ptr_dtor(&tmp);
	}
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR != IS_UNUSED) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = opline->op2.zv;

container_again:
	switch (Z_TYPE_P(container)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(container);
offset_again:
			switch (Z_TYPE_P(offset)) {
				case IS_DOUBLE:
					hval = zend_dval_to_lval(Z_DVAL_P(offset));
					zend_hash_index_del(ht, hval);
					break;
				case IS_RESOURCE:
				case IS_BOOL:
				case IS_LONG:
					hval = Z_LVAL_P(offset);
					zend_hash_index_del(ht, hval);
					break;
				case IS_STRING:
					if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
						if (Z_REFCOUNTED_P(offset)) Z_ADDREF_P(offset);
					}
					if (IS_CONST != IS_CONST) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
					}
					if (ht == &EG(symbol_table).ht) {
						zend_delete_global_variable(Z_STR_P(offset) TSRMLS_CC);
					} else {
						zend_hash_del(ht, Z_STR_P(offset));
					}
					if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
num_index_dim:
					zend_hash_index_del(ht, hval);
					if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
				case IS_NULL:
					zend_hash_del(ht, STR_EMPTY_ALLOC());
					break;
				case IS_REFERENCE:
					offset = Z_REFVAL_P(offset);
					goto offset_again;
					break;
				default:
					zend_error(E_WARNING, "Illegal offset type in unset");
					break;
			}

			break;
		}
		case IS_OBJECT:
			if (UNEXPECTED(Z_OBJ_HT_P(container)->unset_dimension == NULL)) {
				zend_error_noreturn(E_ERROR, "Cannot use object as array");
			}
//???			if (IS_CONST == IS_CONST) {
//???				zval_copy_ctor(offset);
//???			}
			Z_OBJ_HT_P(container)->unset_dimension(container, offset TSRMLS_CC);

			break;
		case IS_STRING:
		case IS_STR_OFFSET:
			zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
			ZEND_VM_CONTINUE(); /* bailed out before */
		case IS_REFERENCE:
			container = Z_REFVAL_P(container);
			goto container_again;
			break;
		default:

			break;
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && Z_TYPE_P(container) == IS_STR_OFFSET) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
	}
	offset = opline->op2.zv;

	ZVAL_DEREF(container);
	if (Z_TYPE_P(container) == IS_OBJECT) {
		if (Z_OBJ_HT_P(container)->unset_property) {
			Z_OBJ_HT_P(container)->unset_property(container, offset, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
		} else {
			zend_error(E_NOTICE, "Trying to unset property of non-object");
		}
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_UNDEF) {
			value = EX_VAR(opline->op1.var);
			ZVAL_DEREF(value);
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_DUP(&tmp, varname);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_CONST != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_CONST == IS_CONST) {
				if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
					ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				} else {
					ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op2.var));
			}
			value = zend_std_get_static_property(ce, Z_STR_P(varname), 1, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if ((value = zend_hash_find(target_symbol_table, Z_STR_P(varname))) == NULL) {
				isset = 0;
			}
		}

		if (IS_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_ptr_dtor_nogc(free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_P(value) != IS_NULL) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(value TSRMLS_CC)) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	int result;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = opline->op2.zv;

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht = Z_ARRVAL_P(container);
		zval *value = NULL;
		zend_string *str;

isset_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				value = zend_hash_index_find(ht, hval);
				break;
			case IS_STRING:
				str = Z_STR_P(offset);
				if (IS_CONST != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(str->val, str->len+1, hval, goto num_index_prop);
				}
str_index_prop:
				value = zend_hash_find_ind(ht, str);
				break;
			case IS_NULL:
				str = STR_EMPTY_ALLOC();
				goto str_index_prop;
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto isset_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = (value != NULL && Z_TYPE_P(value) > IS_NULL);
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			result = (value == NULL || !i_zend_is_true(value TSRMLS_CC));
		}
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISSET) == 0, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISSET) == 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		result = 0;
		if (UNEXPECTED(Z_TYPE_P(offset) != IS_LONG)) {
			if (Z_TYPE_P(offset) < IS_STRING /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_DUP(&tmp, offset);
				convert_to_long(&tmp);
				offset = &tmp;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
				if ((opline->extended_value & ZEND_ISSET) ||
				    Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else {
		result = ((opline->extended_value & ZEND_ISSET) == 0);
	}

	ZVAL_BOOL(EX_VAR(opline->result.var), result);
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CONST(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_VAR_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

				if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));
				zval_ptr_dtor_nogc(free_op1.var);
			} else {
				if (IS_VAR == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_CONST == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_CONST == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_op_data1;
	zval *object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value;
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_dtor(free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		zval_dtor(free_op2.var);
		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_VAR_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_TMP_VAR TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:
	zval_dtor(free_op2.var);
	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_VAR_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:
	zval_dtor(free_op2.var);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_TMP(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_TMP(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_TMP(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_TMP(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_TMP(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_TMP(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_TMP(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_TMP(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_TMP(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_TMP(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_TMP(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_TMP(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_TMP(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_TMP(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_TMP(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_TMP(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_TMP(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_TMP(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_TMP(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_TMP(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_TMP(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_TMP(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_TMP(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_VAR_TMP(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(retval);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(zptr);
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(retval, zptr);
			}
		}
	}

	if (!have_get_ptr) {
		zval rv;

		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(z);
			incdec_op(z);
			ZVAL_COPY_VALUE(retval, z);
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(retval, opline);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(retval);
			}
		}
	}

	zval_dtor(free_op2.var);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_TMP(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_TMP(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_VAR_TMP(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		ZVAL_NULL(retval);
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_DUP(retval, zptr);

			incdec_op(zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval rv;
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
			zval z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			ZVAL_DUP(retval, z);
			ZVAL_DUP(&z_copy, z);
			incdec_op(&z_copy);
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, &z_copy, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	zval_dtor(free_op2.var);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_TMP(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_TMP(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_ptr_dtor_nogc(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (EXPECTED(opline->extended_value == 0)) {
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	} else {
		zend_fetch_dimension_address_W_ref(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	}
	zval_dtor(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_RW(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read_IS(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	zval_dtor(free_op2.var);
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}
		zval_dtor(free_op2.var);
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	} else {
		if (IS_TMP_VAR == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
		zval_dtor(free_op2.var);
		zval_ptr_dtor_nogc(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_UNSET(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_VAR_TMP(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_dtor(free_op2.var);
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_VAR_TMP(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, (opline->extended_value & ZEND_FETCH_MAKE_REF) != 0 TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_RW, 0 TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_dtor(free_op2.var);
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;

		SAVE_OPLINE();
		property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, 0 TSRMLS_CC);
		zval_dtor(free_op2.var);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_VAR_TMP(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container, *property, *retval_ptr;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_UNSET, 0 TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *object;
	zval *property_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (UNEXPECTED(Z_ISREF_P(object_ptr)) && Z_TYPE_P(Z_REFVAL_P(object_ptr)) == IS_OBJECT) {
		object_ptr = Z_REFVAL_P(object_ptr);
	}
	if (Z_TYPE_P(object_ptr) == IS_OBJECT) {
		zend_free_op free_op2;
		zval *property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);
		zval_dtor(free_op2.var);
	} else {
		zend_free_op free_op2, free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		zval *variable_ptr;

		zend_fetch_dimension_address_W(EX_VAR((opline+1)->op2.var), object_ptr, dim, IS_TMP_VAR TSRMLS_CC);
		zval_dtor(free_op2.var);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
			zend_assign_to_string_offset(variable_ptr, value, (opline+1)->op1_type, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
		} else if (UNEXPECTED(variable_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
			FREE_OP_VAR_PTR(free_op_data2);
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(EX_VAR(opline->result.var), value);
			}
			FREE_OP_VAR_PTR(free_op_data2);
		}
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
		zend_assign_to_string_offset(variable_ptr, value, IS_TMP_VAR, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
	} else if (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr == &EG(error_zval))) {
		if (1) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		if (IS_TMP_VAR == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
		} else if (IS_TMP_VAR == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_free_op free_op1, free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_TMP_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_TMP_VAR == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_dtor(free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_dtor(free_op2.var);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
			ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
		} else {
			ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), ce);
		}
		call->called_scope = ce;
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_TMP_VAR == IS_CONST &&
	    CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
		call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
	} else if (IS_VAR != IS_CONST &&
	           IS_TMP_VAR == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce))) {
		/* do nothing */
	} else if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;

		function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		if (IS_TMP_VAR != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
 			}
		}

		if (ce->get_static_method) {
			call->fbc = ce->get_static_method(ce, Z_STR_P(function_name) TSRMLS_CC);
		} else {
			call->fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_TMP_VAR == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
		}
		if (UNEXPECTED(call->fbc == NULL)) {
			zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name->val, Z_STRVAL_P(function_name));
		}
		if (IS_TMP_VAR == IS_CONST &&
		    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
		    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
			if (IS_VAR == IS_CONST) {
				CACHE_PTR(Z_CACHE_SLOT_P(function_name), call->fbc);
			} else {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), ce, call->fbc);
			}
		}
		if (IS_TMP_VAR != IS_CONST) {
			zval_dtor(free_op2.var);
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (Z_OBJ(EG(This)) && Z_OBJCE(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name->val);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (Z_OBJ(EG(This)) &&
		    Z_OBJ_HT(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			}
		}
		call->object = Z_OBJ(EG(This));
		if (call->object) {
			GC_REFCOUNT(call->object)++;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_VAR == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;
			zval_ptr_dtor_nogc(free_op1.var);
		} else if (IS_VAR == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_TMP_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}
		zval_dtor(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR != IS_UNUSED) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

container_again:
	switch (Z_TYPE_P(container)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(container);
offset_again:
			switch (Z_TYPE_P(offset)) {
				case IS_DOUBLE:
					hval = zend_dval_to_lval(Z_DVAL_P(offset));
					zend_hash_index_del(ht, hval);
					break;
				case IS_RESOURCE:
				case IS_BOOL:
				case IS_LONG:
					hval = Z_LVAL_P(offset);
					zend_hash_index_del(ht, hval);
					break;
				case IS_STRING:
					if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
						if (Z_REFCOUNTED_P(offset)) Z_ADDREF_P(offset);
					}
					if (IS_TMP_VAR != IS_CONST) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
					}
					if (ht == &EG(symbol_table).ht) {
						zend_delete_global_variable(Z_STR_P(offset) TSRMLS_CC);
					} else {
						zend_hash_del(ht, Z_STR_P(offset));
					}
					if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
num_index_dim:
					zend_hash_index_del(ht, hval);
					if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
				case IS_NULL:
					zend_hash_del(ht, STR_EMPTY_ALLOC());
					break;
				case IS_REFERENCE:
					offset = Z_REFVAL_P(offset);
					goto offset_again;
					break;
				default:
					zend_error(E_WARNING, "Illegal offset type in unset");
					break;
			}
			zval_dtor(free_op2.var);
			break;
		}
		case IS_OBJECT:
			if (UNEXPECTED(Z_OBJ_HT_P(container)->unset_dimension == NULL)) {
				zend_error_noreturn(E_ERROR, "Cannot use object as array");
			}
//???			if (IS_TMP_VAR == IS_CONST) {
//???				zval_copy_ctor(offset);
//???			}
			Z_OBJ_HT_P(container)->unset_dimension(container, offset TSRMLS_CC);
			zval_dtor(free_op2.var);
			break;
		case IS_STRING:
		case IS_STR_OFFSET:
			zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
			ZEND_VM_CONTINUE(); /* bailed out before */
		case IS_REFERENCE:
			container = Z_REFVAL_P(container);
			goto container_again;
			break;
		default:
			zval_dtor(free_op2.var);
			break;
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && Z_TYPE_P(container) == IS_STR_OFFSET) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
	}
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	ZVAL_DEREF(container);
	if (Z_TYPE_P(container) == IS_OBJECT) {
		if (Z_OBJ_HT_P(container)->unset_property) {
			Z_OBJ_HT_P(container)->unset_property(container, offset, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
		} else {
			zend_error(E_NOTICE, "Trying to unset property of non-object");
		}
	}
	zval_dtor(free_op2.var);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;
	int result;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht = Z_ARRVAL_P(container);
		zval *value = NULL;
		zend_string *str;

isset_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				value = zend_hash_index_find(ht, hval);
				break;
			case IS_STRING:
				str = Z_STR_P(offset);
				if (IS_TMP_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(str->val, str->len+1, hval, goto num_index_prop);
				}
str_index_prop:
				value = zend_hash_find_ind(ht, str);
				break;
			case IS_NULL:
				str = STR_EMPTY_ALLOC();
				goto str_index_prop;
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto isset_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = (value != NULL && Z_TYPE_P(value) > IS_NULL);
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			result = (value == NULL || !i_zend_is_true(value TSRMLS_CC));
		}
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISSET) == 0, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISSET) == 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		result = 0;
		if (UNEXPECTED(Z_TYPE_P(offset) != IS_LONG)) {
			if (Z_TYPE_P(offset) < IS_STRING /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_DUP(&tmp, offset);
				convert_to_long(&tmp);
				offset = &tmp;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
				if ((opline->extended_value & ZEND_ISSET) ||
				    Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else {
		result = ((opline->extended_value & ZEND_ISSET) == 0);
	}

	zval_dtor(free_op2.var);
	ZVAL_BOOL(EX_VAR(opline->result.var), result);
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_TMP(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_VAR_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

				if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));
				zval_ptr_dtor_nogc(free_op1.var);
			} else {
				if (IS_VAR == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_TMP_VAR == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_TMP_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);
	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_op_data1;
	zval *object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value;
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_ptr_dtor_nogc(free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		zval_ptr_dtor_nogc(free_op2.var);
		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_VAR_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2, free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_VAR TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:
	zval_ptr_dtor_nogc(free_op2.var);
	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_VAR_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:
	zval_ptr_dtor_nogc(free_op2.var);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_VAR(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_VAR(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_VAR(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_VAR(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_VAR(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_VAR(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_VAR(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_VAR(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_VAR(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_VAR(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_VAR(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_VAR(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_VAR(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_VAR(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_VAR(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_VAR(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_VAR(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_VAR(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_VAR(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_VAR(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_VAR(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_VAR(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_VAR(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_VAR_VAR(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_ptr_dtor_nogc(free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(retval);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(zptr);
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(retval, zptr);
			}
		}
	}

	if (!have_get_ptr) {
		zval rv;

		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(z);
			incdec_op(z);
			ZVAL_COPY_VALUE(retval, z);
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(retval, opline);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(retval);
			}
		}
	}

	zval_ptr_dtor_nogc(free_op2.var);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_VAR(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_VAR(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_VAR_VAR(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_ptr_dtor_nogc(free_op2.var);
		ZVAL_NULL(retval);
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_DUP(retval, zptr);

			incdec_op(zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval rv;
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
			zval z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			ZVAL_DUP(retval, z);
			ZVAL_DUP(&z_copy, z);
			incdec_op(&z_copy);
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, &z_copy, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	zval_ptr_dtor_nogc(free_op2.var);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_VAR(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_VAR(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_VAR_VAR(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval *retval;
	zval tmp_varname;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_UNDEF(&tmp_varname);
 	if (IS_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_DUP_DEREF(&tmp_varname, varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_VAR != IS_CONST) {
						zval_dtor(&tmp_varname);
					}
					zval_ptr_dtor_nogc(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		retval = zend_std_get_static_property(ce, Z_STR_P(varname), 0, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		retval = zend_hash_find(target_symbol_table, Z_STR_P(varname));
		if (retval == NULL) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = EX_VAR(opline->result.var);
					ZVAL_NULL(retval);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					retval = zend_hash_update(target_symbol_table, Z_STR_P(varname), &EG(uninitialized_zval));
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
		} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
			retval = Z_INDIRECT_P(retval);
			if (Z_TYPE_P(retval) == IS_UNDEF) {
				switch (type) {
					case BP_VAR_R:
					case BP_VAR_UNSET:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_IS:
						retval = EX_VAR(opline->result.var);
						ZVAL_NULL(retval);
						break;
					case BP_VAR_RW:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_W:
						ZVAL_NULL(retval);
						break;
					EMPTY_SWITCH_DEFAULT_CASE()
				}
			}
		}
		if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) == ZEND_FETCH_STATIC) {
			zval_update_constant(retval, (void*) 1 TSRMLS_CC);
		} else if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) != ZEND_FETCH_GLOBAL_LOCK) {
			zval_ptr_dtor_nogc(free_op1.var);
		}
	}

	if (IS_VAR != IS_CONST) {
		zval_dtor(&tmp_varname);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY(EX_VAR(opline->result.var), retval);
	} else {
		if (/*type == BP_VAR_W &&*/ (opline->extended_value & ZEND_FETCH_MAKE_REF)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
		}
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_VAR(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_VAR(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_VAR(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		return zend_fetch_var_address_helper_SPEC_VAR_VAR(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		return zend_fetch_var_address_helper_SPEC_VAR_VAR(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_VAR(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_VAR(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_ptr_dtor_nogc(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (EXPECTED(opline->extended_value == 0)) {
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	} else {
		zend_fetch_dimension_address_W_ref(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	}
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_RW(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read_IS(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}
		zval_ptr_dtor_nogc(free_op2.var);
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	} else {
		if (IS_VAR == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op2.var);
		zval_ptr_dtor_nogc(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_UNSET(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_VAR_VAR(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_ptr_dtor_nogc(free_op2.var);
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_VAR_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, (opline->extended_value & ZEND_FETCH_MAKE_REF) != 0 TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_RW, 0 TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_ptr_dtor_nogc(free_op2.var);
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;

		SAVE_OPLINE();
		property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, 0 TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op2.var);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_VAR_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container, *property, *retval_ptr;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_UNSET, 0 TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *object;
	zval *property_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (UNEXPECTED(Z_ISREF_P(object_ptr)) && Z_TYPE_P(Z_REFVAL_P(object_ptr)) == IS_OBJECT) {
		object_ptr = Z_REFVAL_P(object_ptr);
	}
	if (Z_TYPE_P(object_ptr) == IS_OBJECT) {
		zend_free_op free_op2;
		zval *property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op2.var);
	} else {
		zend_free_op free_op2, free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		zval *variable_ptr;

		zend_fetch_dimension_address_W(EX_VAR((opline+1)->op2.var), object_ptr, dim, IS_VAR TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op2.var);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
			zend_assign_to_string_offset(variable_ptr, value, (opline+1)->op1_type, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
		} else if (UNEXPECTED(variable_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
			FREE_OP_VAR_PTR(free_op_data2);
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(EX_VAR(opline->result.var), value);
			}
			FREE_OP_VAR_PTR(free_op_data2);
		}
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
		zend_assign_to_string_offset(variable_ptr, value, IS_VAR, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
	} else if (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		if (IS_VAR == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
		} else if (IS_VAR == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */
 	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *variable_ptr;
	zval *value_ptr;

	SAVE_OPLINE();
	value_ptr = _get_zval_ptr_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_VAR &&
	    opline->extended_value == ZEND_RETURNS_FUNCTION &&
	    !(Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF) &&
	    !Z_ISREF_P(value_ptr)) {
		if (!(free_op2.var != NULL)) {
			PZVAL_LOCK(value_ptr); /* undo the effect of get_zval_ptr_ptr() */
		}
		zend_error(E_STRICT, "Only variables should be assigned by reference");
		if (UNEXPECTED(EG(exception) != NULL)) {
			if (free_op2.var) {zval_ptr_dtor_nogc(free_op2.var);};
			HANDLE_EXCEPTION();
		}
		return ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		if (!(free_op2.var != NULL)) {
			PZVAL_LOCK(value_ptr);
		}
	}

	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR &&
	    UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT) &&
	    UNEXPECTED(!Z_ISREF_P(variable_ptr))) {
		zend_error_noreturn(E_ERROR, "Cannot assign by reference to overloaded object");
	}
	if ((IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) ||
	    (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET))) {
		zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets nor overloaded objects");
	}
	if ((IS_VAR == IS_VAR && UNEXPECTED(variable_ptr == &EG(error_zval))) ||
	    (IS_VAR == IS_VAR && UNEXPECTED(value_ptr == &EG(error_zval)))) {
		variable_ptr = &EG(uninitialized_zval);
	} else {
		zend_assign_to_variable_reference(variable_ptr, value_ptr TSRMLS_CC);
	}

	if (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		if (!(free_op2.var != NULL)) {
			Z_DELREF_P(variable_ptr);
		}
	}

	if (RETURN_VALUE_USED(opline)) {
		ZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	if (free_op2.var) {zval_ptr_dtor_nogc(free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_free_op free_op1, free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_VAR == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor_nogc(free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_ptr_dtor_nogc(free_op2.var);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
			ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
		} else {
			ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), ce);
		}
		call->called_scope = ce;
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_VAR == IS_CONST &&
	    CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
		call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
	} else if (IS_VAR != IS_CONST &&
	           IS_VAR == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce))) {
		/* do nothing */
	} else if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;

		function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		if (IS_VAR != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
 			}
		}

		if (ce->get_static_method) {
			call->fbc = ce->get_static_method(ce, Z_STR_P(function_name) TSRMLS_CC);
		} else {
			call->fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_VAR == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
		}
		if (UNEXPECTED(call->fbc == NULL)) {
			zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name->val, Z_STRVAL_P(function_name));
		}
		if (IS_VAR == IS_CONST &&
		    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
		    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
			if (IS_VAR == IS_CONST) {
				CACHE_PTR(Z_CACHE_SLOT_P(function_name), call->fbc);
			} else {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), ce, call->fbc);
			}
		}
		if (IS_VAR != IS_CONST) {
			zval_ptr_dtor_nogc(free_op2.var);
		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (Z_OBJ(EG(This)) && Z_OBJCE(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name->val);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (Z_OBJ(EG(This)) &&
		    Z_OBJ_HT(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			}
		}
		call->object = Z_OBJ(EG(This));
		if (call->object) {
			GC_REFCOUNT(call->object)++;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_VAR == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;
			zval_ptr_dtor_nogc(free_op1.var);
		} else if (IS_VAR == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}
		zval_ptr_dtor_nogc(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;
	zend_bool tmp_is_dup = 0;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
	    ZVAL_COPY_VALUE(&tmp, EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->op1.var));
		zval_ptr_dtor(&tmp);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_DUP(&tmp, varname);
		convert_to_string(&tmp);
		varname = &tmp;
		tmp_is_dup = 1;
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		ZVAL_COPY(&tmp, varname);
		varname = &tmp;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_VAR != IS_CONST && tmp_is_dup) {
						zval_dtor(&tmp);
					} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
						zval_ptr_dtor(&tmp);
					}
					zval_ptr_dtor_nogc(free_op1.var);
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		zend_std_unset_static_property(ce, Z_STR_P(varname), ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_hash_del_ind(target_symbol_table, Z_STR_P(varname));
	}

	if (IS_VAR != IS_CONST && tmp_is_dup) {
		zval_dtor(&tmp);
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		zval_ptr_dtor(&tmp);
	}
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR != IS_UNUSED) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

container_again:
	switch (Z_TYPE_P(container)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(container);
offset_again:
			switch (Z_TYPE_P(offset)) {
				case IS_DOUBLE:
					hval = zend_dval_to_lval(Z_DVAL_P(offset));
					zend_hash_index_del(ht, hval);
					break;
				case IS_RESOURCE:
				case IS_BOOL:
				case IS_LONG:
					hval = Z_LVAL_P(offset);
					zend_hash_index_del(ht, hval);
					break;
				case IS_STRING:
					if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
						if (Z_REFCOUNTED_P(offset)) Z_ADDREF_P(offset);
					}
					if (IS_VAR != IS_CONST) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
					}
					if (ht == &EG(symbol_table).ht) {
						zend_delete_global_variable(Z_STR_P(offset) TSRMLS_CC);
					} else {
						zend_hash_del(ht, Z_STR_P(offset));
					}
					if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
num_index_dim:
					zend_hash_index_del(ht, hval);
					if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
				case IS_NULL:
					zend_hash_del(ht, STR_EMPTY_ALLOC());
					break;
				case IS_REFERENCE:
					offset = Z_REFVAL_P(offset);
					goto offset_again;
					break;
				default:
					zend_error(E_WARNING, "Illegal offset type in unset");
					break;
			}
			zval_ptr_dtor_nogc(free_op2.var);
			break;
		}
		case IS_OBJECT:
			if (UNEXPECTED(Z_OBJ_HT_P(container)->unset_dimension == NULL)) {
				zend_error_noreturn(E_ERROR, "Cannot use object as array");
			}
//???			if (IS_VAR == IS_CONST) {
//???				zval_copy_ctor(offset);
//???			}
			Z_OBJ_HT_P(container)->unset_dimension(container, offset TSRMLS_CC);
			zval_ptr_dtor_nogc(free_op2.var);
			break;
		case IS_STRING:
		case IS_STR_OFFSET:
			zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
			ZEND_VM_CONTINUE(); /* bailed out before */
		case IS_REFERENCE:
			container = Z_REFVAL_P(container);
			goto container_again;
			break;
		default:
			zval_ptr_dtor_nogc(free_op2.var);
			break;
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && Z_TYPE_P(container) == IS_STR_OFFSET) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
	}
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	ZVAL_DEREF(container);
	if (Z_TYPE_P(container) == IS_OBJECT) {
		if (Z_OBJ_HT_P(container)->unset_property) {
			Z_OBJ_HT_P(container)->unset_property(container, offset, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
		} else {
			zend_error(E_NOTICE, "Trying to unset property of non-object");
		}
	}
	zval_ptr_dtor_nogc(free_op2.var);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_UNDEF) {
			value = EX_VAR(opline->op1.var);
			ZVAL_DEREF(value);
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_DUP(&tmp, varname);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_VAR != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_VAR == IS_CONST) {
				if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
					ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				} else {
					ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op2.var));
			}
			value = zend_std_get_static_property(ce, Z_STR_P(varname), 1, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if ((value = zend_hash_find(target_symbol_table, Z_STR_P(varname))) == NULL) {
				isset = 0;
			}
		}

		if (IS_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_ptr_dtor_nogc(free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_P(value) != IS_NULL) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(value TSRMLS_CC)) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;
	int result;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht = Z_ARRVAL_P(container);
		zval *value = NULL;
		zend_string *str;

isset_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				value = zend_hash_index_find(ht, hval);
				break;
			case IS_STRING:
				str = Z_STR_P(offset);
				if (IS_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(str->val, str->len+1, hval, goto num_index_prop);
				}
str_index_prop:
				value = zend_hash_find_ind(ht, str);
				break;
			case IS_NULL:
				str = STR_EMPTY_ALLOC();
				goto str_index_prop;
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto isset_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = (value != NULL && Z_TYPE_P(value) > IS_NULL);
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			result = (value == NULL || !i_zend_is_true(value TSRMLS_CC));
		}
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISSET) == 0, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISSET) == 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		result = 0;
		if (UNEXPECTED(Z_TYPE_P(offset) != IS_LONG)) {
			if (Z_TYPE_P(offset) < IS_STRING /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_DUP(&tmp, offset);
				convert_to_long(&tmp);
				offset = &tmp;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
				if ((opline->extended_value & ZEND_ISSET) ||
				    Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else {
		result = ((opline->extended_value & ZEND_ISSET) == 0);
	}

	zval_ptr_dtor_nogc(free_op2.var);
	ZVAL_BOOL(EX_VAR(opline->result.var), result);
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_VAR(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_VAR_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

				if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));
				zval_ptr_dtor_nogc(free_op1.var);
			} else {
				if (IS_VAR == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_VAR == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));
			zval_ptr_dtor_nogc(free_op2.var);
		} else {
			if (IS_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data1;
	zval *object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *property = NULL;
	zval *value;
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_UNUSED == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_UNUSED == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_UNUSED == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = NULL;

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_UNUSED TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:

	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_VAR_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = NULL;
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_UNUSED(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_UNUSED(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_UNUSED(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_VAR_UNUSED(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *varname;
	zval *retval;
	zval tmp_varname;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	ZVAL_UNDEF(&tmp_varname);
 	if (IS_VAR != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_DUP_DEREF(&tmp_varname, varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_VAR != IS_CONST) {
						zval_dtor(&tmp_varname);
					}
					zval_ptr_dtor_nogc(free_op1.var);
					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		retval = zend_std_get_static_property(ce, Z_STR_P(varname), 0, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op1.var);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		retval = zend_hash_find(target_symbol_table, Z_STR_P(varname));
		if (retval == NULL) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = EX_VAR(opline->result.var);
					ZVAL_NULL(retval);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					retval = zend_hash_update(target_symbol_table, Z_STR_P(varname), &EG(uninitialized_zval));
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
		} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
			retval = Z_INDIRECT_P(retval);
			if (Z_TYPE_P(retval) == IS_UNDEF) {
				switch (type) {
					case BP_VAR_R:
					case BP_VAR_UNSET:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_IS:
						retval = EX_VAR(opline->result.var);
						ZVAL_NULL(retval);
						break;
					case BP_VAR_RW:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_W:
						ZVAL_NULL(retval);
						break;
					EMPTY_SWITCH_DEFAULT_CASE()
				}
			}
		}
		if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) == ZEND_FETCH_STATIC) {
			zval_update_constant(retval, (void*) 1 TSRMLS_CC);
		} else if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) != ZEND_FETCH_GLOBAL_LOCK) {
			zval_ptr_dtor_nogc(free_op1.var);
		}
	}

	if (IS_VAR != IS_CONST) {
		zval_dtor(&tmp_varname);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY(EX_VAR(opline->result.var), retval);
	} else {
		if (/*type == BP_VAR_W &&*/ (opline->extended_value & ZEND_FETCH_MAKE_REF)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
		}
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_VAR_UNUSED(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (EXPECTED(opline->extended_value == 0)) {
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, NULL, IS_UNUSED TSRMLS_CC);
	} else {
		zend_fetch_dimension_address_W_ref(EX_VAR(opline->result.var), container, NULL, IS_UNUSED TSRMLS_CC);
	}

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_RW(EX_VAR(opline->result.var), container, NULL, IS_UNUSED TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zend_free_op free_op1;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, NULL, IS_UNUSED TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}

		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	} else {
		if (IS_UNUSED == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, NULL, IS_UNUSED TSRMLS_CC);

		zval_ptr_dtor_nogc(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (UNEXPECTED(Z_ISREF_P(object_ptr)) && Z_TYPE_P(Z_REFVAL_P(object_ptr)) == IS_OBJECT) {
		object_ptr = Z_REFVAL_P(object_ptr);
	}
	if (Z_TYPE_P(object_ptr) == IS_OBJECT) {

		zval *property_name = NULL;

		zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_UNUSED == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);

	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = NULL;
		zval *variable_ptr;

		zend_fetch_dimension_address_W(EX_VAR((opline+1)->op2.var), object_ptr, dim, IS_UNUSED TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
			zend_assign_to_string_offset(variable_ptr, value, (opline+1)->op1_type, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
		} else if (UNEXPECTED(variable_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
			FREE_OP_VAR_PTR(free_op_data2);
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(EX_VAR(opline->result.var), value);
			}
			FREE_OP_VAR_PTR(free_op_data2);
		}
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
			ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
		} else {
			ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), ce);
		}
		call->called_scope = ce;
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_UNUSED == IS_CONST &&
	    CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
		call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
	} else if (IS_VAR != IS_CONST &&
	           IS_UNUSED == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce))) {
		/* do nothing */
	} else if (IS_UNUSED != IS_UNUSED) {


		function_name = NULL;
		if (IS_UNUSED != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
 			}
		}

		if (ce->get_static_method) {
			call->fbc = ce->get_static_method(ce, Z_STR_P(function_name) TSRMLS_CC);
		} else {
			call->fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_UNUSED == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
		}
		if (UNEXPECTED(call->fbc == NULL)) {
			zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name->val, Z_STRVAL_P(function_name));
		}
		if (IS_UNUSED == IS_CONST &&
		    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
		    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
			if (IS_VAR == IS_CONST) {
				CACHE_PTR(Z_CACHE_SLOT_P(function_name), call->fbc);
			} else {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), ce, call->fbc);
			}
		}
		if (IS_UNUSED != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (Z_OBJ(EG(This)) && Z_OBJCE(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name->val);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (Z_OBJ(EG(This)) &&
		    Z_OBJ_HT(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			}
		}
		call->object = Z_OBJ(EG(This));
		if (call->object) {
			GC_REFCOUNT(call->object)++;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_VAR == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;
			zval_ptr_dtor_nogc(free_op1.var);
		} else if (IS_VAR == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_UNUSED != IS_UNUSED) {

		zval *offset = NULL;
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_UNUSED != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;
	zend_free_op free_op1;
	zend_bool tmp_is_dup = 0;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
	    ZVAL_COPY_VALUE(&tmp, EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->op1.var));
		zval_ptr_dtor(&tmp);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_DUP(&tmp, varname);
		convert_to_string(&tmp);
		varname = &tmp;
		tmp_is_dup = 1;
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		ZVAL_COPY(&tmp, varname);
		varname = &tmp;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_VAR != IS_CONST && tmp_is_dup) {
						zval_dtor(&tmp);
					} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
						zval_ptr_dtor(&tmp);
					}
					zval_ptr_dtor_nogc(free_op1.var);
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		zend_std_unset_static_property(ce, Z_STR_P(varname), ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_hash_del_ind(target_symbol_table, Z_STR_P(varname));
	}

	if (IS_VAR != IS_CONST && tmp_is_dup) {
		zval_dtor(&tmp);
	} else if (IS_VAR == IS_VAR || IS_VAR == IS_CV) {
		zval_ptr_dtor(&tmp);
	}
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_VAR == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_UNDEF) {
			value = EX_VAR(opline->op1.var);
			ZVAL_DEREF(value);
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;
		zend_free_op free_op1;
		zval tmp, *varname = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_DUP(&tmp, varname);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_UNUSED != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_UNUSED == IS_CONST) {
				if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
					ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				} else {
					ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op2.var));
			}
			value = zend_std_get_static_property(ce, Z_STR_P(varname), 1, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if ((value = zend_hash_find(target_symbol_table, Z_STR_P(varname))) == NULL) {
				isset = 0;
			}
		}

		if (IS_VAR != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}
		zval_ptr_dtor_nogc(free_op1.var);
	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_P(value) != IS_NULL) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(value TSRMLS_CC)) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *var_ptr;

	SAVE_OPLINE();
	var_ptr = EX_VAR(opline->op1.var);
	if (Z_TYPE_P(var_ptr) != IS_OBJECT &&
	    !Z_ISREF_P(var_ptr) &&
	    Z_REFCOUNTED_P(var_ptr) &&
	    Z_REFCOUNT_P(var_ptr) > 1) {

		Z_DELREF_P(var_ptr);
		ZVAL_DUP(EX_VAR(opline->op1.var), var_ptr);
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_VAR_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

				if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));
				zval_ptr_dtor_nogc(free_op1.var);
			} else {
				if (IS_VAR == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_UNUSED == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_UNUSED == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;

	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_VAR_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data1;
	zval *object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zval *property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	zval *value;
	int have_get_ptr = 0;

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		FREE_OP(free_op_data1);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_VAR_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_VAR == IS_VAR && !(free_op1.var != NULL)) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_CV TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:

	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_VAR_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	var_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_VAR == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CV(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CV(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CV(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CV(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CV(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CV(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CV(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CV(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CV(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CV(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CV(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CV(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CV(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CV(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CV(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CV(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CV(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CV(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CV(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CV(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_VAR_CV(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_VAR_CV(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_VAR_CV(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_VAR_CV(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(retval);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(zptr);
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(retval, zptr);
			}
		}
	}

	if (!have_get_ptr) {
		zval rv;

		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(z);
			incdec_op(z);
			ZVAL_COPY_VALUE(retval, z);
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(retval, opline);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(retval);
			}
		}
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_CV(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_VAR_CV(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_VAR_CV(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_DUP(retval, zptr);

			incdec_op(zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval rv;
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
			zval z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			ZVAL_DUP(retval, z);
			ZVAL_DUP(&z_copy, z);
			incdec_op(&z_copy);
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, &z_copy, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_CV(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_VAR_CV(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);

	if (IS_VAR != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {
		zval_ptr_dtor_nogc(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (EXPECTED(opline->extended_value == 0)) {
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);
	} else {
		zend_fetch_dimension_address_W_ref(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);
	}

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_RW(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	zend_fetch_dimension_address_read_IS(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zend_free_op free_op1;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);
		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}

		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	} else {
		if (IS_CV == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);

		zval_ptr_dtor_nogc(free_op1.var);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_UNSET(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_VAR_CV(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_VAR_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, (opline->extended_value & ZEND_FETCH_MAKE_REF) != 0 TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_RW, 0 TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;

		SAVE_OPLINE();
		property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

		if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, 0 TSRMLS_CC);

		if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_VAR_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container, *property, *retval_ptr;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_UNSET, 0 TSRMLS_CC);

	if (IS_VAR == IS_VAR && (free_op1.var != NULL) && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *object;
	zval *property_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(object_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (UNEXPECTED(Z_ISREF_P(object_ptr)) && Z_TYPE_P(Z_REFVAL_P(object_ptr)) == IS_OBJECT) {
		object_ptr = Z_REFVAL_P(object_ptr);
	}
	if (Z_TYPE_P(object_ptr) == IS_OBJECT) {

		zval *property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);

	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		zval *variable_ptr;

		zend_fetch_dimension_address_W(EX_VAR((opline+1)->op2.var), object_ptr, dim, IS_CV TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
			zend_assign_to_string_offset(variable_ptr, value, (opline+1)->op1_type, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
		} else if (UNEXPECTED(variable_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
			FREE_OP_VAR_PTR(free_op_data2);
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(EX_VAR(opline->result.var), value);
			}
			FREE_OP_VAR_PTR(free_op_data2);
		}
	 	FREE_OP_IF_VAR(free_op_data1);
	}
 	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

	if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
		zend_assign_to_string_offset(variable_ptr, value, IS_CV, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
	} else if (IS_VAR == IS_VAR && UNEXPECTED(variable_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		if (IS_CV == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
		} else if (IS_CV == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *variable_ptr;
	zval *value_ptr;

	SAVE_OPLINE();
	value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV == IS_VAR &&
	    opline->extended_value == ZEND_RETURNS_FUNCTION &&
	    !(Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF) &&
	    !Z_ISREF_P(value_ptr)) {
		if (!0) {
			PZVAL_LOCK(value_ptr); /* undo the effect of get_zval_ptr_ptr() */
		}
		zend_error(E_STRICT, "Only variables should be assigned by reference");
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		return ZEND_ASSIGN_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		if (!0) {
			PZVAL_LOCK(value_ptr);
		}
	}

	variable_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR &&
	    UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT) &&
	    UNEXPECTED(!Z_ISREF_P(variable_ptr))) {
		zend_error_noreturn(E_ERROR, "Cannot assign by reference to overloaded object");
	}
	if ((IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) ||
	    (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET))) {
		zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets nor overloaded objects");
	}
	if ((IS_VAR == IS_VAR && UNEXPECTED(variable_ptr == &EG(error_zval))) ||
	    (IS_CV == IS_VAR && UNEXPECTED(value_ptr == &EG(error_zval)))) {
		variable_ptr = &EG(uninitialized_zval);
	} else {
		zend_assign_to_variable_reference(variable_ptr, value_ptr TSRMLS_CC);
	}

	if (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		if (!0) {
			Z_DELREF_P(variable_ptr);
		}
	}

	if (RETURN_VALUE_USED(opline)) {
		ZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_free_op free_op1;
	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_CV != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_CV == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_ptr_dtor_nogc(free_op1.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_class_entry *ce;
	call_slot *call = EX(call_slots) + opline->result.num;

	SAVE_OPLINE();

	if (IS_VAR == IS_CONST) {
		/* no function found. try a static method in class */
		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
			ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
		} else {
			ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, opline->extended_value TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				HANDLE_EXCEPTION();
			}
			if (UNEXPECTED(ce == NULL)) {
				zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
			}
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), ce);
		}
		call->called_scope = ce;
	} else {
		ce = Z_CE_P(EX_VAR(opline->op1.var));

		if (opline->extended_value == ZEND_FETCH_CLASS_PARENT || opline->extended_value == ZEND_FETCH_CLASS_SELF) {
			call->called_scope = EG(called_scope);
		} else {
			call->called_scope = ce;
		}
	}

	if (IS_VAR == IS_CONST &&
	    IS_CV == IS_CONST &&
	    CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
		call->fbc = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
	} else if (IS_VAR != IS_CONST &&
	           IS_CV == IS_CONST &&
	           (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce))) {
		/* do nothing */
	} else if (IS_CV != IS_UNUSED) {


		function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		if (IS_CV != IS_CONST) {
			if (UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				zend_error_noreturn(E_ERROR, "Function name must be a string");
 			}
		}

		if (ce->get_static_method) {
			call->fbc = ce->get_static_method(ce, Z_STR_P(function_name) TSRMLS_CC);
		} else {
			call->fbc = zend_std_get_static_method(ce, Z_STR_P(function_name), ((IS_CV == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
		}
		if (UNEXPECTED(call->fbc == NULL)) {
			zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", ce->name->val, Z_STRVAL_P(function_name));
		}
		if (IS_CV == IS_CONST &&
		    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
		    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0)) {
			if (IS_VAR == IS_CONST) {
				CACHE_PTR(Z_CACHE_SLOT_P(function_name), call->fbc);
			} else {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), ce, call->fbc);
			}
		}
		if (IS_CV != IS_CONST) {

		}
	} else {
		if (UNEXPECTED(ce->constructor == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot call constructor");
		}
		if (Z_OBJ(EG(This)) && Z_OBJCE(EG(This)) != ce->constructor->common.scope && (ce->constructor->common.fn_flags & ZEND_ACC_PRIVATE)) {
			zend_error_noreturn(E_ERROR, "Cannot call private %s::__construct()", ce->name->val);
		}
		call->fbc = ce->constructor;
	}

	if (call->fbc->common.fn_flags & ZEND_ACC_STATIC) {
		call->object = NULL;
	} else {
		if (Z_OBJ(EG(This)) &&
		    Z_OBJ_HT(EG(This))->get_class_entry &&
		    !instanceof_function(Z_OBJCE(EG(This)), ce TSRMLS_CC)) {
		    /* We are calling method of the other (incompatible) class,
		       but passing $this. This is done for compatibility with php-4. */
			if (call->fbc->common.fn_flags & ZEND_ACC_ALLOW_STATIC) {
				zend_error(E_DEPRECATED, "Non-static method %s::%s() should not be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			} else {
				/* An internal function assumes $this is present and won't check that. So PHP would crash by allowing the call. */
				zend_error_noreturn(E_ERROR, "Non-static method %s::%s() cannot be called statically, assuming $this from incompatible context", call->fbc->common.scope->name->val, call->fbc->common.function_name->val);
			}
		}
		call->object = Z_OBJ(EG(This));
		if (call->object) {
			GC_REFCOUNT(call->object)++;
		}
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC),
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		expr_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_VAR == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;
			zval_ptr_dtor_nogc(free_op1.var);
		} else if (IS_VAR == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CV != IS_UNUSED) {

		zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_CV != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_VAR == IS_VAR || IS_VAR == IS_CV) && opline->extended_value) {
		if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_VAR == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_VAR != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR != IS_UNUSED) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

container_again:
	switch (Z_TYPE_P(container)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(container);
offset_again:
			switch (Z_TYPE_P(offset)) {
				case IS_DOUBLE:
					hval = zend_dval_to_lval(Z_DVAL_P(offset));
					zend_hash_index_del(ht, hval);
					break;
				case IS_RESOURCE:
				case IS_BOOL:
				case IS_LONG:
					hval = Z_LVAL_P(offset);
					zend_hash_index_del(ht, hval);
					break;
				case IS_STRING:
					if (IS_CV == IS_CV || IS_CV == IS_VAR) {
						if (Z_REFCOUNTED_P(offset)) Z_ADDREF_P(offset);
					}
					if (IS_CV != IS_CONST) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
					}
					if (ht == &EG(symbol_table).ht) {
						zend_delete_global_variable(Z_STR_P(offset) TSRMLS_CC);
					} else {
						zend_hash_del(ht, Z_STR_P(offset));
					}
					if (IS_CV == IS_CV || IS_CV == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
num_index_dim:
					zend_hash_index_del(ht, hval);
					if (IS_CV == IS_CV || IS_CV == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
				case IS_NULL:
					zend_hash_del(ht, STR_EMPTY_ALLOC());
					break;
				case IS_REFERENCE:
					offset = Z_REFVAL_P(offset);
					goto offset_again;
					break;
				default:
					zend_error(E_WARNING, "Illegal offset type in unset");
					break;
			}

			break;
		}
		case IS_OBJECT:
			if (UNEXPECTED(Z_OBJ_HT_P(container)->unset_dimension == NULL)) {
				zend_error_noreturn(E_ERROR, "Cannot use object as array");
			}
//???			if (IS_CV == IS_CONST) {
//???				zval_copy_ctor(offset);
//???			}
			Z_OBJ_HT_P(container)->unset_dimension(container, offset TSRMLS_CC);

			break;
		case IS_STRING:
		case IS_STR_OFFSET:
			zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
			ZEND_VM_CONTINUE(); /* bailed out before */
		case IS_REFERENCE:
			container = Z_REFVAL_P(container);
			goto container_again;
			break;
		default:

			break;
	}
	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	if (IS_VAR == IS_VAR && Z_TYPE_P(container) == IS_STR_OFFSET) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
	}
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	ZVAL_DEREF(container);
	if (Z_TYPE_P(container) == IS_OBJECT) {
		if (Z_OBJ_HT_P(container)->unset_property) {
			Z_OBJ_HT_P(container)->unset_property(container, offset, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
		} else {
			zend_error(E_NOTICE, "Trying to unset property of non-object");
		}
	}

	if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;
	int result;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_var_deref(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht = Z_ARRVAL_P(container);
		zval *value = NULL;
		zend_string *str;

isset_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				value = zend_hash_index_find(ht, hval);
				break;
			case IS_STRING:
				str = Z_STR_P(offset);
				if (IS_CV != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(str->val, str->len+1, hval, goto num_index_prop);
				}
str_index_prop:
				value = zend_hash_find_ind(ht, str);
				break;
			case IS_NULL:
				str = STR_EMPTY_ALLOC();
				goto str_index_prop;
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto isset_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = (value != NULL && Z_TYPE_P(value) > IS_NULL);
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			result = (value == NULL || !i_zend_is_true(value TSRMLS_CC));
		}
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISSET) == 0, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISSET) == 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		result = 0;
		if (UNEXPECTED(Z_TYPE_P(offset) != IS_LONG)) {
			if (Z_TYPE_P(offset) < IS_STRING /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_DUP(&tmp, offset);
				convert_to_long(&tmp);
				offset = &tmp;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
				if ((opline->extended_value & ZEND_ISSET) ||
				    Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else {
		result = ((opline->extended_value & ZEND_ISSET) == 0);
	}

	ZVAL_BOOL(EX_VAR(opline->result.var), result);
	zval_ptr_dtor_nogc(free_op1.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_VAR_CV(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_VAR_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op1;

		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_VAR == IS_CONST || IS_VAR == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = _get_zval_ptr_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

				if (IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_VAR == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

				if (free_op1.var) {zval_ptr_dtor_nogc(free_op1.var);};
			}
		} else {
			zval *value = _get_zval_ptr_var(opline->op1.var, execute_data, &free_op1 TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_VAR == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_VAR == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));
				zval_ptr_dtor_nogc(free_op1.var);
			} else {
				if (IS_VAR == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_CV == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_CV == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_CLONE_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (IS_UNUSED == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name->val);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name->val, EG(scope) ? EG(scope)->name->val : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name->val, EG(scope) ? EG(scope)->name->val : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		ZVAL_OBJ(EX_VAR(opline->result.var), clone_call(obj TSRMLS_CC));
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(EX_VAR(opline->result.var));
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_EXIT_SPEC_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0 || (IS_UNUSED != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_UNUSED != IS_UNUSED) {

		zval *ptr = NULL;

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}

	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval *object = _get_obj_zval_ptr_unused(TSRMLS_C);
	zval *property = opline->op2.zv;
	zval *value;
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_UNUSED == IS_VAR && !0) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = opline->op2.zv;

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_CONST TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:

	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);

	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_UNUSED_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = opline->op2.zv;
	var_ptr = NULL;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_UNUSED == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CONST(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CONST(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CONST(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_UNUSED_CONST(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	property = opline->op2.zv;
	retval = EX_VAR(opline->result.var);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(retval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(zptr);
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(retval, zptr);
			}
		}
	}

	if (!have_get_ptr) {
		zval rv;

		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(z);
			incdec_op(z);
			ZVAL_COPY_VALUE(retval, z);
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(retval, opline);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(retval);
			}
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_CONST(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_CONST(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_UNUSED_CONST(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	property = opline->op2.zv;
	retval = EX_VAR(opline->result.var);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_DUP(retval, zptr);

			incdec_op(zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval rv;
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
			zval z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			ZVAL_DUP(retval, z);
			ZVAL_DUP(&z_copy, z);
			incdec_op(&z_copy);
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, &z_copy, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_CONST(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_CONST(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = opline->op2.zv;

	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, (opline->extended_value & ZEND_FETCH_MAKE_REF) != 0 TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = opline->op2.zv;
	container = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_RW, 0 TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;

		SAVE_OPLINE();
		property = opline->op2.zv;
		container = _get_obj_zval_ptr_unused(TSRMLS_C);

		if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, 0 TSRMLS_CC);

		if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_UNUSED_CONST(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container, *property, *retval_ptr;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	property = opline->op2.zv;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_UNSET, 0 TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object;
	zval *property_name;

	SAVE_OPLINE();
	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	property_name = opline->op2.zv;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);


	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_CHAR_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *str = EX_VAR(opline->result.var);

	SAVE_OPLINE();

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_char_to_string */
		ZVAL_EMPTY_STRING(str);
	}

	add_char_to_string(str, str, opline->op2.zv);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_STRING_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *str = EX_VAR(opline->result.var);

	SAVE_OPLINE();

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		ZVAL_EMPTY_STRING(str);
	}

	add_string_to_string(str, str, opline->op2.zv);

	/* FREE_OP is missing intentionally here - we're always working on the same temporary variable */
	/*CHECK_EXCEPTION();*/
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;

	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = opline->op2.zv;

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_CONST != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_CONST == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_UNUSED == IS_UNUSED) {
		zend_constant *c;
		zval *retval;

		if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
			c = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
		} else if ((c = zend_quick_get_constant(opline->op2.zv + 1, opline->extended_value TSRMLS_CC)) == NULL) {
			if ((opline->extended_value & IS_CONSTANT_UNQUALIFIED) != 0) {
				char *actual = (char *)zend_memrchr(Z_STRVAL_P(opline->op2.zv), '\\', Z_STRLEN_P(opline->op2.zv));
				if(!actual) {
					actual = Z_STRVAL_P(opline->op2.zv);
				} else {
					actual++;
				}
				/* non-qualified constant - allow text substitution */
				zend_error(E_NOTICE, "Use of undefined constant %s - assumed '%s'", actual, actual);
				ZVAL_STRINGL(EX_VAR(opline->result.var), actual, Z_STRLEN_P(opline->op2.zv)-(actual - Z_STRVAL_P(opline->op2.zv)));
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else {
				zend_error_noreturn(E_ERROR, "Undefined constant '%s'", Z_STRVAL_P(opline->op2.zv));
			}
		} else {
			CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), c);
		}
		retval = EX_VAR(opline->result.var);
		ZVAL_DUP(retval, &c->value);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		/* class constant */
		zend_class_entry *ce;
		zval *value;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				value = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				ZVAL_DUP(EX_VAR(opline->result.var), value);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			} else if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op1.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op1.zv), opline->op1.zv + 1, opline->extended_value TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op1.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op1.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op1.var));
			if ((value = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce)) != NULL) {
				ZVAL_DUP(EX_VAR(opline->result.var), value);
				CHECK_EXCEPTION();
				ZEND_VM_NEXT_OPCODE();
			}
		}

		if (EXPECTED((value = zend_hash_find(&ce->constants_table, Z_STR_P(opline->op2.zv))) != NULL)) {
			if (Z_ISREF_P(value)) {
				value = Z_REFVAL_P(value);
			}
			if (Z_CONSTANT_P(value)) {
				zend_class_entry *old_scope = EG(scope);

				EG(scope) = ce;
				zval_update_constant(value, (void *) 1 TSRMLS_CC);
				EG(scope) = old_scope;
			}
			if (IS_UNUSED == IS_CONST) {
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), value);
			} else {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce, value);
			}
			ZVAL_DUP(EX_VAR(opline->result.var), value);
		} else if (Z_STRLEN_P(opline->op2.zv) == sizeof("class")-1 && memcmp(Z_STRVAL_P(opline->op2.zv), "class", sizeof("class") - 1) == 0) {
			/* "class" is assigned as a case-sensitive keyword from zend_do_resolve_class_name */
			ZVAL_STR(EX_VAR(opline->result.var), ce->name);
			STR_ADDREF(ce->name);
		} else {
			zend_error_noreturn(E_ERROR, "Undefined class constant '%s'", Z_STRVAL_P(opline->op2.zv));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED != IS_UNUSED) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = opline->op2.zv;

container_again:
	switch (Z_TYPE_P(container)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(container);
offset_again:
			switch (Z_TYPE_P(offset)) {
				case IS_DOUBLE:
					hval = zend_dval_to_lval(Z_DVAL_P(offset));
					zend_hash_index_del(ht, hval);
					break;
				case IS_RESOURCE:
				case IS_BOOL:
				case IS_LONG:
					hval = Z_LVAL_P(offset);
					zend_hash_index_del(ht, hval);
					break;
				case IS_STRING:
					if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
						if (Z_REFCOUNTED_P(offset)) Z_ADDREF_P(offset);
					}
					if (IS_CONST != IS_CONST) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
					}
					if (ht == &EG(symbol_table).ht) {
						zend_delete_global_variable(Z_STR_P(offset) TSRMLS_CC);
					} else {
						zend_hash_del(ht, Z_STR_P(offset));
					}
					if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
num_index_dim:
					zend_hash_index_del(ht, hval);
					if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
				case IS_NULL:
					zend_hash_del(ht, STR_EMPTY_ALLOC());
					break;
				case IS_REFERENCE:
					offset = Z_REFVAL_P(offset);
					goto offset_again;
					break;
				default:
					zend_error(E_WARNING, "Illegal offset type in unset");
					break;
			}

			break;
		}
		case IS_OBJECT:
			if (UNEXPECTED(Z_OBJ_HT_P(container)->unset_dimension == NULL)) {
				zend_error_noreturn(E_ERROR, "Cannot use object as array");
			}
//???			if (IS_CONST == IS_CONST) {
//???				zval_copy_ctor(offset);
//???			}
			Z_OBJ_HT_P(container)->unset_dimension(container, offset TSRMLS_CC);

			break;
		case IS_STRING:
		case IS_STR_OFFSET:
			zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
			ZEND_VM_CONTINUE(); /* bailed out before */
		case IS_REFERENCE:
			container = Z_REFVAL_P(container);
			goto container_again;
			break;
		default:

			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && Z_TYPE_P(container) == IS_STR_OFFSET) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
	}
	offset = opline->op2.zv;

	ZVAL_DEREF(container);
	if (Z_TYPE_P(container) == IS_OBJECT) {
		if (Z_OBJ_HT_P(container)->unset_property) {
			Z_OBJ_HT_P(container)->unset_property(container, offset, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
		} else {
			zend_error(E_NOTICE, "Trying to unset property of non-object");
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	int result;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset = opline->op2.zv;

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht = Z_ARRVAL_P(container);
		zval *value = NULL;
		zend_string *str;

isset_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				value = zend_hash_index_find(ht, hval);
				break;
			case IS_STRING:
				str = Z_STR_P(offset);
				if (IS_CONST != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(str->val, str->len+1, hval, goto num_index_prop);
				}
str_index_prop:
				value = zend_hash_find_ind(ht, str);
				break;
			case IS_NULL:
				str = STR_EMPTY_ALLOC();
				goto str_index_prop;
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto isset_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = (value != NULL && Z_TYPE_P(value) > IS_NULL);
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			result = (value == NULL || !i_zend_is_true(value TSRMLS_CC));
		}
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISSET) == 0, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISSET) == 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		result = 0;
		if (UNEXPECTED(Z_TYPE_P(offset) != IS_LONG)) {
			if (Z_TYPE_P(offset) < IS_STRING /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_DUP(&tmp, offset);
				convert_to_long(&tmp);
				offset = &tmp;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
				if ((opline->extended_value & ZEND_ISSET) ||
				    Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else {
		result = ((opline->extended_value & ZEND_ISSET) == 0);
	}

	ZVAL_BOOL(EX_VAR(opline->result.var), result);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CONST(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_UNUSED_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_UNUSED == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_UNUSED == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_CONST == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_CONST == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data1;
	zval *object = _get_obj_zval_ptr_unused(TSRMLS_C);
	zval *property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value;
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_dtor(free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		zval_dtor(free_op2.var);
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_UNUSED == IS_VAR && !0) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_TMP_VAR TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:
	zval_dtor(free_op2.var);
	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);

	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_UNUSED_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	var_ptr = NULL;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_UNUSED == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMP(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMP(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMP(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMP(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMP(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMP(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMP(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMP(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMP(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMP(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_TMP(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_TMP(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_TMP(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_UNUSED_TMP(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(retval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(zptr);
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(retval, zptr);
			}
		}
	}

	if (!have_get_ptr) {
		zval rv;

		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(z);
			incdec_op(z);
			ZVAL_COPY_VALUE(retval, z);
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(retval, opline);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(retval);
			}
		}
	}

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_TMP(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_TMP(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_UNUSED_TMP(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_DUP(retval, zptr);

			incdec_op(zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval rv;
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
			zval z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			ZVAL_DUP(retval, z);
			ZVAL_DUP(&z_copy, z);
			incdec_op(&z_copy);
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, &z_copy, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_TMP(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_TMP(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, (opline->extended_value & ZEND_FETCH_MAKE_REF) != 0 TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_RW, 0 TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;

		SAVE_OPLINE();
		property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_obj_zval_ptr_unused(TSRMLS_C);

		if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, 0 TSRMLS_CC);
		zval_dtor(free_op2.var);
		if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_UNUSED_TMP(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container, *property, *retval_ptr;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_UNSET, 0 TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *object;
	zval *property_name;

	SAVE_OPLINE();
	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);
	zval_dtor(free_op2.var);

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_VAR_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *str = EX_VAR(opline->result.var);
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		ZVAL_EMPTY_STRING(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		ZVAL_DEREF(var);
		if (Z_TYPE_P(var) != IS_STRING) {
			zend_make_printable_zval(var, &var_copy, &use_copy);

			if (use_copy) {
				var = &var_copy;
			}
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_free_op free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_TMP_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_TMP_VAR == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_dtor(free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED != IS_UNUSED) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

container_again:
	switch (Z_TYPE_P(container)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(container);
offset_again:
			switch (Z_TYPE_P(offset)) {
				case IS_DOUBLE:
					hval = zend_dval_to_lval(Z_DVAL_P(offset));
					zend_hash_index_del(ht, hval);
					break;
				case IS_RESOURCE:
				case IS_BOOL:
				case IS_LONG:
					hval = Z_LVAL_P(offset);
					zend_hash_index_del(ht, hval);
					break;
				case IS_STRING:
					if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
						if (Z_REFCOUNTED_P(offset)) Z_ADDREF_P(offset);
					}
					if (IS_TMP_VAR != IS_CONST) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
					}
					if (ht == &EG(symbol_table).ht) {
						zend_delete_global_variable(Z_STR_P(offset) TSRMLS_CC);
					} else {
						zend_hash_del(ht, Z_STR_P(offset));
					}
					if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
num_index_dim:
					zend_hash_index_del(ht, hval);
					if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
				case IS_NULL:
					zend_hash_del(ht, STR_EMPTY_ALLOC());
					break;
				case IS_REFERENCE:
					offset = Z_REFVAL_P(offset);
					goto offset_again;
					break;
				default:
					zend_error(E_WARNING, "Illegal offset type in unset");
					break;
			}
			zval_dtor(free_op2.var);
			break;
		}
		case IS_OBJECT:
			if (UNEXPECTED(Z_OBJ_HT_P(container)->unset_dimension == NULL)) {
				zend_error_noreturn(E_ERROR, "Cannot use object as array");
			}
//???			if (IS_TMP_VAR == IS_CONST) {
//???				zval_copy_ctor(offset);
//???			}
			Z_OBJ_HT_P(container)->unset_dimension(container, offset TSRMLS_CC);
			zval_dtor(free_op2.var);
			break;
		case IS_STRING:
		case IS_STR_OFFSET:
			zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
			ZEND_VM_CONTINUE(); /* bailed out before */
		case IS_REFERENCE:
			container = Z_REFVAL_P(container);
			goto container_again;
			break;
		default:
			zval_dtor(free_op2.var);
			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && Z_TYPE_P(container) == IS_STR_OFFSET) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
	}
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	ZVAL_DEREF(container);
	if (Z_TYPE_P(container) == IS_OBJECT) {
		if (Z_OBJ_HT_P(container)->unset_property) {
			Z_OBJ_HT_P(container)->unset_property(container, offset, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
		} else {
			zend_error(E_NOTICE, "Trying to unset property of non-object");
		}
	}
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	int result;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht = Z_ARRVAL_P(container);
		zval *value = NULL;
		zend_string *str;

isset_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				value = zend_hash_index_find(ht, hval);
				break;
			case IS_STRING:
				str = Z_STR_P(offset);
				if (IS_TMP_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(str->val, str->len+1, hval, goto num_index_prop);
				}
str_index_prop:
				value = zend_hash_find_ind(ht, str);
				break;
			case IS_NULL:
				str = STR_EMPTY_ALLOC();
				goto str_index_prop;
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto isset_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = (value != NULL && Z_TYPE_P(value) > IS_NULL);
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			result = (value == NULL || !i_zend_is_true(value TSRMLS_CC));
		}
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISSET) == 0, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISSET) == 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		result = 0;
		if (UNEXPECTED(Z_TYPE_P(offset) != IS_LONG)) {
			if (Z_TYPE_P(offset) < IS_STRING /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_DUP(&tmp, offset);
				convert_to_long(&tmp);
				offset = &tmp;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
				if ((opline->extended_value & ZEND_ISSET) ||
				    Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else {
		result = ((opline->extended_value & ZEND_ISSET) == 0);
	}

	zval_dtor(free_op2.var);
	ZVAL_BOOL(EX_VAR(opline->result.var), result);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_TMP(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_UNUSED_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_UNUSED == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_UNUSED == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_TMP_VAR == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_TMP_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data1;
	zval *object = _get_obj_zval_ptr_unused(TSRMLS_C);
	zval *property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value;
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_ptr_dtor_nogc(free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		zval_ptr_dtor_nogc(free_op2.var);
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_UNUSED_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_UNUSED == IS_VAR && !0) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_VAR TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:
	zval_ptr_dtor_nogc(free_op2.var);
	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);

	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_UNUSED_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	var_ptr = NULL;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_UNUSED == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:
	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_VAR(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_VAR(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_VAR(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_VAR(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_VAR(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_VAR(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_VAR(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_VAR(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_VAR(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_VAR(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_VAR(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_VAR(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_VAR(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_UNUSED_VAR(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_ptr_dtor_nogc(free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(retval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(zptr);
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(retval, zptr);
			}
		}
	}

	if (!have_get_ptr) {
		zval rv;

		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(z);
			incdec_op(z);
			ZVAL_COPY_VALUE(retval, z);
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(retval, opline);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(retval);
			}
		}
	}

	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_VAR(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_VAR(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_UNUSED_VAR(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_ptr_dtor_nogc(free_op2.var);
		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_DUP(retval, zptr);

			incdec_op(zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval rv;
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
			zval z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			ZVAL_DUP(retval, z);
			ZVAL_DUP(&z_copy, z);
			incdec_op(&z_copy);
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, &z_copy, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_VAR(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_VAR(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, (opline->extended_value & ZEND_FETCH_MAKE_REF) != 0 TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_RW, 0 TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;

		SAVE_OPLINE();
		property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_obj_zval_ptr_unused(TSRMLS_C);

		if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, 0 TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op2.var);
		if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_UNUSED_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container, *property, *retval_ptr;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_UNSET, 0 TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *object;
	zval *property_name;

	SAVE_OPLINE();
	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_VAR_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *str = EX_VAR(opline->result.var);
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		ZVAL_EMPTY_STRING(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		ZVAL_DEREF(var);
		if (Z_TYPE_P(var) != IS_STRING) {
			zend_make_printable_zval(var, &var_copy, &use_copy);

			if (use_copy) {
				var = &var_copy;
			}
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */
	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_free_op free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_VAR == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor_nogc(free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED != IS_UNUSED) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

container_again:
	switch (Z_TYPE_P(container)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(container);
offset_again:
			switch (Z_TYPE_P(offset)) {
				case IS_DOUBLE:
					hval = zend_dval_to_lval(Z_DVAL_P(offset));
					zend_hash_index_del(ht, hval);
					break;
				case IS_RESOURCE:
				case IS_BOOL:
				case IS_LONG:
					hval = Z_LVAL_P(offset);
					zend_hash_index_del(ht, hval);
					break;
				case IS_STRING:
					if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
						if (Z_REFCOUNTED_P(offset)) Z_ADDREF_P(offset);
					}
					if (IS_VAR != IS_CONST) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
					}
					if (ht == &EG(symbol_table).ht) {
						zend_delete_global_variable(Z_STR_P(offset) TSRMLS_CC);
					} else {
						zend_hash_del(ht, Z_STR_P(offset));
					}
					if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
num_index_dim:
					zend_hash_index_del(ht, hval);
					if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
				case IS_NULL:
					zend_hash_del(ht, STR_EMPTY_ALLOC());
					break;
				case IS_REFERENCE:
					offset = Z_REFVAL_P(offset);
					goto offset_again;
					break;
				default:
					zend_error(E_WARNING, "Illegal offset type in unset");
					break;
			}
			zval_ptr_dtor_nogc(free_op2.var);
			break;
		}
		case IS_OBJECT:
			if (UNEXPECTED(Z_OBJ_HT_P(container)->unset_dimension == NULL)) {
				zend_error_noreturn(E_ERROR, "Cannot use object as array");
			}
//???			if (IS_VAR == IS_CONST) {
//???				zval_copy_ctor(offset);
//???			}
			Z_OBJ_HT_P(container)->unset_dimension(container, offset TSRMLS_CC);
			zval_ptr_dtor_nogc(free_op2.var);
			break;
		case IS_STRING:
		case IS_STR_OFFSET:
			zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
			ZEND_VM_CONTINUE(); /* bailed out before */
		case IS_REFERENCE:
			container = Z_REFVAL_P(container);
			goto container_again;
			break;
		default:
			zval_ptr_dtor_nogc(free_op2.var);
			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && Z_TYPE_P(container) == IS_STR_OFFSET) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
	}
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	ZVAL_DEREF(container);
	if (Z_TYPE_P(container) == IS_OBJECT) {
		if (Z_OBJ_HT_P(container)->unset_property) {
			Z_OBJ_HT_P(container)->unset_property(container, offset, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
		} else {
			zend_error(E_NOTICE, "Trying to unset property of non-object");
		}
	}
	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	int result;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht = Z_ARRVAL_P(container);
		zval *value = NULL;
		zend_string *str;

isset_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				value = zend_hash_index_find(ht, hval);
				break;
			case IS_STRING:
				str = Z_STR_P(offset);
				if (IS_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(str->val, str->len+1, hval, goto num_index_prop);
				}
str_index_prop:
				value = zend_hash_find_ind(ht, str);
				break;
			case IS_NULL:
				str = STR_EMPTY_ALLOC();
				goto str_index_prop;
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto isset_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = (value != NULL && Z_TYPE_P(value) > IS_NULL);
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			result = (value == NULL || !i_zend_is_true(value TSRMLS_CC));
		}
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISSET) == 0, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISSET) == 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		result = 0;
		if (UNEXPECTED(Z_TYPE_P(offset) != IS_LONG)) {
			if (Z_TYPE_P(offset) < IS_STRING /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_DUP(&tmp, offset);
				convert_to_long(&tmp);
				offset = &tmp;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
				if ((opline->extended_value & ZEND_ISSET) ||
				    Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else {
		result = ((opline->extended_value & ZEND_ISSET) == 0);
	}

	zval_ptr_dtor_nogc(free_op2.var);
	ZVAL_BOOL(EX_VAR(opline->result.var), result);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_VAR(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_UNUSED_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_UNUSED == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_UNUSED == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_VAR == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));
			zval_ptr_dtor_nogc(free_op2.var);
		} else {
			if (IS_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval *object = _get_obj_zval_ptr_unused(TSRMLS_C);
	zval *property = NULL;
	zval *value;
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_UNUSED == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_UNUSED == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_UNUSED == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_UNUSED == IS_VAR && !0) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = NULL;

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_UNUSED TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:

	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);

	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = NULL;
	var_ptr = NULL;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_UNUSED == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_UNUSED(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_UNUSED(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_UNUSED(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_UNUSED_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_UNUSED == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_UNUSED == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_UNUSED == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_UNUSED == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval *object = _get_obj_zval_ptr_unused(TSRMLS_C);
	zval *property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	zval *value;
	int have_get_ptr = 0;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_UNUSED == IS_VAR && !0) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_CV TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:

	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);

	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_UNUSED_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	var_ptr = NULL;

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_UNUSED == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CV(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CV(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CV(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CV(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CV(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CV(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CV(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CV(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CV(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CV(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_UNUSED_CV(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_UNUSED_CV(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_UNUSED_CV(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_UNUSED_CV(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(retval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(zptr);
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(retval, zptr);
			}
		}
	}

	if (!have_get_ptr) {
		zval rv;

		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(z);
			incdec_op(z);
			ZVAL_COPY_VALUE(retval, z);
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(retval, opline);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(retval);
			}
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_CV(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_UNUSED_CV(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_UNUSED_CV(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_DUP(retval, zptr);

			incdec_op(zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval rv;
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
			zval z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			ZVAL_DUP(retval, z);
			ZVAL_DUP(&z_copy, z);
			incdec_op(&z_copy);
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, &z_copy, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_CV(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_UNUSED_CV(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_UNUSED_CV(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_UNUSED_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, (opline->extended_value & ZEND_FETCH_MAKE_REF) != 0 TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	container = _get_obj_zval_ptr_unused(TSRMLS_C);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_RW, 0 TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;

		SAVE_OPLINE();
		property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		container = _get_obj_zval_ptr_unused(TSRMLS_C);

		if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, 0 TSRMLS_CC);

		if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_UNUSED_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container, *property, *retval_ptr;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_UNSET, 0 TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object;
	zval *property_name;

	SAVE_OPLINE();
	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);


	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_VAR_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *str = EX_VAR(opline->result.var);
	zval *var;
	zval var_copy;
	int use_copy = 0;

	SAVE_OPLINE();
	var = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_UNUSED == IS_UNUSED) {
		/* Initialize for erealloc in add_string_to_string */
		ZVAL_EMPTY_STRING(str);
	}

	if (Z_TYPE_P(var) != IS_STRING) {
		ZVAL_DEREF(var);
		if (Z_TYPE_P(var) != IS_STRING) {
			zend_make_printable_zval(var, &var_copy, &use_copy);

			if (use_copy) {
				var = &var_copy;
			}
		}
	}
	add_string_to_string(str, str, var);

	if (use_copy) {
		zval_dtor(var);
	}
	/* original comment, possibly problematic:
	 * FREE_OP is missing intentionally here - we're always working on the same temporary variable
	 * (Zeev):  I don't think it's problematic, we only use variables
	 * which aren't affected by FREE_OP(Ts, )'s anyway, unless they're
	 * string offsets or overloaded objects
	 */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;

	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_obj_zval_ptr_unused(TSRMLS_C);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_CV != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_CV == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_UNUSED == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_UNUSED != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED != IS_UNUSED) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

container_again:
	switch (Z_TYPE_P(container)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(container);
offset_again:
			switch (Z_TYPE_P(offset)) {
				case IS_DOUBLE:
					hval = zend_dval_to_lval(Z_DVAL_P(offset));
					zend_hash_index_del(ht, hval);
					break;
				case IS_RESOURCE:
				case IS_BOOL:
				case IS_LONG:
					hval = Z_LVAL_P(offset);
					zend_hash_index_del(ht, hval);
					break;
				case IS_STRING:
					if (IS_CV == IS_CV || IS_CV == IS_VAR) {
						if (Z_REFCOUNTED_P(offset)) Z_ADDREF_P(offset);
					}
					if (IS_CV != IS_CONST) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
					}
					if (ht == &EG(symbol_table).ht) {
						zend_delete_global_variable(Z_STR_P(offset) TSRMLS_CC);
					} else {
						zend_hash_del(ht, Z_STR_P(offset));
					}
					if (IS_CV == IS_CV || IS_CV == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
num_index_dim:
					zend_hash_index_del(ht, hval);
					if (IS_CV == IS_CV || IS_CV == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
				case IS_NULL:
					zend_hash_del(ht, STR_EMPTY_ALLOC());
					break;
				case IS_REFERENCE:
					offset = Z_REFVAL_P(offset);
					goto offset_again;
					break;
				default:
					zend_error(E_WARNING, "Illegal offset type in unset");
					break;
			}

			break;
		}
		case IS_OBJECT:
			if (UNEXPECTED(Z_OBJ_HT_P(container)->unset_dimension == NULL)) {
				zend_error_noreturn(E_ERROR, "Cannot use object as array");
			}
//???			if (IS_CV == IS_CONST) {
//???				zval_copy_ctor(offset);
//???			}
			Z_OBJ_HT_P(container)->unset_dimension(container, offset TSRMLS_CC);

			break;
		case IS_STRING:
		case IS_STR_OFFSET:
			zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
			ZEND_VM_CONTINUE(); /* bailed out before */
		case IS_REFERENCE:
			container = Z_REFVAL_P(container);
			goto container_again;
			break;
		default:

			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	if (IS_UNUSED == IS_VAR && Z_TYPE_P(container) == IS_STR_OFFSET) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
	}
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	ZVAL_DEREF(container);
	if (Z_TYPE_P(container) == IS_OBJECT) {
		if (Z_OBJ_HT_P(container)->unset_property) {
			Z_OBJ_HT_P(container)->unset_property(container, offset, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
		} else {
			zend_error(E_NOTICE, "Trying to unset property of non-object");
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	int result;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_obj_zval_ptr_unused(TSRMLS_C);
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht = Z_ARRVAL_P(container);
		zval *value = NULL;
		zend_string *str;

isset_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				value = zend_hash_index_find(ht, hval);
				break;
			case IS_STRING:
				str = Z_STR_P(offset);
				if (IS_CV != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(str->val, str->len+1, hval, goto num_index_prop);
				}
str_index_prop:
				value = zend_hash_find_ind(ht, str);
				break;
			case IS_NULL:
				str = STR_EMPTY_ALLOC();
				goto str_index_prop;
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto isset_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = (value != NULL && Z_TYPE_P(value) > IS_NULL);
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			result = (value == NULL || !i_zend_is_true(value TSRMLS_CC));
		}
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISSET) == 0, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISSET) == 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		result = 0;
		if (UNEXPECTED(Z_TYPE_P(offset) != IS_LONG)) {
			if (Z_TYPE_P(offset) < IS_STRING /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_DUP(&tmp, offset);
				convert_to_long(&tmp);
				offset = &tmp;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
				if ((opline->extended_value & ZEND_ISSET) ||
				    Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else {
		result = ((opline->extended_value & ZEND_ISSET) == 0);
	}

	ZVAL_BOOL(EX_VAR(opline->result.var), result);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_UNUSED_CV(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_UNUSED_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_UNUSED != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_UNUSED == IS_CONST || IS_UNUSED == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = NULL;
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = NULL;

				if (IS_UNUSED == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_UNUSED == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = NULL;

			/* Consts, temporary variables and references need copying */
			if (IS_UNUSED == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_UNUSED == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_UNUSED == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_CV == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_CV == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_BW_NOT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_not_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_NOT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_not_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC) TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *var_ptr;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (UNEXPECTED(Z_ISREF_P(var_ptr))) {
		var_ptr = Z_REFVAL_P(var_ptr);
	} else {
		SEPARATE_ZVAL(var_ptr);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_P(var_ptr, get)
	   && Z_OBJ_HANDLER_P(var_ptr, set)) {
		/* proxy object */
		zval rv;
		zval *val = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_increment_function(val);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(val);
	} else {
		fast_increment_function(var_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *var_ptr;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (UNEXPECTED(Z_ISREF_P(var_ptr))) {
		var_ptr = Z_REFVAL_P(var_ptr);
	} else {
		SEPARATE_ZVAL(var_ptr);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_P(var_ptr, get)
	   && Z_OBJ_HANDLER_P(var_ptr, set)) {
		/* proxy object */
		zval rv;
		zval *val = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_decrement_function(val);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(val);
	} else {
		fast_decrement_function(var_ptr);
	}

	if (RETURN_VALUE_USED(opline)) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *var_ptr, *retval;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		ZVAL_NULL(EX_VAR(opline->result.var));

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	retval = EX_VAR(opline->result.var);

	if (UNEXPECTED(Z_ISREF_P(var_ptr))) {
		var_ptr = Z_REFVAL_P(var_ptr);
		ZVAL_DUP(retval, var_ptr);
	} else {
		ZVAL_DUP(retval, var_ptr);
		SEPARATE_ZVAL(var_ptr);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_P(var_ptr, get)
	   && Z_OBJ_HANDLER_P(var_ptr, set)) {
		/* proxy object */
		zval rv;
		zval *val = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_increment_function(val);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(val);
	} else {
		fast_increment_function(var_ptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_DEC_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *var_ptr, *retval;

	SAVE_OPLINE();
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}
	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		ZVAL_NULL(EX_VAR(opline->result.var));

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	retval = EX_VAR(opline->result.var);

	if (UNEXPECTED(Z_ISREF_P(var_ptr))) {
		var_ptr = Z_REFVAL_P(var_ptr);
		ZVAL_DUP(retval, var_ptr);
	} else {
		ZVAL_DUP(retval, var_ptr);
		SEPARATE_ZVAL(var_ptr);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT)
	   && Z_OBJ_HANDLER_P(var_ptr, get)
	   && Z_OBJ_HANDLER_P(var_ptr, set)) {
		/* proxy object */
		zval rv;
		zval *val = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(val);
		fast_decrement_function(val);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, val TSRMLS_CC);
		zval_ptr_dtor(val);
	} else {
		fast_decrement_function(var_ptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *z;

	SAVE_OPLINE();
	z = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	zend_print_variable(z);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRINT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	ZVAL_LONG(EX_VAR(opline->result.var), 1);
	return ZEND_ECHO_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_JMPZ_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val TSRMLS_CC);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (!ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int ret;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		ret = Z_LVAL_P(val);
	} else {
		ret = i_zend_is_true(val TSRMLS_CC);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (ret) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}

	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPZNZ_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val TSRMLS_CC);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	if (EXPECTED(retval != 0)) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on true to %d\n", opline->extended_value);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->extended_value]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	} else {
#if DEBUG_ZEND>=2
		printf("Conditional jmp on false to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(&EX(op_array)->opcodes[opline->op2.opline_num]);
		ZEND_VM_CONTINUE(); /* CHECK_ME */
	}
}

static int ZEND_FASTCALL  ZEND_JMPZ_EX_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val TSRMLS_CC);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	ZVAL_BOOL(EX_VAR(opline->result.var), retval);
	if (!retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMPNZ_EX_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *val;
	int retval;

	SAVE_OPLINE();
	val = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_TMP_VAR && EXPECTED(Z_TYPE_P(val) == IS_BOOL)) {
		retval = Z_LVAL_P(val);
	} else {
		retval = i_zend_is_true(val TSRMLS_CC);

		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
	}
	ZVAL_BOOL(EX_VAR(opline->result.var), retval);
	if (retval) {
#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_SET_OPCODE(opline->op2.jmp_addr);
		ZEND_VM_CONTINUE();
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_RETURN_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;


	SAVE_OPLINE();
	retval_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (!EX(return_value)) {

	} else {
		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
			if (IS_CV != IS_TMP_VAR) {
				zval_opt_copy_ctor(EX(return_value));
			}

		} else if (Z_ISREF_P(retval_ptr)) {
			ZVAL_DUP(EX(return_value), Z_REFVAL_P(retval_ptr));

		} else {
			ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
			if (IS_CV == IS_CV) {
				if (Z_OPT_REFCOUNTED_P(retval_ptr)) Z_ADDREF_P(retval_ptr);
			}
		}
	}
	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_RETURN_BY_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *retval_ptr;


	SAVE_OPLINE();

	do {
		if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR ||
		    (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_VALUE)) {
			/* Not supposed to happen, but we'll allow it */
			zend_error(E_NOTICE, "Only variable references should be returned by reference");

			retval_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
			if (!EX(return_value)) {
				if (IS_CV == IS_TMP_VAR) {

				}
			} else if (!0) { /* Not a temp var */
				ZVAL_DUP(EX(return_value), retval_ptr);
			} else {
				ZVAL_COPY_VALUE(EX(return_value), retval_ptr);
			}
			break;
		}

		retval_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(retval_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot return string offsets by reference");
		}

		if (IS_CV == IS_VAR && !Z_ISREF_P(retval_ptr)) {
			if (opline->extended_value == ZEND_RETURNS_FUNCTION &&
			    (Z_VAR_FLAGS_P(retval_ptr) & IS_VAR_RET_REF)) {
			} else {
				zend_error(E_NOTICE, "Only variable references should be returned by reference");
				if (EX(return_value)) {
					zval tmp;
					ZVAL_DUP(&tmp, retval_ptr);
					ZVAL_NEW_REF(EX(return_value), &tmp);
				}
				break;
			}
		}

		if (EX(return_value)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval_ptr);
			ZVAL_COPY(EX(return_value), retval_ptr);
		}
	} while (0);

	return zend_leave_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_THROW_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zval exception;


	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CONST || UNEXPECTED(Z_TYPE_P(value) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Can only throw objects");
	}

	zend_exception_save(TSRMLS_C);
	if (IS_CV == IS_CONST) {
		ZVAL_DUP(&exception, value);
		value = &exception;
	} else if (IS_CV != IS_TMP_VAR) {
		if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
	}

	zend_throw_exception_object(value TSRMLS_CC);
	zend_exception_restore(TSRMLS_C);

	HANDLE_EXCEPTION();
}

static int ZEND_FASTCALL zend_send_by_var_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *varptr, *top;


	varptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	top = zend_vm_stack_top_inc(TSRMLS_C);
	if (Z_ISREF_P(varptr)) {
		ZVAL_DUP(top, Z_REFVAL_P(varptr));

	} else {
		if (IS_CV == IS_CV) {
			if (Z_REFCOUNTED_P(varptr)) Z_ADDREF_P(varptr);
		}
		ZVAL_COPY_VALUE(top, varptr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *varptr;
	int arg_num;

	SAVE_OPLINE();
	if (opline->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) { /* Had function_ptr at compile_time */
		if (!(opline->extended_value & ZEND_ARG_SEND_BY_REF)) {
			return zend_send_by_var_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	} else {
		arg_num = opline->op2.num + EX(call)->num_additional_args;
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
			return zend_send_by_var_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}

	varptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	if ((!(opline->extended_value & ZEND_ARG_SEND_FUNCTION) ||
	     (Z_VAR_FLAGS_P(varptr) & IS_VAR_RET_REF)) &&
	    ((!Z_REFCOUNTED_P(varptr) && Z_TYPE_P(varptr) != IS_STRING) ||
	     Z_ISREF_P(varptr) ||
	     Z_TYPE_P(varptr) == IS_OBJECT ||
	     (Z_REFCOUNTED_P(varptr) && Z_REFCOUNT_P(varptr) == 1))) {

		if (Z_ISREF_P(varptr)) {
			if (IS_CV == IS_CV) {
				Z_ADDREF_P(varptr);
			}
		} else {
			ZVAL_NEW_REF(varptr, varptr);
			if (IS_CV == IS_CV) {
				Z_ADDREF_P(varptr);
			}
		}
		zend_vm_stack_push(varptr TSRMLS_CC);
	} else {
		zval val;

		if ((opline->extended_value & ZEND_ARG_COMPILE_TIME_BOUND) ?
			!(opline->extended_value & ZEND_ARG_SEND_SILENT) :
			!ARG_MAY_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
			zend_error(E_STRICT, "Only variables should be passed by reference");
		}
		ZVAL_COPY_VALUE(&val, varptr);
		if (!0) {
			zval_opt_copy_ctor(&val);
		}

		zend_vm_stack_push(&val TSRMLS_CC);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEND_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *varptr;

	SAVE_OPLINE();
	varptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(varptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Only variables can be passed by reference");
	}

	if (IS_CV == IS_VAR && UNEXPECTED(varptr == &EG(error_zval))) {
		zend_vm_stack_push(&EG(uninitialized_zval) TSRMLS_CC);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (opline->extended_value == ZEND_DO_FCALL_BY_NAME &&
	    EX(function_state).function->type == ZEND_INTERNAL_FUNCTION) {
		int arg_num = opline->op2.num + EX(call)->num_additional_args;
		if (!ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
			return zend_send_by_var_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}

	if (Z_ISREF_P(varptr)) {
		Z_ADDREF_P(varptr);
	} else if (IS_CV == IS_VAR &&
		EXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT)) {
		zval tmp;
		ZVAL_COPY_VALUE(&tmp, varptr);
		varptr = &tmp;
		SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr);
	} else {
		SEPARATE_ZVAL_TO_MAKE_IS_REF(varptr);
		Z_ADDREF_P(varptr);
	}

	zend_vm_stack_push(varptr TSRMLS_CC);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SEND_VAR_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (opline->extended_value == ZEND_DO_FCALL_BY_NAME) {
		int arg_num = opline->op2.num + EX(call)->num_additional_args;
		if (ARG_SHOULD_BE_SENT_BY_REF(EX(call)->fbc, arg_num)) {
			return ZEND_SEND_REF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
		}
	}
	SAVE_OPLINE();
	return zend_send_by_var_helper_SPEC_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_BOOL_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *retval = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	/* PHP 3.0 returned "" for false and 1 for true, here we use 0 and 1 for now */
	ZVAL_BOOL(retval, i_zend_is_true(_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC) TSRMLS_CC));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CLONE_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *obj;
	zend_class_entry *ce;
	zend_function *clone;
	zend_object_clone_obj_t clone_call;

	SAVE_OPLINE();
	obj = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_CONST ||
	    UNEXPECTED(Z_TYPE_P(obj) != IS_OBJECT)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "__clone method called on non-object");
	}

	ce = Z_OBJCE_P(obj);
	clone = ce ? ce->clone : NULL;
	clone_call =  Z_OBJ_HT_P(obj)->clone_obj;
	if (UNEXPECTED(clone_call == NULL)) {
		if (ce) {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object of class %s", ce->name->val);
		} else {
			zend_error_noreturn(E_ERROR, "Trying to clone an uncloneable object");
		}
	}

	if (ce && clone) {
		if (clone->op_array.fn_flags & ZEND_ACC_PRIVATE) {
			/* Ensure that if we're calling a private function, we're allowed to do so.
			 */
			if (UNEXPECTED(ce != EG(scope))) {
				zend_error_noreturn(E_ERROR, "Call to private %s::__clone() from context '%s'", ce->name->val, EG(scope) ? EG(scope)->name->val : "");
			}
		} else if ((clone->common.fn_flags & ZEND_ACC_PROTECTED)) {
			/* Ensure that if we're calling a protected function, we're allowed to do so.
			 */
			if (UNEXPECTED(!zend_check_protected(zend_get_function_root_class(clone), EG(scope)))) {
				zend_error_noreturn(E_ERROR, "Call to protected %s::__clone() from context '%s'", ce->name->val, EG(scope) ? EG(scope)->name->val : "");
			}
		}
	}

	if (EXPECTED(EG(exception) == NULL)) {
		ZVAL_OBJ(EX_VAR(opline->result.var), clone_call(obj TSRMLS_CC));
		if (!RETURN_VALUE_USED(opline) || UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(EX_VAR(opline->result.var));
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CAST_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr, *expr_ptr;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	expr = expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		ZVAL_DEREF(expr);
	}
	if (Z_TYPE_P(expr) == opline->extended_value) {
		ZVAL_COPY_VALUE(result, expr);
		if (IS_CV == IS_CONST || expr != expr_ptr) {
			zval_opt_copy_ctor(result);

		} else if (IS_CV == IS_CV) {
			if (Z_OPT_REFCOUNTED_P(expr)) Z_ADDREF_P(expr);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	if (opline->extended_value != IS_STRING) {
		ZVAL_COPY_VALUE(result, expr);
		if (!0) {
			zval_opt_copy_ctor(result);
		}
	}

	switch (opline->extended_value) {
		case IS_NULL:
			convert_to_null(result);
			break;
		case IS_BOOL:
			convert_to_boolean(result);
			break;
		case IS_LONG:
			convert_to_long(result);
			break;
		case IS_DOUBLE:
			convert_to_double(result);
			break;
		case IS_STRING: {
			zval var_copy;
			int use_copy;

			zend_make_printable_zval(expr, &var_copy, &use_copy);
			if (use_copy) {
				ZVAL_COPY_VALUE(result, &var_copy);
				if (0) {

				}
			} else {
				ZVAL_COPY_VALUE(result, expr);
				if (!0) {
					zval_opt_copy_ctor(result);
				}
			}
			break;
		}
		case IS_ARRAY:
			convert_to_array(result);
			break;
		case IS_OBJECT:
			convert_to_object(result);
			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_op_array *new_op_array=NULL;

	zval *inc_filename;
	zval tmp_inc_filename;
	zend_bool failure_retval=0;

	SAVE_OPLINE();
	inc_filename = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	ZVAL_UNDEF(&tmp_inc_filename);
	if (Z_TYPE_P(inc_filename) != IS_STRING) {
		ZVAL_DUP(&tmp_inc_filename, inc_filename);
		convert_to_string(&tmp_inc_filename);
		inc_filename = &tmp_inc_filename;
	}

	if (opline->extended_value != ZEND_EVAL && strlen(Z_STRVAL_P(inc_filename)) != Z_STRLEN_P(inc_filename)) {
		if (opline->extended_value == ZEND_INCLUDE_ONCE || opline->extended_value == ZEND_INCLUDE) {
			zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		} else {
			zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
		}
	} else {
		switch (opline->extended_value) {
			case ZEND_INCLUDE_ONCE:
			case ZEND_REQUIRE_ONCE: {
					zend_file_handle file_handle;
					char *resolved_path;

					resolved_path = zend_resolve_path(Z_STRVAL_P(inc_filename), Z_STRLEN_P(inc_filename) TSRMLS_CC);
					if (resolved_path) {
						failure_retval = zend_hash_str_exists(&EG(included_files), resolved_path, strlen(resolved_path));
					} else {
						resolved_path = Z_STRVAL_P(inc_filename);
					}

					if (failure_retval) {
						/* do nothing, file already included */
					} else if (SUCCESS == zend_stream_open(resolved_path, &file_handle TSRMLS_CC)) {

						if (!file_handle.opened_path) {
							file_handle.opened_path = estrdup(resolved_path);
						}

						if (zend_hash_str_add_empty_element(&EG(included_files), file_handle.opened_path, strlen(file_handle.opened_path))) {
							new_op_array = zend_compile_file(&file_handle, (opline->extended_value==ZEND_INCLUDE_ONCE?ZEND_INCLUDE:ZEND_REQUIRE) TSRMLS_CC);
							zend_destroy_file_handle(&file_handle TSRMLS_CC);
						} else {
							zend_file_handle_dtor(&file_handle TSRMLS_CC);
							failure_retval=1;
						}
					} else {
						if (opline->extended_value == ZEND_INCLUDE_ONCE) {
							zend_message_dispatcher(ZMSG_FAILED_INCLUDE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						} else {
							zend_message_dispatcher(ZMSG_FAILED_REQUIRE_FOPEN, Z_STRVAL_P(inc_filename) TSRMLS_CC);
						}
					}
					if (resolved_path != Z_STRVAL_P(inc_filename)) {
						efree(resolved_path);
					}
				}
				break;
			case ZEND_INCLUDE:
			case ZEND_REQUIRE:
				new_op_array = compile_filename(opline->extended_value, inc_filename TSRMLS_CC);
				break;
			case ZEND_EVAL: {
					char *eval_desc = zend_make_compiled_string_description("eval()'d code" TSRMLS_CC);

					new_op_array = zend_compile_string(inc_filename, eval_desc TSRMLS_CC);
					efree(eval_desc);
				}
				break;
			EMPTY_SWITCH_DEFAULT_CASE()
		}
	}
	if (Z_TYPE(tmp_inc_filename) != IS_UNDEF) {
		zval_ptr_dtor(&tmp_inc_filename);
	}

	if (UNEXPECTED(EG(exception) != NULL)) {
		HANDLE_EXCEPTION();
	} else if (EXPECTED(new_op_array != NULL)) {
		zval *return_value = NULL;

		EG(active_op_array) = new_op_array;
		if (RETURN_VALUE_USED(opline)) {
			return_value = EX_VAR(opline->result.var);
		}

		EX(function_state).function = (zend_function *) new_op_array;
		EX(object) = NULL;

		if (!EG(active_symbol_table)) {
			zend_rebuild_symbol_table(TSRMLS_C);
		}

		if (EXPECTED(zend_execute_ex == execute_ex)) {
		    i_create_execute_data_from_op_array(new_op_array, return_value, VM_FRAME_NESTED_CODE TSRMLS_CC);
			ZEND_VM_ENTER();
		} else {
			zend_execute(new_op_array, return_value TSRMLS_CC);
		}

		EX(function_state).function = (zend_function *) EX(op_array);

		EG(opline_ptr) = &EX(opline);
		EG(active_op_array) = EX(op_array);
		destroy_op_array(new_op_array TSRMLS_CC);
		efree(new_op_array);
		if (UNEXPECTED(EG(exception) != NULL)) {
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}

	} else if (RETURN_VALUE_USED(opline)) {
		ZVAL_BOOL(EX_VAR(opline->result.var), failure_retval);
	}
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FE_RESET_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *array_ptr, *array_ref, iterator;
	HashTable *fe_ht;
	zend_object_iterator *iter = NULL;
	zend_class_entry *ce = NULL;
	zend_bool is_empty = 0;

	SAVE_OPLINE();

	if ((IS_CV == IS_CV || IS_CV == IS_VAR) &&
	    (opline->extended_value & ZEND_FE_RESET_VARIABLE)) {
		array_ptr = array_ref = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		ZVAL_DEREF(array_ptr);
		if (Z_TYPE_P(array_ptr) == IS_ARRAY) {
			if (!Z_ISREF_P(array_ref)) {
				SEPARATE_ZVAL(array_ptr);
				array_ref = array_ptr;
				if (opline->extended_value & ZEND_FE_FETCH_BYREF) {
					ZVAL_NEW_REF(array_ptr, array_ptr);
					array_ref = array_ptr;
					array_ptr = Z_REFVAL_P(array_ptr);
				}
			}
			if (Z_REFCOUNTED_P(array_ref)) Z_ADDREF_P(array_ref);
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			if(Z_OBJ_HT_P(array_ptr)->get_class_entry == NULL) {
				zend_error(E_WARNING, "foreach() cannot iterate over objects without PHP class");
				ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
			}

			ce = Z_OBJCE_P(array_ptr);
			if (!ce || ce->get_iterator == NULL) {
				if (!Z_ISREF_P(array_ref)) {
					SEPARATE_ZVAL(array_ptr);
				}
				Z_ADDREF_P(array_ptr);
			}
			array_ref = array_ptr;
		} else {
			if (Z_REFCOUNTED_P(array_ref)) Z_ADDREF_P(array_ref);
		}
	} else {
		array_ptr = array_ref = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		ZVAL_DEREF(array_ptr);
		if (0) { /* IS_TMP_VAR */
			zval tmp;

			ZVAL_COPY_VALUE(&tmp, array_ptr);
			array_ptr = &tmp;
			if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
				ce = Z_OBJCE_P(array_ptr);
				if (ce && ce->get_iterator) {
					Z_DELREF_P(array_ref);
				}
			}
		} else if (Z_TYPE_P(array_ptr) == IS_OBJECT) {
			ce = Z_OBJCE_P(array_ptr);
			if (!ce || !ce->get_iterator) {
				if (IS_CV == IS_CV) {
					Z_ADDREF_P(array_ref);
				}
			}
		} else if (Z_REFCOUNTED_P(array_ref)) {
			if (IS_CV == IS_CONST ||
			           (IS_CV == IS_CV &&
			            !Z_ISREF_P(array_ref) &&
			            Z_REFCOUNT_P(array_ref) > 1) ||
			           (IS_CV == IS_VAR &&
			            !Z_ISREF_P(array_ref) &&
			            Z_REFCOUNT_P(array_ref) > 2)) {
				zval tmp;

				if (IS_CV == IS_VAR) {
					Z_DELREF_P(array_ref);
				}
				ZVAL_DUP(&tmp, array_ref);
				array_ptr = array_ref = &tmp;
			} else if (IS_CV == IS_CV) {
				if (Z_ISREF_P(array_ref) && Z_REFCOUNT_P(array_ref) == 1) {
					ZVAL_UNREF(array_ref);
					array_ptr = array_ref;
				}
				Z_ADDREF_P(array_ref);
			}
		}
	}

	if (ce && ce->get_iterator) {
		iter = ce->get_iterator(ce, array_ptr, opline->extended_value & ZEND_FE_RESET_REFERENCE TSRMLS_CC);

		if (IS_CV == IS_VAR && !(opline->extended_value & ZEND_FE_RESET_VARIABLE)) {

		}
		if (iter && EXPECTED(EG(exception) == NULL)) {
			ZVAL_OBJ(&iterator, &iter->std);
			array_ptr = array_ref = &iterator;
		} else {
			if (IS_CV == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

			}
			if (!EG(exception)) {
				zend_throw_exception_ex(NULL, 0 TSRMLS_CC, "Object of type %s did not create an Iterator", ce->name->val);
			}
			zend_throw_exception_internal(NULL TSRMLS_CC);
			HANDLE_EXCEPTION();
		}
	}

	ZVAL_COPY_VALUE(EX_VAR(opline->result.var), array_ref);

	if (iter) {
		iter->index = 0;
		if (iter->funcs->rewind) {
			iter->funcs->rewind(iter TSRMLS_CC);
			if (UNEXPECTED(EG(exception) != NULL)) {
				zval_ptr_dtor(array_ref);
				if (IS_CV == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

				}
				HANDLE_EXCEPTION();
			}
		}
		is_empty = iter->funcs->valid(iter TSRMLS_CC) != SUCCESS;
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor(array_ref);
			if (IS_CV == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

			}
			HANDLE_EXCEPTION();
		}
		iter->index = -1; /* will be set to 0 before using next handler */
	} else if ((fe_ht = HASH_OF(array_ptr)) != NULL) {
		zend_hash_internal_pointer_reset(fe_ht);
		if (ce) {
			zend_object *zobj = Z_OBJ_P(array_ptr);
			while (zend_hash_has_more_elements(fe_ht) == SUCCESS) {
				zend_string *str_key;
				ulong int_key;
				zend_uchar key_type;

				key_type = zend_hash_get_current_key(fe_ht, &str_key, &int_key, 0);
				if (key_type != HASH_KEY_NON_EXISTENT &&
					(key_type == HASH_KEY_IS_LONG ||
				     zend_check_property_access(zobj, str_key TSRMLS_CC) == SUCCESS)) {
					break;
				}
				zend_hash_move_forward(fe_ht);
			}
		}
		is_empty = zend_hash_has_more_elements(fe_ht) != SUCCESS;
		zend_hash_get_pointer(fe_ht, (HashPointer*)EX_VAR((opline+2)->op1.var));
	} else {
		zend_error(E_WARNING, "Invalid argument supplied for foreach()");
		is_empty = 1;
	}

	if (IS_CV == IS_VAR && opline->extended_value & ZEND_FE_RESET_VARIABLE) {

	}
	if (is_empty) {
		ZEND_VM_JMP(EX(op_array)->opcodes+opline->op2.opline_num);
	} else {
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}
}

static int ZEND_FASTCALL  ZEND_EXIT_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
#if 0 || (IS_CV != IS_UNUSED)
	USE_OPLINE

	SAVE_OPLINE();
	if (IS_CV != IS_UNUSED) {

		zval *ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

		if (Z_TYPE_P(ptr) == IS_LONG) {
			EG(exit_status) = Z_LVAL_P(ptr);
		} else {
			zend_print_variable(ptr);
		}

	}
#endif
	zend_bailout();
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}

static int ZEND_FASTCALL  ZEND_JMP_SET_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (i_zend_is_true(value TSRMLS_CC)) {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
		if (!0) {
			zval_opt_copy_ctor(EX_VAR(opline->result.var));
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_JMP_SET_VAR_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (i_zend_is_true(value TSRMLS_CC)) {
		if (IS_CV == IS_VAR || IS_CV == IS_CV) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		} else {
			ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
			if (!0) {
				zval_opt_copy_ctor(EX_VAR(opline->result.var));
			}
		}

#if DEBUG_ZEND>=2
		printf("Conditional jmp to %d\n", opline->op2.opline_num);
#endif
		ZEND_VM_JMP(opline->op2.jmp_addr);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
	if (!0) {
		zval_opt_copy_ctor(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		ZVAL_COPY(EX_VAR(opline->result.var), value);
	} else {
		ZVAL_COPY_VALUE(EX_VAR(opline->result.var), value);
		if (!0) {
			zval_opt_copy_ctor(EX_VAR(opline->result.var));
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INSTANCEOF_SPEC_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr;
	zend_bool result;

	SAVE_OPLINE();
	expr = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (Z_TYPE_P(expr) == IS_OBJECT && Z_OBJ_HT_P(expr)->get_class_entry) {
		result = instanceof_function(Z_OBJCE_P(expr), Z_CE_P(EX_VAR(opline->op2.var)) TSRMLS_CC);
	} else {
		result = 0;
	}
	ZVAL_BOOL(EX_VAR(opline->result.var), result);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		opline->op2.zv TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_CV_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval *object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *property = opline->op2.zv;
	zval *value;
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_CV_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_CV == IS_VAR && !0) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = opline->op2.zv;

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_CONST TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:

	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);

	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_CV_CONST(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = opline->op2.zv;
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CONST(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CONST(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CONST(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CONST(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CONST(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CONST(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CONST(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CONST(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CONST(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CONST(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CONST(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CONST(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CONST(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CONST(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CONST(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CONST(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CONST(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CONST(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CONST(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CONST(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CONST(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CONST(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CONST(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_CV_CONST(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = opline->op2.zv;
	retval = EX_VAR(opline->result.var);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(retval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(zptr);
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(retval, zptr);
			}
		}
	}

	if (!have_get_ptr) {
		zval rv;

		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(z);
			incdec_op(z);
			ZVAL_COPY_VALUE(retval, z);
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(retval, opline);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(retval);
			}
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_CONST(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_CONST(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_CV_CONST(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = opline->op2.zv;
	retval = EX_VAR(opline->result.var);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_DUP(retval, zptr);

			incdec_op(zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval rv;
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
			zval z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			ZVAL_DUP(retval, z);
			ZVAL_DUP(&z_copy, z);
			incdec_op(&z_copy);
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, &z_copy, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_CONST(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_CONST(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CV_CONST(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *varname;
	zval *retval;
	zval tmp_varname;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	ZVAL_UNDEF(&tmp_varname);
 	if (IS_CV != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_DUP_DEREF(&tmp_varname, varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CV != IS_CONST) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		retval = zend_std_get_static_property(ce, Z_STR_P(varname), 0, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		retval = zend_hash_find(target_symbol_table, Z_STR_P(varname));
		if (retval == NULL) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = EX_VAR(opline->result.var);
					ZVAL_NULL(retval);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					retval = zend_hash_update(target_symbol_table, Z_STR_P(varname), &EG(uninitialized_zval));
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
		} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
			retval = Z_INDIRECT_P(retval);
			if (Z_TYPE_P(retval) == IS_UNDEF) {
				switch (type) {
					case BP_VAR_R:
					case BP_VAR_UNSET:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_IS:
						retval = EX_VAR(opline->result.var);
						ZVAL_NULL(retval);
						break;
					case BP_VAR_RW:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_W:
						ZVAL_NULL(retval);
						break;
					EMPTY_SWITCH_DEFAULT_CASE()
				}
			}
		}
		if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) == ZEND_FETCH_STATIC) {
			zval_update_constant(retval, (void*) 1 TSRMLS_CC);
		} else if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) != ZEND_FETCH_GLOBAL_LOCK) {

		}
	}

	if (IS_CV != IS_CONST) {
		zval_dtor(&tmp_varname);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY(EX_VAR(opline->result.var), retval);
	} else {
		if (/*type == BP_VAR_W &&*/ (opline->extended_value & ZEND_FETCH_MAKE_REF)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
		}
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_CONST(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_CONST(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_CONST(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		return zend_fetch_var_address_helper_SPEC_CV_CONST(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		return zend_fetch_var_address_helper_SPEC_CV_CONST(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_CONST(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_CONST(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);

	if (IS_CV != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (EXPECTED(opline->extended_value == 0)) {
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);
	} else {
		zend_fetch_dimension_address_W_ref(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);
	}

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_RW(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read_IS(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zend_free_op free_op1;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}


	} else {
		if (IS_CONST == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);


	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_UNSET(EX_VAR(opline->result.var), container, opline->op2.zv, IS_CONST TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_CV_CONST(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_CV_CONST(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = opline->op2.zv;

	container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, (opline->extended_value & ZEND_FETCH_MAKE_REF) != 0 TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = opline->op2.zv;
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_RW, 0 TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_deref_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset  = opline->op2.zv;

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;

		SAVE_OPLINE();
		property = opline->op2.zv;
		container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, 0 TSRMLS_CC);

		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_CV_CONST(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container, *property, *retval_ptr;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	property = opline->op2.zv;

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_UNSET, 0 TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object;
	zval *property_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	property_name = opline->op2.zv;

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);


	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (UNEXPECTED(Z_ISREF_P(object_ptr)) && Z_TYPE_P(Z_REFVAL_P(object_ptr)) == IS_OBJECT) {
		object_ptr = Z_REFVAL_P(object_ptr);
	}
	if (Z_TYPE_P(object_ptr) == IS_OBJECT) {

		zval *property_name = opline->op2.zv;

		zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);

	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = opline->op2.zv;
		zval *variable_ptr;

		zend_fetch_dimension_address_W(EX_VAR((opline+1)->op2.var), object_ptr, dim, IS_CONST TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
			zend_assign_to_string_offset(variable_ptr, value, (opline+1)->op1_type, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
		} else if (UNEXPECTED(variable_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
			FREE_OP_VAR_PTR(free_op_data2);
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(EX_VAR(opline->result.var), value);
			}
			FREE_OP_VAR_PTR(free_op_data2);
		}
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = opline->op2.zv;
	variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
		zend_assign_to_string_offset(variable_ptr, value, IS_CONST, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
	} else if (IS_CV == IS_VAR && UNEXPECTED(variable_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		if (IS_CONST == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
		} else if (IS_CONST == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}

	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;

	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = opline->op2.zv;

	if (IS_CONST != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_CONST != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_CONST == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_CONST == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
				 opline->op2.zv TSRMLS_CC));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_CV == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_CV == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CONST != IS_UNUSED) {

		zval *offset = opline->op2.zv;
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_CONST != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;

	zend_bool tmp_is_dup = 0;

	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
	    ZVAL_COPY_VALUE(&tmp, EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->op1.var));
		zval_ptr_dtor(&tmp);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_DUP(&tmp, varname);
		convert_to_string(&tmp);
		varname = &tmp;
		tmp_is_dup = 1;
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		ZVAL_COPY(&tmp, varname);
		varname = &tmp;
	}

	if (IS_CONST != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_CONST == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_CV != IS_CONST && tmp_is_dup) {
						zval_dtor(&tmp);
					} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
						zval_ptr_dtor(&tmp);
					}

					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		zend_std_unset_static_property(ce, Z_STR_P(varname), ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_hash_del_ind(target_symbol_table, Z_STR_P(varname));
	}

	if (IS_CV != IS_CONST && tmp_is_dup) {
		zval_dtor(&tmp);
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		zval_ptr_dtor(&tmp);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV != IS_UNUSED) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = opline->op2.zv;

container_again:
	switch (Z_TYPE_P(container)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(container);
offset_again:
			switch (Z_TYPE_P(offset)) {
				case IS_DOUBLE:
					hval = zend_dval_to_lval(Z_DVAL_P(offset));
					zend_hash_index_del(ht, hval);
					break;
				case IS_RESOURCE:
				case IS_BOOL:
				case IS_LONG:
					hval = Z_LVAL_P(offset);
					zend_hash_index_del(ht, hval);
					break;
				case IS_STRING:
					if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
						if (Z_REFCOUNTED_P(offset)) Z_ADDREF_P(offset);
					}
					if (IS_CONST != IS_CONST) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
					}
					if (ht == &EG(symbol_table).ht) {
						zend_delete_global_variable(Z_STR_P(offset) TSRMLS_CC);
					} else {
						zend_hash_del(ht, Z_STR_P(offset));
					}
					if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
num_index_dim:
					zend_hash_index_del(ht, hval);
					if (IS_CONST == IS_CV || IS_CONST == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
				case IS_NULL:
					zend_hash_del(ht, STR_EMPTY_ALLOC());
					break;
				case IS_REFERENCE:
					offset = Z_REFVAL_P(offset);
					goto offset_again;
					break;
				default:
					zend_error(E_WARNING, "Illegal offset type in unset");
					break;
			}

			break;
		}
		case IS_OBJECT:
			if (UNEXPECTED(Z_OBJ_HT_P(container)->unset_dimension == NULL)) {
				zend_error_noreturn(E_ERROR, "Cannot use object as array");
			}
//???			if (IS_CONST == IS_CONST) {
//???				zval_copy_ctor(offset);
//???			}
			Z_OBJ_HT_P(container)->unset_dimension(container, offset TSRMLS_CC);

			break;
		case IS_STRING:
		case IS_STR_OFFSET:
			zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
			ZEND_VM_CONTINUE(); /* bailed out before */
		case IS_REFERENCE:
			container = Z_REFVAL_P(container);
			goto container_again;
			break;
		default:

			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && Z_TYPE_P(container) == IS_STR_OFFSET) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
	}
	offset = opline->op2.zv;

	ZVAL_DEREF(container);
	if (Z_TYPE_P(container) == IS_OBJECT) {
		if (Z_OBJ_HT_P(container)->unset_property) {
			Z_OBJ_HT_P(container)->unset_property(container, offset, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
		} else {
			zend_error(E_NOTICE, "Trying to unset property of non-object");
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_CONST == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_UNDEF) {
			value = EX_VAR(opline->op1.var);
			ZVAL_DEREF(value);
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_DUP(&tmp, varname);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_CONST != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_CONST == IS_CONST) {
				if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
					ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				} else {
					ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op2.var));
			}
			value = zend_std_get_static_property(ce, Z_STR_P(varname), 1, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if ((value = zend_hash_find(target_symbol_table, Z_STR_P(varname))) == NULL) {
				isset = 0;
			}
		}

		if (IS_CV != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_P(value) != IS_NULL) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(value TSRMLS_CC)) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	int result;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_deref_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset = opline->op2.zv;

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht = Z_ARRVAL_P(container);
		zval *value = NULL;
		zend_string *str;

isset_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				value = zend_hash_index_find(ht, hval);
				break;
			case IS_STRING:
				str = Z_STR_P(offset);
				if (IS_CONST != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(str->val, str->len+1, hval, goto num_index_prop);
				}
str_index_prop:
				value = zend_hash_find_ind(ht, str);
				break;
			case IS_NULL:
				str = STR_EMPTY_ALLOC();
				goto str_index_prop;
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto isset_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = (value != NULL && Z_TYPE_P(value) > IS_NULL);
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			result = (value == NULL || !i_zend_is_true(value TSRMLS_CC));
		}
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISSET) == 0, ((IS_CONST == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISSET) == 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		result = 0;
		if (UNEXPECTED(Z_TYPE_P(offset) != IS_LONG)) {
			if (Z_TYPE_P(offset) < IS_STRING /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_DUP(&tmp, offset);
				convert_to_long(&tmp);
				offset = &tmp;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
				if ((opline->extended_value & ZEND_ISSET) ||
				    Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else {
		result = ((opline->extended_value & ZEND_ISSET) == 0);
	}

	ZVAL_BOOL(EX_VAR(opline->result.var), result);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CONST(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CV_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_CV == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_CV == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CONST != IS_UNUSED) {

		zval *key = opline->op2.zv;

		/* Consts, temporary variables and references need copying */
		if (IS_CONST == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_CONST == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_CONST == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_CV_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data1;
	zval *object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value;
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_dtor(free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		zval_dtor(free_op2.var);
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_CV_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_CV == IS_VAR && !0) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_TMP_VAR TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:
	zval_dtor(free_op2.var);
	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);

	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_CV_TMP(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_TMP(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_TMP(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_TMP(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_TMP(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_TMP(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_TMP(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_TMP(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_TMP(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_TMP(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_TMP(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_TMP(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_TMP(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_TMP(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_TMP(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_TMP(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_TMP(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_TMP(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_TMP(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_TMP(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_TMP(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_TMP(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_TMP(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_TMP(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_CV_TMP(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(retval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(zptr);
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(retval, zptr);
			}
		}
	}

	if (!have_get_ptr) {
		zval rv;

		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(z);
			incdec_op(z);
			ZVAL_COPY_VALUE(retval, z);
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(retval, opline);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(retval);
			}
		}
	}

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_TMP(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_TMP(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_CV_TMP(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_dtor(free_op2.var);
		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_DUP(retval, zptr);

			incdec_op(zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval rv;
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
			zval z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			ZVAL_DUP(retval, z);
			ZVAL_DUP(&z_copy, z);
			incdec_op(&z_copy);
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, &z_copy, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_TMP(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_TMP(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CV != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (EXPECTED(opline->extended_value == 0)) {
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	} else {
		zend_fetch_dimension_address_W_ref(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	}
	zval_dtor(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_RW(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read_IS(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}
		zval_dtor(free_op2.var);

	} else {
		if (IS_TMP_VAR == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
		zval_dtor(free_op2.var);

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_UNSET(EX_VAR(opline->result.var), container, _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_TMP_VAR TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_CV_TMP(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_CV_TMP(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, (opline->extended_value & ZEND_FETCH_MAKE_REF) != 0 TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_RW, 0 TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_deref_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;

		SAVE_OPLINE();
		property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, 0 TSRMLS_CC);
		zval_dtor(free_op2.var);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_CV_TMP(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container, *property, *retval_ptr;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_UNSET, 0 TSRMLS_CC);
	zval_dtor(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *object;
	zval *property_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);
	zval_dtor(free_op2.var);

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (UNEXPECTED(Z_ISREF_P(object_ptr)) && Z_TYPE_P(Z_REFVAL_P(object_ptr)) == IS_OBJECT) {
		object_ptr = Z_REFVAL_P(object_ptr);
	}
	if (Z_TYPE_P(object_ptr) == IS_OBJECT) {
		zend_free_op free_op2;
		zval *property_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);
		zval_dtor(free_op2.var);
	} else {
		zend_free_op free_op2, free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		zval *variable_ptr;

		zend_fetch_dimension_address_W(EX_VAR((opline+1)->op2.var), object_ptr, dim, IS_TMP_VAR TSRMLS_CC);
		zval_dtor(free_op2.var);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
			zend_assign_to_string_offset(variable_ptr, value, (opline+1)->op1_type, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
		} else if (UNEXPECTED(variable_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
			FREE_OP_VAR_PTR(free_op_data2);
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(EX_VAR(opline->result.var), value);
			}
			FREE_OP_VAR_PTR(free_op_data2);
		}
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
		zend_assign_to_string_offset(variable_ptr, value, IS_TMP_VAR, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
	} else if (IS_CV == IS_VAR && UNEXPECTED(variable_ptr == &EG(error_zval))) {
		if (1) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		if (IS_TMP_VAR == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
		} else if (IS_TMP_VAR == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}

	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_free_op free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_TMP_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_TMP_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_TMP_VAR == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_TMP_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_dtor(free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
				 _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_dtor(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_CV == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_CV == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_TMP_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}
		zval_dtor(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV != IS_UNUSED) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

container_again:
	switch (Z_TYPE_P(container)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(container);
offset_again:
			switch (Z_TYPE_P(offset)) {
				case IS_DOUBLE:
					hval = zend_dval_to_lval(Z_DVAL_P(offset));
					zend_hash_index_del(ht, hval);
					break;
				case IS_RESOURCE:
				case IS_BOOL:
				case IS_LONG:
					hval = Z_LVAL_P(offset);
					zend_hash_index_del(ht, hval);
					break;
				case IS_STRING:
					if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
						if (Z_REFCOUNTED_P(offset)) Z_ADDREF_P(offset);
					}
					if (IS_TMP_VAR != IS_CONST) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
					}
					if (ht == &EG(symbol_table).ht) {
						zend_delete_global_variable(Z_STR_P(offset) TSRMLS_CC);
					} else {
						zend_hash_del(ht, Z_STR_P(offset));
					}
					if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
num_index_dim:
					zend_hash_index_del(ht, hval);
					if (IS_TMP_VAR == IS_CV || IS_TMP_VAR == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
				case IS_NULL:
					zend_hash_del(ht, STR_EMPTY_ALLOC());
					break;
				case IS_REFERENCE:
					offset = Z_REFVAL_P(offset);
					goto offset_again;
					break;
				default:
					zend_error(E_WARNING, "Illegal offset type in unset");
					break;
			}
			zval_dtor(free_op2.var);
			break;
		}
		case IS_OBJECT:
			if (UNEXPECTED(Z_OBJ_HT_P(container)->unset_dimension == NULL)) {
				zend_error_noreturn(E_ERROR, "Cannot use object as array");
			}
//???			if (IS_TMP_VAR == IS_CONST) {
//???				zval_copy_ctor(offset);
//???			}
			Z_OBJ_HT_P(container)->unset_dimension(container, offset TSRMLS_CC);
			zval_dtor(free_op2.var);
			break;
		case IS_STRING:
		case IS_STR_OFFSET:
			zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
			ZEND_VM_CONTINUE(); /* bailed out before */
		case IS_REFERENCE:
			container = Z_REFVAL_P(container);
			goto container_again;
			break;
		default:
			zval_dtor(free_op2.var);
			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && Z_TYPE_P(container) == IS_STR_OFFSET) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
	}
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	ZVAL_DEREF(container);
	if (Z_TYPE_P(container) == IS_OBJECT) {
		if (Z_OBJ_HT_P(container)->unset_property) {
			Z_OBJ_HT_P(container)->unset_property(container, offset, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
		} else {
			zend_error(E_NOTICE, "Trying to unset property of non-object");
		}
	}
	zval_dtor(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	int result;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_deref_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht = Z_ARRVAL_P(container);
		zval *value = NULL;
		zend_string *str;

isset_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				value = zend_hash_index_find(ht, hval);
				break;
			case IS_STRING:
				str = Z_STR_P(offset);
				if (IS_TMP_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(str->val, str->len+1, hval, goto num_index_prop);
				}
str_index_prop:
				value = zend_hash_find_ind(ht, str);
				break;
			case IS_NULL:
				str = STR_EMPTY_ALLOC();
				goto str_index_prop;
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto isset_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = (value != NULL && Z_TYPE_P(value) > IS_NULL);
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			result = (value == NULL || !i_zend_is_true(value TSRMLS_CC));
		}
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISSET) == 0, ((IS_TMP_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISSET) == 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		result = 0;
		if (UNEXPECTED(Z_TYPE_P(offset) != IS_LONG)) {
			if (Z_TYPE_P(offset) < IS_STRING /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_DUP(&tmp, offset);
				convert_to_long(&tmp);
				offset = &tmp;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
				if ((opline->extended_value & ZEND_ISSET) ||
				    Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else {
		result = ((opline->extended_value & ZEND_ISSET) == 0);
	}

	zval_dtor(free_op2.var);
	ZVAL_BOOL(EX_VAR(opline->result.var), result);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_TMP(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CV_TMP_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_CV == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_CV == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_TMP_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_tmp(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_TMP_VAR == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_TMP_VAR == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_TMP_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;

	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC);

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_CV_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data1;
	zval *object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	zval *value;
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");
		zval_ptr_dtor_nogc(free_op2.var);
		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		zval_ptr_dtor_nogc(free_op2.var);
		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_CV_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2, free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_CV == IS_VAR && !0) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_VAR TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:
	zval_ptr_dtor_nogc(free_op2.var);
	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);

	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_CV_VAR(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:
	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_VAR(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_VAR(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_VAR(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_VAR(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_VAR(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_VAR(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_VAR(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_VAR(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_VAR(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_VAR(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_VAR(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_VAR(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_VAR(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_VAR(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_VAR(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_VAR(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_VAR(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_VAR(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_VAR(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_VAR(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_VAR(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_VAR(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_VAR(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_CV_VAR(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_ptr_dtor_nogc(free_op2.var);
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(retval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(zptr);
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(retval, zptr);
			}
		}
	}

	if (!have_get_ptr) {
		zval rv;

		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(z);
			incdec_op(z);
			ZVAL_COPY_VALUE(retval, z);
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(retval, opline);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(retval);
			}
		}
	}

	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_VAR(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_VAR(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_CV_VAR(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
		zval_ptr_dtor_nogc(free_op2.var);
		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_DUP(retval, zptr);

			incdec_op(zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval rv;
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
			zval z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			ZVAL_DUP(retval, z);
			ZVAL_DUP(&z_copy, z);
			incdec_op(&z_copy);
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, &z_copy, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}

	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_VAR(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_VAR(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CV_VAR(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *varname;
	zval *retval;
	zval tmp_varname;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	ZVAL_UNDEF(&tmp_varname);
 	if (IS_CV != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_DUP_DEREF(&tmp_varname, varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CV != IS_CONST) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		retval = zend_std_get_static_property(ce, Z_STR_P(varname), 0, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		retval = zend_hash_find(target_symbol_table, Z_STR_P(varname));
		if (retval == NULL) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = EX_VAR(opline->result.var);
					ZVAL_NULL(retval);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					retval = zend_hash_update(target_symbol_table, Z_STR_P(varname), &EG(uninitialized_zval));
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
		} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
			retval = Z_INDIRECT_P(retval);
			if (Z_TYPE_P(retval) == IS_UNDEF) {
				switch (type) {
					case BP_VAR_R:
					case BP_VAR_UNSET:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_IS:
						retval = EX_VAR(opline->result.var);
						ZVAL_NULL(retval);
						break;
					case BP_VAR_RW:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_W:
						ZVAL_NULL(retval);
						break;
					EMPTY_SWITCH_DEFAULT_CASE()
				}
			}
		}
		if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) == ZEND_FETCH_STATIC) {
			zval_update_constant(retval, (void*) 1 TSRMLS_CC);
		} else if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) != ZEND_FETCH_GLOBAL_LOCK) {

		}
	}

	if (IS_CV != IS_CONST) {
		zval_dtor(&tmp_varname);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY(EX_VAR(opline->result.var), retval);
	} else {
		if (/*type == BP_VAR_W &&*/ (opline->extended_value & ZEND_FETCH_MAKE_REF)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
		}
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_VAR(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_VAR(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_VAR(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		return zend_fetch_var_address_helper_SPEC_CV_VAR(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		return zend_fetch_var_address_helper_SPEC_CV_VAR(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_VAR(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_VAR(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_CV != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (EXPECTED(opline->extended_value == 0)) {
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	} else {
		zend_fetch_dimension_address_W_ref(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	}
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_RW(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read_IS(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zend_free_op free_op1, free_op2;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}
		zval_ptr_dtor_nogc(free_op2.var);

	} else {
		if (IS_VAR == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op2.var);

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_UNSET(EX_VAR(opline->result.var), container, _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC), IS_VAR TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_CV_VAR(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_CV_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, (opline->extended_value & ZEND_FETCH_MAKE_REF) != 0 TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_RW, 0 TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zend_free_op free_op2;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_deref_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}

	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1, free_op2;
		zval *property;

		SAVE_OPLINE();
		property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, 0 TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op2.var);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_CV_VAR(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1, free_op2;
	zval *container, *property, *retval_ptr;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_UNSET, 0 TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);
	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *object;
	zval *property_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);
	zval_ptr_dtor_nogc(free_op2.var);

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (UNEXPECTED(Z_ISREF_P(object_ptr)) && Z_TYPE_P(Z_REFVAL_P(object_ptr)) == IS_OBJECT) {
		object_ptr = Z_REFVAL_P(object_ptr);
	}
	if (Z_TYPE_P(object_ptr) == IS_OBJECT) {
		zend_free_op free_op2;
		zval *property_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op2.var);
	} else {
		zend_free_op free_op2, free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_var_deref(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		zval *variable_ptr;

		zend_fetch_dimension_address_W(EX_VAR((opline+1)->op2.var), object_ptr, dim, IS_VAR TSRMLS_CC);
		zval_ptr_dtor_nogc(free_op2.var);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
			zend_assign_to_string_offset(variable_ptr, value, (opline+1)->op1_type, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
		} else if (UNEXPECTED(variable_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
			FREE_OP_VAR_PTR(free_op_data2);
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(EX_VAR(opline->result.var), value);
			}
			FREE_OP_VAR_PTR(free_op_data2);
		}
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
	variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
		zend_assign_to_string_offset(variable_ptr, value, IS_VAR, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
	} else if (IS_CV == IS_VAR && UNEXPECTED(variable_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		if (IS_VAR == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
		} else if (IS_VAR == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}

	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */
 	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *variable_ptr;
	zval *value_ptr;

	SAVE_OPLINE();
	value_ptr = _get_zval_ptr_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR == IS_VAR &&
	    opline->extended_value == ZEND_RETURNS_FUNCTION &&
	    !(Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF) &&
	    !Z_ISREF_P(value_ptr)) {
		if (!(free_op2.var != NULL)) {
			PZVAL_LOCK(value_ptr); /* undo the effect of get_zval_ptr_ptr() */
		}
		zend_error(E_STRICT, "Only variables should be assigned by reference");
		if (UNEXPECTED(EG(exception) != NULL)) {
			if (free_op2.var) {zval_ptr_dtor_nogc(free_op2.var);};
			HANDLE_EXCEPTION();
		}
		return ZEND_ASSIGN_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		if (!(free_op2.var != NULL)) {
			PZVAL_LOCK(value_ptr);
		}
	}

	variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR &&
	    UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT) &&
	    UNEXPECTED(!Z_ISREF_P(variable_ptr))) {
		zend_error_noreturn(E_ERROR, "Cannot assign by reference to overloaded object");
	}
	if ((IS_VAR == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) ||
	    (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET))) {
		zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets nor overloaded objects");
	}
	if ((IS_CV == IS_VAR && UNEXPECTED(variable_ptr == &EG(error_zval))) ||
	    (IS_VAR == IS_VAR && UNEXPECTED(value_ptr == &EG(error_zval)))) {
		variable_ptr = &EG(uninitialized_zval);
	} else {
		zend_assign_to_variable_reference(variable_ptr, value_ptr TSRMLS_CC);
	}

	if (IS_VAR == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		if (!(free_op2.var != NULL)) {
			Z_DELREF_P(variable_ptr);
		}
	}

	if (RETURN_VALUE_USED(opline)) {
		ZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);
	}

	if (free_op2.var) {zval_ptr_dtor_nogc(free_op2.var);};

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;
	zend_free_op free_op2;
	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (IS_VAR != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_VAR != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_VAR == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_VAR == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {
			zval_ptr_dtor_nogc(free_op2.var);
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;

	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
				 _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC) TSRMLS_CC));

	zval_ptr_dtor_nogc(free_op2.var);
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_CV == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_CV == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}
		zval_ptr_dtor_nogc(free_op2.var);
	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;

	zend_bool tmp_is_dup = 0;

	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
	    ZVAL_COPY_VALUE(&tmp, EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->op1.var));
		zval_ptr_dtor(&tmp);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_DUP(&tmp, varname);
		convert_to_string(&tmp);
		varname = &tmp;
		tmp_is_dup = 1;
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		ZVAL_COPY(&tmp, varname);
		varname = &tmp;
	}

	if (IS_VAR != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_VAR == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_CV != IS_CONST && tmp_is_dup) {
						zval_dtor(&tmp);
					} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
						zval_ptr_dtor(&tmp);
					}

					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		zend_std_unset_static_property(ce, Z_STR_P(varname), ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_hash_del_ind(target_symbol_table, Z_STR_P(varname));
	}

	if (IS_CV != IS_CONST && tmp_is_dup) {
		zval_dtor(&tmp);
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		zval_ptr_dtor(&tmp);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV != IS_UNUSED) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

container_again:
	switch (Z_TYPE_P(container)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(container);
offset_again:
			switch (Z_TYPE_P(offset)) {
				case IS_DOUBLE:
					hval = zend_dval_to_lval(Z_DVAL_P(offset));
					zend_hash_index_del(ht, hval);
					break;
				case IS_RESOURCE:
				case IS_BOOL:
				case IS_LONG:
					hval = Z_LVAL_P(offset);
					zend_hash_index_del(ht, hval);
					break;
				case IS_STRING:
					if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
						if (Z_REFCOUNTED_P(offset)) Z_ADDREF_P(offset);
					}
					if (IS_VAR != IS_CONST) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
					}
					if (ht == &EG(symbol_table).ht) {
						zend_delete_global_variable(Z_STR_P(offset) TSRMLS_CC);
					} else {
						zend_hash_del(ht, Z_STR_P(offset));
					}
					if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
num_index_dim:
					zend_hash_index_del(ht, hval);
					if (IS_VAR == IS_CV || IS_VAR == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
				case IS_NULL:
					zend_hash_del(ht, STR_EMPTY_ALLOC());
					break;
				case IS_REFERENCE:
					offset = Z_REFVAL_P(offset);
					goto offset_again;
					break;
				default:
					zend_error(E_WARNING, "Illegal offset type in unset");
					break;
			}
			zval_ptr_dtor_nogc(free_op2.var);
			break;
		}
		case IS_OBJECT:
			if (UNEXPECTED(Z_OBJ_HT_P(container)->unset_dimension == NULL)) {
				zend_error_noreturn(E_ERROR, "Cannot use object as array");
			}
//???			if (IS_VAR == IS_CONST) {
//???				zval_copy_ctor(offset);
//???			}
			Z_OBJ_HT_P(container)->unset_dimension(container, offset TSRMLS_CC);
			zval_ptr_dtor_nogc(free_op2.var);
			break;
		case IS_STRING:
		case IS_STR_OFFSET:
			zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
			ZEND_VM_CONTINUE(); /* bailed out before */
		case IS_REFERENCE:
			container = Z_REFVAL_P(container);
			goto container_again;
			break;
		default:
			zval_ptr_dtor_nogc(free_op2.var);
			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && Z_TYPE_P(container) == IS_STR_OFFSET) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
	}
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	ZVAL_DEREF(container);
	if (Z_TYPE_P(container) == IS_OBJECT) {
		if (Z_OBJ_HT_P(container)->unset_property) {
			Z_OBJ_HT_P(container)->unset_property(container, offset, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
		} else {
			zend_error(E_NOTICE, "Trying to unset property of non-object");
		}
	}
	zval_ptr_dtor_nogc(free_op2.var);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_VAR == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_UNDEF) {
			value = EX_VAR(opline->op1.var);
			ZVAL_DEREF(value);
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_DUP(&tmp, varname);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_VAR != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_VAR == IS_CONST) {
				if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
					ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				} else {
					ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op2.var));
			}
			value = zend_std_get_static_property(ce, Z_STR_P(varname), 1, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if ((value = zend_hash_find(target_symbol_table, Z_STR_P(varname))) == NULL) {
				isset = 0;
			}
		}

		if (IS_CV != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_P(value) != IS_NULL) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(value TSRMLS_CC)) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op2;
	zval *container;
	int result;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_deref_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht = Z_ARRVAL_P(container);
		zval *value = NULL;
		zend_string *str;

isset_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				value = zend_hash_index_find(ht, hval);
				break;
			case IS_STRING:
				str = Z_STR_P(offset);
				if (IS_VAR != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(str->val, str->len+1, hval, goto num_index_prop);
				}
str_index_prop:
				value = zend_hash_find_ind(ht, str);
				break;
			case IS_NULL:
				str = STR_EMPTY_ALLOC();
				goto str_index_prop;
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto isset_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = (value != NULL && Z_TYPE_P(value) > IS_NULL);
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			result = (value == NULL || !i_zend_is_true(value TSRMLS_CC));
		}
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISSET) == 0, ((IS_VAR == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISSET) == 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		result = 0;
		if (UNEXPECTED(Z_TYPE_P(offset) != IS_LONG)) {
			if (Z_TYPE_P(offset) < IS_STRING /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_DUP(&tmp, offset);
				convert_to_long(&tmp);
				offset = &tmp;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
				if ((opline->extended_value & ZEND_ISSET) ||
				    Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else {
		result = ((opline->extended_value & ZEND_ISSET) == 0);
	}

	zval_ptr_dtor_nogc(free_op2.var);
	ZVAL_BOOL(EX_VAR(opline->result.var), result);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_VAR(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CV_VAR_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_CV == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_CV == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_VAR != IS_UNUSED) {
		zend_free_op free_op2;
		zval *key = _get_zval_ptr_var(opline->op2.var, execute_data, &free_op2 TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_VAR == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_VAR == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));
			zval_ptr_dtor_nogc(free_op2.var);
		} else {
			if (IS_VAR == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval *object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *property = NULL;
	zval *value;
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_UNUSED == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_UNUSED == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_UNUSED == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_CV == IS_VAR && !0) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = NULL;

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_UNUSED TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:

	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);

	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_CV_UNUSED(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = NULL;
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_UNUSED(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_UNUSED(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_UNUSED(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_UNUSED(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_UNUSED(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_UNUSED(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_UNUSED(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_UNUSED(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_UNUSED(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_UNUSED(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_UNUSED(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_UNUSED(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_UNUSED(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_fetch_var_address_helper_SPEC_CV_UNUSED(int type, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *varname;
	zval *retval;
	zval tmp_varname;
	HashTable *target_symbol_table;

	SAVE_OPLINE();
	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	ZVAL_UNDEF(&tmp_varname);
 	if (IS_CV != IS_CONST && UNEXPECTED(Z_TYPE_P(varname) != IS_STRING)) {
		ZVAL_DUP_DEREF(&tmp_varname, varname);
		convert_to_string(&tmp_varname);
		varname = &tmp_varname;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(ce == NULL)) {
					if (IS_CV != IS_CONST) {
						zval_dtor(&tmp_varname);
					}

					CHECK_EXCEPTION();
					ZEND_VM_NEXT_OPCODE();
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		retval = zend_std_get_static_property(ce, Z_STR_P(varname), 0, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);

	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		retval = zend_hash_find(target_symbol_table, Z_STR_P(varname));
		if (retval == NULL) {
			switch (type) {
				case BP_VAR_R:
				case BP_VAR_UNSET:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_IS:
					retval = EX_VAR(opline->result.var);
					ZVAL_NULL(retval);
					break;
				case BP_VAR_RW:
					zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
					/* break missing intentionally */
				case BP_VAR_W:
					retval = zend_hash_update(target_symbol_table, Z_STR_P(varname), &EG(uninitialized_zval));
					break;
				EMPTY_SWITCH_DEFAULT_CASE()
			}
		/* GLOBAL or $$name variable may be an INDIRECT pointer to CV */
		} else if (Z_TYPE_P(retval) == IS_INDIRECT) {
			retval = Z_INDIRECT_P(retval);
			if (Z_TYPE_P(retval) == IS_UNDEF) {
				switch (type) {
					case BP_VAR_R:
					case BP_VAR_UNSET:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_IS:
						retval = EX_VAR(opline->result.var);
						ZVAL_NULL(retval);
						break;
					case BP_VAR_RW:
						zend_error(E_NOTICE,"Undefined variable: %s", Z_STRVAL_P(varname));
						/* break missing intentionally */
					case BP_VAR_W:
						ZVAL_NULL(retval);
						break;
					EMPTY_SWITCH_DEFAULT_CASE()
				}
			}
		}
		if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) == ZEND_FETCH_STATIC) {
			zval_update_constant(retval, (void*) 1 TSRMLS_CC);
		} else if ((opline->extended_value & ZEND_FETCH_TYPE_MASK) != ZEND_FETCH_GLOBAL_LOCK) {

		}
	}

	if (IS_CV != IS_CONST) {
		zval_dtor(&tmp_varname);
	}

	ZEND_ASSERT(retval != NULL);
	if (type == BP_VAR_R || type == BP_VAR_IS) {
		ZVAL_COPY(EX_VAR(opline->result.var), retval);
	} else {
		if (/*type == BP_VAR_W &&*/ (opline->extended_value & ZEND_FETCH_MAKE_REF)) {
			SEPARATE_ZVAL_TO_MAKE_IS_REF(retval);
		}
		ZVAL_INDIRECT(EX_VAR(opline->result.var), retval);
	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_RW, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		return zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_W, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		return zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_R, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_UNSET, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_var_address_helper_SPEC_CV_UNUSED(BP_VAR_IS, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (EXPECTED(opline->extended_value == 0)) {
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, NULL, IS_UNUSED TSRMLS_CC);
	} else {
		zend_fetch_dimension_address_W_ref(EX_VAR(opline->result.var), container, NULL, IS_UNUSED TSRMLS_CC);
	}

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_RW(EX_VAR(opline->result.var), container, NULL, IS_UNUSED TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zend_free_op free_op1;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, NULL, IS_UNUSED TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}


	} else {
		if (IS_UNUSED == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, NULL, IS_UNUSED TSRMLS_CC);


	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (UNEXPECTED(Z_ISREF_P(object_ptr)) && Z_TYPE_P(Z_REFVAL_P(object_ptr)) == IS_OBJECT) {
		object_ptr = Z_REFVAL_P(object_ptr);
	}
	if (Z_TYPE_P(object_ptr) == IS_OBJECT) {

		zval *property_name = NULL;

		zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_UNUSED == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);

	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = NULL;
		zval *variable_ptr;

		zend_fetch_dimension_address_W(EX_VAR((opline+1)->op2.var), object_ptr, dim, IS_UNUSED TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
			zend_assign_to_string_offset(variable_ptr, value, (opline+1)->op1_type, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
		} else if (UNEXPECTED(variable_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
			FREE_OP_VAR_PTR(free_op_data2);
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(EX_VAR(opline->result.var), value);
			}
			FREE_OP_VAR_PTR(free_op_data2);
		}
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_CV == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_CV == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_UNUSED != IS_UNUSED) {

		zval *offset = NULL;
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_UNUSED != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval tmp, *varname;
	HashTable *target_symbol_table;

	zend_bool tmp_is_dup = 0;

	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
	    ZVAL_COPY_VALUE(&tmp, EX_VAR(opline->op1.var));
		ZVAL_UNDEF(EX_VAR(opline->op1.var));
		zval_ptr_dtor(&tmp);
		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	varname = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
		ZVAL_DUP(&tmp, varname);
		convert_to_string(&tmp);
		varname = &tmp;
		tmp_is_dup = 1;
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		ZVAL_COPY(&tmp, varname);
		varname = &tmp;
	}

	if (IS_UNUSED != IS_UNUSED) {
		zend_class_entry *ce;

		if (IS_UNUSED == IS_CONST) {
			if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
				ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
			} else {
				ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
				if (UNEXPECTED(EG(exception) != NULL)) {
					if (IS_CV != IS_CONST && tmp_is_dup) {
						zval_dtor(&tmp);
					} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
						zval_ptr_dtor(&tmp);
					}

					HANDLE_EXCEPTION();
				}
				if (UNEXPECTED(ce == NULL)) {
					zend_error_noreturn(E_ERROR, "Class '%s' not found", Z_STRVAL_P(opline->op2.zv));
				}
				CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
			}
		} else {
			ce = Z_CE_P(EX_VAR(opline->op2.var));
		}
		zend_std_unset_static_property(ce, Z_STR_P(varname), ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
	} else {
		target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
		zend_hash_del_ind(target_symbol_table, Z_STR_P(varname));
	}

	if (IS_CV != IS_CONST && tmp_is_dup) {
		zval_dtor(&tmp);
	} else if (IS_CV == IS_VAR || IS_CV == IS_CV) {
		zval_ptr_dtor(&tmp);
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *value;
	zend_bool isset = 1;

	SAVE_OPLINE();
	if (IS_CV == IS_CV &&
	    IS_UNUSED == IS_UNUSED &&
	    (opline->extended_value & ZEND_QUICK_SET)) {
		if (Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_UNDEF) {
			value = EX_VAR(opline->op1.var);
			ZVAL_DEREF(value);
		} else {
			isset = 0;
		}
	} else {
		HashTable *target_symbol_table;

		zval tmp, *varname = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV != IS_CONST && Z_TYPE_P(varname) != IS_STRING) {
			ZVAL_DUP(&tmp, varname);
			convert_to_string(&tmp);
			varname = &tmp;
		}

		if (IS_UNUSED != IS_UNUSED) {
			zend_class_entry *ce;

			if (IS_UNUSED == IS_CONST) {
				if (CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv))) {
					ce = CACHED_PTR(Z_CACHE_SLOT_P(opline->op2.zv));
				} else {
					ce = zend_fetch_class_by_name(Z_STR_P(opline->op2.zv), opline->op2.zv + 1, 0 TSRMLS_CC);
					if (UNEXPECTED(ce == NULL)) {
						CHECK_EXCEPTION();
						ZEND_VM_NEXT_OPCODE();
					}
					CACHE_PTR(Z_CACHE_SLOT_P(opline->op2.zv), ce);
				}
			} else {
				ce = Z_CE_P(EX_VAR(opline->op2.var));
			}
			value = zend_std_get_static_property(ce, Z_STR_P(varname), 1, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(varname) : -1) TSRMLS_CC);
			if (!value) {
				isset = 0;
			}
		} else {
			target_symbol_table = zend_get_target_symbol_table(opline->extended_value & ZEND_FETCH_TYPE_MASK TSRMLS_CC);
			if ((value = zend_hash_find(target_symbol_table, Z_STR_P(varname))) == NULL) {
				isset = 0;
			}
		}

		if (IS_CV != IS_CONST && varname == &tmp) {
			zval_dtor(&tmp);
		}

	}

	if (opline->extended_value & ZEND_ISSET) {
		if (isset && Z_TYPE_P(value) != IS_NULL) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
		if (!isset || !i_zend_is_true(value TSRMLS_CC)) {
			ZVAL_BOOL(EX_VAR(opline->result.var), 1);
		} else {
			ZVAL_BOOL(EX_VAR(opline->result.var), 0);
		}
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CV_UNUSED_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_CV == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_CV == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_UNUSED != IS_UNUSED) {

		zval *key = NULL;

		/* Consts, temporary variables and references need copying */
		if (IS_UNUSED == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_UNUSED == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_UNUSED == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL  ZEND_ADD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_add_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SUB_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_sub_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MUL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mul_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_DIV_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_div_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_MOD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	fast_mod_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_left_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_SR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	shift_right_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CONCAT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	concat_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	is_identical_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	is_identical_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);
	Z_LVAL_P(result) = !Z_LVAL_P(result);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_not_equal_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_is_smaller_or_equal_function(result,
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_OR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_or_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_AND_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_and_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BW_XOR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	bitwise_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE


	SAVE_OPLINE();
	boolean_xor_function(EX_VAR(opline->result.var),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
		_get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_obj_helper_SPEC_CV_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data1;
	zval *object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	zval *property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	zval *value;
	int have_get_ptr = 0;

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	object = make_real_object(object TSRMLS_CC);

	value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to assign property of non-object");

		FREE_OP(free_op_data1);

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		/* here we are sure we are dealing with an object */
		if (opline->extended_value == ZEND_ASSIGN_OBJ
			&& Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
			zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			if (zptr != NULL) { 			/* NULL means no success in getting PTR */
				SEPARATE_ZVAL_IF_NOT_REF(zptr);

				have_get_ptr = 1;
				binary_op(zptr, zptr, value TSRMLS_CC);
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), zptr);
				}
			}
		}

		if (!have_get_ptr) {
			zval *z = NULL;
			zval rv;

			if (opline->extended_value == ZEND_ASSIGN_OBJ) {
				if (Z_OBJ_HT_P(object)->read_property) {
					z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
				}
			} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
				if (Z_OBJ_HT_P(object)->read_dimension) {
					z = Z_OBJ_HT_P(object)->read_dimension(object, property, BP_VAR_R, &rv TSRMLS_CC);
				}
			}
			if (z) {
				if (Z_TYPE_P(z) == IS_OBJECT && Z_OBJ_HT_P(z)->get) {
					zval rv;
					zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

					if (Z_REFCOUNT_P(z) == 0) {
						zval_dtor(z);
					}
					ZVAL_COPY_VALUE(z, value);
				}
//???				if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
				SEPARATE_ZVAL_IF_NOT_REF(z);
				binary_op(z, z, value TSRMLS_CC);
				if (opline->extended_value == ZEND_ASSIGN_OBJ) {
					Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
				} else /* if (opline->extended_value == ZEND_ASSIGN_DIM) */ {
					Z_OBJ_HT_P(object)->write_dimension(object, property, z TSRMLS_CC);
				}
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_COPY(EX_VAR(opline->result.var), z);
				}
				zval_ptr_dtor(z);
			} else {
				zend_error(E_WARNING, "Attempt to assign property of non-object");
				if (RETURN_VALUE_USED(opline)) {
					ZVAL_NULL(EX_VAR(opline->result.var));
				}
			}
		}

		FREE_OP(free_op_data1);
	}

	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_dim_helper_SPEC_CV_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op_data2, free_op_data1;
	zval *var_ptr;
	zval *value, *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	} else if (UNEXPECTED(Z_TYPE_P(container) == IS_OBJECT)) {
		if (IS_CV == IS_VAR && !0) {
			Z_ADDREF_P(container);  /* undo the effect of get_obj_zval_ptr_ptr() */
		}
		return zend_binary_assign_op_obj_helper_SPEC_CV_CV(binary_op, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else {
		zval *dim = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		zend_fetch_dimension_address_RW(EX_VAR((opline+1)->op2.var), container, dim, IS_CV TSRMLS_CC);
		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		var_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
	}

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_dim_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_dim_exit:

	FREE_OP(free_op_data1);
	FREE_OP_VAR_PTR(free_op_data2);

	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_binary_assign_op_helper_SPEC_CV_CV(int (*binary_op)(zval *result, zval *op1, zval *op2 TSRMLS_DC), ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *var_ptr;
	zval *value;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	var_ptr = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(var_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use assign-op operators with overloaded objects nor string offsets");
	}

	if (IS_CV == IS_VAR && UNEXPECTED(var_ptr == &EG(error_zval))) {
		if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
		goto assign_op_exit;
	}

	SEPARATE_ZVAL_IF_NOT_REF(var_ptr);
	ZVAL_DEREF(var_ptr);

	if (UNEXPECTED(Z_TYPE_P(var_ptr) == IS_OBJECT) &&
	    UNEXPECTED(Z_OBJ_HANDLER_P(var_ptr, get) && Z_OBJ_HANDLER_P(var_ptr, set))) {
		/* proxy object */
		zval rv;
		zval *objval = Z_OBJ_HANDLER_P(var_ptr, get)(var_ptr, &rv TSRMLS_CC);
		Z_ADDREF_P(objval);
		binary_op(objval, objval, value TSRMLS_CC);
		Z_OBJ_HANDLER_P(var_ptr, set)(var_ptr, objval TSRMLS_CC);
		zval_ptr_dtor(objval);
	} else {
		binary_op(var_ptr, var_ptr, value TSRMLS_CC);
	}

	if (UNEXPECTED(RETURN_VALUE_USED(opline))) {
		ZVAL_COPY(EX_VAR(opline->result.var), var_ptr);
	}

assign_op_exit:


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_ADD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CV(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CV(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CV(add_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SUB_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CV(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CV(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CV(sub_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MUL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CV(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CV(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CV(mul_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIV_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CV(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CV(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CV(div_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_MOD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CV(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CV(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CV(mod_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CV(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CV(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CV(shift_left_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CV(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CV(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CV(shift_right_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_CONCAT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CV(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CV(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CV(concat_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_OR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CV(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CV(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CV(bitwise_or_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_AND_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CV(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CV(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CV(bitwise_and_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_ASSIGN_BW_XOR_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	if (EXPECTED(opline->extended_value == 0)) {
		return zend_binary_assign_op_helper_SPEC_CV_CV(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) {
		return zend_binary_assign_op_dim_helper_SPEC_CV_CV(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else /* if (EXPECTED(opline->extended_value == ZEND_ASSIGN_DIM)) */ {
		return zend_binary_assign_op_obj_helper_SPEC_CV_CV(bitwise_xor_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL zend_pre_incdec_property_helper_SPEC_CV_CV(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(retval);
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			have_get_ptr = 1;
			incdec_op(zptr);
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(retval, zptr);
			}
		}
	}

	if (!have_get_ptr) {
		zval rv;

		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			SEPARATE_ZVAL_IF_NOT_REF(z);
			incdec_op(z);
			ZVAL_COPY_VALUE(retval, z);
			Z_OBJ_HT_P(object)->write_property(object, property, z, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			SELECTIVE_PZVAL_LOCK(retval, opline);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(retval);
			}
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_CV(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_PRE_DEC_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_pre_incdec_property_helper_SPEC_CV_CV(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL zend_post_incdec_property_helper_SPEC_CV_CV(incdec_t incdec_op, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object;
	zval *property;
	zval *retval;
	int have_get_ptr = 0;

	SAVE_OPLINE();
	object = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	retval = EX_VAR(opline->result.var);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot increment/decrement overloaded objects nor string offsets");
	}

	object = make_real_object(object TSRMLS_CC); /* this should modify object only if it's empty */

	if (UNEXPECTED(Z_TYPE_P(object) != IS_OBJECT)) {
		zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");

		ZVAL_NULL(retval);

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	}

	/* here we are sure we are dealing with an object */

	if (Z_OBJ_HT_P(object)->get_property_ptr_ptr) {
		zval *zptr = Z_OBJ_HT_P(object)->get_property_ptr_ptr(object, property, BP_VAR_RW, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
		if (zptr != NULL) { 			/* NULL means no success in getting PTR */
			have_get_ptr = 1;
			SEPARATE_ZVAL_IF_NOT_REF(zptr);

			ZVAL_DUP(retval, zptr);

			incdec_op(zptr);

		}
	}

	if (!have_get_ptr) {
		if (Z_OBJ_HT_P(object)->read_property && Z_OBJ_HT_P(object)->write_property) {
			zval rv;
			zval *z = Z_OBJ_HT_P(object)->read_property(object, property, BP_VAR_R, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), &rv TSRMLS_CC);
			zval z_copy;

			if (UNEXPECTED(Z_TYPE_P(z) == IS_OBJECT) && Z_OBJ_HT_P(z)->get) {
				zval rv;
				zval *value = Z_OBJ_HT_P(z)->get(z, &rv TSRMLS_CC);

				if (Z_REFCOUNT_P(z) == 0) {
					zval_dtor(z);
				}
				ZVAL_COPY_VALUE(z, value);
			}
			ZVAL_DUP(retval, z);
			ZVAL_DUP(&z_copy, z);
			incdec_op(&z_copy);
			if (Z_REFCOUNTED_P(z)) Z_ADDREF_P(z);
			Z_OBJ_HT_P(object)->write_property(object, property, &z_copy, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1) TSRMLS_CC);
			zval_ptr_dtor(&z_copy);
			zval_ptr_dtor(z);
		} else {
			zend_error(E_WARNING, "Attempt to increment/decrement property of non-object");
			ZVAL_NULL(retval);
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_CV(increment_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_POST_DEC_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_post_incdec_property_helper_SPEC_CV_CV(decrement_function, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);

	if (IS_CV != IS_VAR || !(opline->extended_value & ZEND_FETCH_ADD_LOCK)) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (EXPECTED(opline->extended_value == 0)) {
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);
	} else {
		zend_fetch_dimension_address_W_ref(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);
	}

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_RW(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	zend_fetch_dimension_address_read_IS(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;
	zend_free_op free_op1;

	SAVE_OPLINE();

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(container == NULL)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
		}
		zend_fetch_dimension_address_W(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);
		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}


	} else {
		if (IS_CV == IS_UNUSED) {
			zend_error_noreturn(E_ERROR, "Cannot use [] for reading");
		}
		container = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		zend_fetch_dimension_address_read_R(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);


	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_fetch_dimension_address_UNSET(EX_VAR(opline->result.var), container, _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC), IS_CV TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_fetch_property_address_read_helper_SPEC_CV_CV(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		zend_error(E_NOTICE, "Trying to get property of non-object");
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_R, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_fetch_property_address_read_helper_SPEC_CV_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}

	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, (opline->extended_value & ZEND_FETCH_MAKE_REF) != 0 TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *property;
	zval *container;

	SAVE_OPLINE();
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	container = _get_zval_ptr_cv_BP_VAR_RW(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_RW, 0 TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;

	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_deref_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset  = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (UNEXPECTED(Z_TYPE_P(container) != IS_OBJECT) ||
	    UNEXPECTED(Z_OBJ_HT_P(container)->read_property == NULL)) {
		ZVAL_NULL(EX_VAR(opline->result.var));
	} else {
		zval *retval;

		/* here we are sure we are dealing with an object */
		retval = Z_OBJ_HT_P(container)->read_property(container, offset, BP_VAR_IS, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1), EX_VAR(opline->result.var) TSRMLS_CC);

		if (retval != EX_VAR(opline->result.var)) {
			ZVAL_COPY(EX_VAR(opline->result.var), retval);
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *container;

	if (zend_is_by_ref_func_arg_fetch(opline, EX(call) TSRMLS_CC)) {
		/* Behave like FETCH_OBJ_W */
		zend_free_op free_op1;
		zval *property;

		SAVE_OPLINE();
		property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		container = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

		if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
		}
		zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_W, 0 TSRMLS_CC);

		if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
			EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
		}

		CHECK_EXCEPTION();
		ZEND_VM_NEXT_OPCODE();
	} else {
		return zend_fetch_property_address_read_helper_SPEC_CV_CV(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	}
}

static int ZEND_FASTCALL  ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zend_free_op free_op1;
	zval *container, *property, *retval_ptr;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	property = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(container) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an object");
	}
	zend_fetch_property_address(EX_VAR(opline->result.var), container, property, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property) : -1), BP_VAR_UNSET, 0 TSRMLS_CC);

	if (IS_CV == IS_VAR && 0 && READY_TO_DESTROY(free_op1.var)) {
		EXTRACT_ZVAL_PTR(EX_VAR(opline->result.var));
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object;
	zval *property_name;

	SAVE_OPLINE();
	object = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_OBJ, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);


	/* assign_obj has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_DIM_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *object_ptr;

	SAVE_OPLINE();
	object_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(object_ptr) == IS_STR_OFFSET)) {
		zend_error_noreturn(E_ERROR, "Cannot use string offset as an array");
	}
	if (UNEXPECTED(Z_ISREF_P(object_ptr)) && Z_TYPE_P(Z_REFVAL_P(object_ptr)) == IS_OBJECT) {
		object_ptr = Z_REFVAL_P(object_ptr);
	}
	if (Z_TYPE_P(object_ptr) == IS_OBJECT) {

		zval *property_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		zend_assign_to_object(RETURN_VALUE_USED(opline)?EX_VAR(opline->result.var):NULL, object_ptr, property_name, (opline+1)->op1_type, &(opline+1)->op1, execute_data, ZEND_ASSIGN_DIM, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(property_name) : -1) TSRMLS_CC);

	} else {
		zend_free_op free_op_data1, free_op_data2;
		zval *value;
		zval *dim = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		zval *variable_ptr;

		zend_fetch_dimension_address_W(EX_VAR((opline+1)->op2.var), object_ptr, dim, IS_CV TSRMLS_CC);

		value = get_zval_ptr((opline+1)->op1_type, &(opline+1)->op1, execute_data, &free_op_data1, BP_VAR_R);
		variable_ptr = _get_zval_ptr_ptr_var((opline+1)->op2.var, execute_data, &free_op_data2 TSRMLS_CC);
		if (UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
			zend_assign_to_string_offset(variable_ptr, value, (opline+1)->op1_type, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
		} else if (UNEXPECTED(variable_ptr == &EG(error_zval))) {
			if (IS_TMP_FREE(free_op_data1)) {
				zval_dtor(value);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_NULL(EX_VAR(opline->result.var));
			}
			FREE_OP_VAR_PTR(free_op_data2);
		} else {
			if ((opline+1)->op1_type == IS_TMP_VAR) {
			 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
			} else if ((opline+1)->op1_type == IS_CONST) {
			 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
			} else {
			 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
			}
			if (RETURN_VALUE_USED(opline)) {
				ZVAL_COPY(EX_VAR(opline->result.var), value);
			}
			FREE_OP_VAR_PTR(free_op_data2);
		}
	 	FREE_OP_IF_VAR(free_op_data1);
	}

	/* assign_dim has two opcodes! */
	CHECK_EXCEPTION();
	ZEND_VM_INC_OPCODE();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *value;
	zval *variable_ptr;

	SAVE_OPLINE();
	value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
	variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

	if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET)) {
		zend_assign_to_string_offset(variable_ptr, value, IS_CV, (RETURN_VALUE_USED(opline) ? EX_VAR(opline->result.var) : NULL) TSRMLS_CC);
	} else if (IS_CV == IS_VAR && UNEXPECTED(variable_ptr == &EG(error_zval))) {
		if (0) {
			zval_dtor(value);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_NULL(EX_VAR(opline->result.var));
		}
	} else {
		if (IS_CV == IS_TMP_VAR) {
		 	value = zend_assign_tmp_to_variable(variable_ptr, value TSRMLS_CC);
		} else if (IS_CV == IS_CONST) {
		 	value = zend_assign_const_to_variable(variable_ptr, value TSRMLS_CC);
		} else {
		 	value = zend_assign_to_variable(variable_ptr, value TSRMLS_CC);
		}
		if (RETURN_VALUE_USED(opline)) {
			ZVAL_COPY(EX_VAR(opline->result.var), value);
		}

	}

	/* zend_assign_to_variable() always takes care of op2, never free it! */

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *variable_ptr;
	zval *value_ptr;

	SAVE_OPLINE();
	value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV == IS_VAR &&
	    opline->extended_value == ZEND_RETURNS_FUNCTION &&
	    !(Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF) &&
	    !Z_ISREF_P(value_ptr)) {
		if (!0) {
			PZVAL_LOCK(value_ptr); /* undo the effect of get_zval_ptr_ptr() */
		}
		zend_error(E_STRICT, "Only variables should be assigned by reference");
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		return ZEND_ASSIGN_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
	} else if (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		if (!0) {
			PZVAL_LOCK(value_ptr);
		}
	}

	variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR &&
	    UNEXPECTED(Z_TYPE_P(EX_VAR(opline->op1.var)) != IS_INDIRECT) &&
	    UNEXPECTED(!Z_ISREF_P(variable_ptr))) {
		zend_error_noreturn(E_ERROR, "Cannot assign by reference to overloaded object");
	}
	if ((IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) ||
	    (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(variable_ptr) == IS_STR_OFFSET))) {
		zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets nor overloaded objects");
	}
	if ((IS_CV == IS_VAR && UNEXPECTED(variable_ptr == &EG(error_zval))) ||
	    (IS_CV == IS_VAR && UNEXPECTED(value_ptr == &EG(error_zval)))) {
		variable_ptr = &EG(uninitialized_zval);
	} else {
		zend_assign_to_variable_reference(variable_ptr, value_ptr TSRMLS_CC);
	}

	if (IS_CV == IS_VAR && opline->extended_value == ZEND_RETURNS_NEW) {
		if (!0) {
			Z_DELREF_P(variable_ptr);
		}
	}

	if (RETURN_VALUE_USED(opline)) {
		ZVAL_COPY(EX_VAR(opline->result.var), variable_ptr);
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE
	zval *function_name;

	call_slot *call = EX(call_slots) + opline->result.num;
	zval *object;

	SAVE_OPLINE();

	function_name = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (IS_CV != IS_CONST &&
	    UNEXPECTED(Z_TYPE_P(function_name) != IS_STRING)) {
		if (UNEXPECTED(EG(exception) != NULL)) {
			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Method name must be a string");
	}

	object = _get_zval_ptr_cv_deref_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
	call->object = Z_TYPE_P(object) == IS_OBJECT ? Z_OBJ_P(object) : NULL;

	if (EXPECTED(call->object != NULL)) {
		call->called_scope = zend_get_class_entry(call->object TSRMLS_CC);

		if (IS_CV != IS_CONST ||
		    (call->fbc = CACHED_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope)) == NULL) {
		    zend_object *object = call->object;

			if (UNEXPECTED(object->handlers->get_method == NULL)) {
				zend_error_noreturn(E_ERROR, "Object does not support method calls");
			}

			/* First, locate the function. */
			call->fbc = object->handlers->get_method(&call->object, Z_STR_P(function_name), ((IS_CV == IS_CONST) ? (opline->op2.zv + 1) : NULL) TSRMLS_CC);
			if (UNEXPECTED(call->fbc == NULL)) {
				zend_error_noreturn(E_ERROR, "Call to undefined method %s::%s()", Z_OBJ_CLASS_NAME_P(call->object), Z_STRVAL_P(function_name));
			}
			if (IS_CV == IS_CONST &&
			    EXPECTED(call->fbc->type <= ZEND_USER_FUNCTION) &&
			    EXPECTED((call->fbc->common.fn_flags & (ZEND_ACC_CALL_VIA_HANDLER|ZEND_ACC_NEVER_CACHE)) == 0) &&
			    EXPECTED(call->object == object)) {
				CACHE_POLYMORPHIC_PTR(Z_CACHE_SLOT_P(function_name), call->called_scope, call->fbc);
			}
		}
	} else {
		if (UNEXPECTED(EG(exception) != NULL)) {

			HANDLE_EXCEPTION();
		}
		zend_error_noreturn(E_ERROR, "Call to a member function %s() on a non-object", Z_STRVAL_P(function_name));
	}

	if ((call->fbc->common.fn_flags & ZEND_ACC_STATIC) != 0) {
		call->object = NULL;
	} else {
		GC_REFCOUNT(call->object)++; /* For $this pointer */
	}

	call->num_additional_args = 0;
	call->is_ctor_call = 0;
	EX(call) = call;


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_CASE_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *result = EX_VAR(opline->result.var);

	SAVE_OPLINE();
	ZVAL_BOOL(result, fast_equal_function(result,
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC),
				 _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC) TSRMLS_CC));

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *expr_ptr, new_expr;

	SAVE_OPLINE();
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);
		if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(expr_ptr) == IS_STR_OFFSET)) {
			zend_error_noreturn(E_ERROR, "Cannot create references to/from string offsets");
		}
		SEPARATE_ZVAL_TO_MAKE_IS_REF(expr_ptr);
		Z_ADDREF_P(expr_ptr);
	} else {
		expr_ptr = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
		if (0) { /* temporary variable */
			ZVAL_COPY_VALUE(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (IS_CV == IS_CONST) {
			ZVAL_DUP(&new_expr, expr_ptr);
			expr_ptr = &new_expr;
		} else if (Z_ISREF_P(expr_ptr)) {
			ZVAL_DUP(&new_expr, Z_REFVAL_P(expr_ptr));
			expr_ptr = &new_expr;

		} else if (IS_CV == IS_CV && Z_REFCOUNTED_P(expr_ptr)) {
			Z_ADDREF_P(expr_ptr);
		}
	}

	if (IS_CV != IS_UNUSED) {

		zval *offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);
		ulong hval;

add_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index;
			case IS_LONG:
			case IS_BOOL:
				hval = Z_LVAL_P(offset);
num_index:
				zend_hash_index_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), hval, expr_ptr);
				break;
			case IS_STRING:
				if (IS_CV != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index);
				}
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), Z_STR_P(offset), expr_ptr);
				break;
			case IS_NULL:
				zend_hash_update(Z_ARRVAL_P(EX_VAR(opline->result.var)), STR_EMPTY_ALLOC(), expr_ptr);
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto add_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type");
				zval_ptr_dtor(expr_ptr);
				/* do nothing */
				break;
		}

	} else {
		zend_hash_next_index_insert(Z_ARRVAL_P(EX_VAR(opline->result.var)), expr_ptr);
	}
	if ((IS_CV == IS_VAR || IS_CV == IS_CV) && opline->extended_value) {

	}
	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	array_init(EX_VAR(opline->result.var));
	if (IS_CV == IS_UNUSED) {
		ZEND_VM_NEXT_OPCODE();
#if 0 || IS_CV != IS_UNUSED
	} else {
		return ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
#endif
	}
}

static int ZEND_FASTCALL  ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zval *offset;
	ulong hval;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV != IS_UNUSED) {
		SEPARATE_ZVAL_IF_NOT_REF(container);
	}
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

container_again:
	switch (Z_TYPE_P(container)) {
		case IS_ARRAY: {
			HashTable *ht = Z_ARRVAL_P(container);
offset_again:
			switch (Z_TYPE_P(offset)) {
				case IS_DOUBLE:
					hval = zend_dval_to_lval(Z_DVAL_P(offset));
					zend_hash_index_del(ht, hval);
					break;
				case IS_RESOURCE:
				case IS_BOOL:
				case IS_LONG:
					hval = Z_LVAL_P(offset);
					zend_hash_index_del(ht, hval);
					break;
				case IS_STRING:
					if (IS_CV == IS_CV || IS_CV == IS_VAR) {
						if (Z_REFCOUNTED_P(offset)) Z_ADDREF_P(offset);
					}
					if (IS_CV != IS_CONST) {
						ZEND_HANDLE_NUMERIC_EX(Z_STRVAL_P(offset), Z_STRLEN_P(offset)+1, hval, goto num_index_dim);
					}
					if (ht == &EG(symbol_table).ht) {
						zend_delete_global_variable(Z_STR_P(offset) TSRMLS_CC);
					} else {
						zend_hash_del(ht, Z_STR_P(offset));
					}
					if (IS_CV == IS_CV || IS_CV == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
num_index_dim:
					zend_hash_index_del(ht, hval);
					if (IS_CV == IS_CV || IS_CV == IS_VAR) {
						zval_ptr_dtor(offset);
					}
					break;
				case IS_NULL:
					zend_hash_del(ht, STR_EMPTY_ALLOC());
					break;
				case IS_REFERENCE:
					offset = Z_REFVAL_P(offset);
					goto offset_again;
					break;
				default:
					zend_error(E_WARNING, "Illegal offset type in unset");
					break;
			}

			break;
		}
		case IS_OBJECT:
			if (UNEXPECTED(Z_OBJ_HT_P(container)->unset_dimension == NULL)) {
				zend_error_noreturn(E_ERROR, "Cannot use object as array");
			}
//???			if (IS_CV == IS_CONST) {
//???				zval_copy_ctor(offset);
//???			}
			Z_OBJ_HT_P(container)->unset_dimension(container, offset TSRMLS_CC);

			break;
		case IS_STRING:
		case IS_STR_OFFSET:
			zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
			ZEND_VM_CONTINUE(); /* bailed out before */
		case IS_REFERENCE:
			container = Z_REFVAL_P(container);
			goto container_again;
			break;
		default:

			break;
	}

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_BP_VAR_UNSET(execute_data, opline->op1.var TSRMLS_CC);
	if (IS_CV == IS_VAR && Z_TYPE_P(container) == IS_STR_OFFSET) {
		zend_error_noreturn(E_ERROR, "Cannot unset string offsets");
	}
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	ZVAL_DEREF(container);
	if (Z_TYPE_P(container) == IS_OBJECT) {
		if (Z_OBJ_HT_P(container)->unset_property) {
			Z_OBJ_HT_P(container)->unset_property(container, offset, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
		} else {
			zend_error(E_NOTICE, "Trying to unset property of non-object");
		}
	}


	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV(int prop_dim, ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	zval *container;
	int result;
	ulong hval;
	zval *offset;

	SAVE_OPLINE();
	container = _get_zval_ptr_cv_deref_BP_VAR_IS(execute_data, opline->op1.var TSRMLS_CC);
	offset = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

	if (Z_TYPE_P(container) == IS_ARRAY && !prop_dim) {
		HashTable *ht = Z_ARRVAL_P(container);
		zval *value = NULL;
		zend_string *str;

isset_again:
		switch (Z_TYPE_P(offset)) {
			case IS_DOUBLE:
				hval = zend_dval_to_lval(Z_DVAL_P(offset));
				goto num_index_prop;
			case IS_RESOURCE:
			case IS_BOOL:
			case IS_LONG:
				hval = Z_LVAL_P(offset);
num_index_prop:
				value = zend_hash_index_find(ht, hval);
				break;
			case IS_STRING:
				str = Z_STR_P(offset);
				if (IS_CV != IS_CONST) {
					ZEND_HANDLE_NUMERIC_EX(str->val, str->len+1, hval, goto num_index_prop);
				}
str_index_prop:
				value = zend_hash_find_ind(ht, str);
				break;
			case IS_NULL:
				str = STR_EMPTY_ALLOC();
				goto str_index_prop;
				break;
			case IS_REFERENCE:
				offset = Z_REFVAL_P(offset);
				goto isset_again;
				break;
			default:
				zend_error(E_WARNING, "Illegal offset type in isset or empty");
				break;
		}

		if (opline->extended_value & ZEND_ISSET) {
			/* > IS_NULL means not IS_UNDEF and not IS_NULL */
			result = (value != NULL && Z_TYPE_P(value) > IS_NULL);
		} else /* if (opline->extended_value & ZEND_ISEMPTY) */ {
			result = (value == NULL || !i_zend_is_true(value TSRMLS_CC));
		}
	} else if (Z_TYPE_P(container) == IS_OBJECT) {
		if (prop_dim) {
			if (Z_OBJ_HT_P(container)->has_property) {
				result = Z_OBJ_HT_P(container)->has_property(container, offset, (opline->extended_value & ZEND_ISSET) == 0, ((IS_CV == IS_CONST) ? Z_CACHE_SLOT_P(offset) : -1) TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check property of non-object");
				result = 0;
			}
		} else {
			if (Z_OBJ_HT_P(container)->has_dimension) {
				result = Z_OBJ_HT_P(container)->has_dimension(container, offset, (opline->extended_value & ZEND_ISSET) == 0 TSRMLS_CC);
			} else {
				zend_error(E_NOTICE, "Trying to check element of non-array");
				result = 0;
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else if (Z_TYPE_P(container) == IS_STRING && !prop_dim) { /* string offsets */
		zval tmp;

		result = 0;
		if (UNEXPECTED(Z_TYPE_P(offset) != IS_LONG)) {
			if (Z_TYPE_P(offset) < IS_STRING /* simple scalar types */
					|| (Z_TYPE_P(offset) == IS_STRING /* or numeric string */
						&& IS_LONG == is_numeric_string(Z_STRVAL_P(offset), Z_STRLEN_P(offset), NULL, NULL, 0))) {
				ZVAL_DUP(&tmp, offset);
				convert_to_long(&tmp);
				offset = &tmp;
			}
		}
		if (Z_TYPE_P(offset) == IS_LONG) {
			if (offset->value.lval >= 0 && offset->value.lval < Z_STRLEN_P(container)) {
				if ((opline->extended_value & ZEND_ISSET) ||
				    Z_STRVAL_P(container)[offset->value.lval] != '0') {
					result = 1;
				}
			}
		}
		if ((opline->extended_value & ZEND_ISSET) == 0) {
			result = !result;
		}
	} else {
		result = ((opline->extended_value & ZEND_ISSET) == 0);
	}

	ZVAL_BOOL(EX_VAR(opline->result.var), result);

	CHECK_EXCEPTION();
	ZEND_VM_NEXT_OPCODE();
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV(0, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_isset_isempty_dim_prop_obj_handler_SPEC_CV_CV(1, ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

static int ZEND_FASTCALL  ZEND_YIELD_SPEC_CV_CV_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	USE_OPLINE

	/* The generator object is stored in EX(return_value) */
	zend_generator *generator = (zend_generator *) EX(return_value);

	if (generator->flags & ZEND_GENERATOR_FORCED_CLOSE) {
		zend_error_noreturn(E_ERROR, "Cannot yield from finally in a force-closed generator");
	}

	/* Destroy the previously yielded value */
	zval_ptr_dtor(&generator->value);

	/* Destroy the previously yielded key */
	zval_ptr_dtor(&generator->key);

	/* Set the new yielded value */
	if (IS_CV != IS_UNUSED) {


		if (EX(op_array)->fn_flags & ZEND_ACC_RETURN_REFERENCE) {
			/* Constants and temporary variables aren't yieldable by reference,
			 * but we still allow them with a notice. */
			if (IS_CV == IS_CONST || IS_CV == IS_TMP_VAR) {
				zval *value;

				zend_error(E_NOTICE, "Only variable references should be yielded by reference");

				value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);
				ZVAL_COPY_VALUE(&generator->value, value);
				if (Z_OPT_REFCOUNTED(generator->value)) Z_SET_REFCOUNT(generator->value, 1);

				/* Temporary variables don't need ctor copying */
				if (!0) {
					zval_copy_ctor(&generator->value);
				}
			} else {
				zval *value_ptr = _get_zval_ptr_cv_BP_VAR_W(execute_data, opline->op1.var TSRMLS_CC);

				if (IS_CV == IS_VAR && UNEXPECTED(Z_TYPE_P(value_ptr) == IS_STR_OFFSET)) {
					zend_error_noreturn(E_ERROR, "Cannot yield string offsets by reference");
				}

				/* If a function call result is yielded and the function did
				 * not return by reference we throw a notice. */
				if (IS_CV == IS_VAR && !Z_ISREF_P(value_ptr)
				    && !(opline->extended_value == ZEND_RETURNS_FUNCTION
				         && (Z_VAR_FLAGS_P(value_ptr) & IS_VAR_RET_REF))) {
					zend_error(E_NOTICE, "Only variable references should be yielded by reference");
				} else {
					SEPARATE_ZVAL_TO_MAKE_IS_REF(value_ptr);
				}
				ZVAL_COPY(&generator->value, value_ptr);

			}
		} else {
			zval *value = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op1.var TSRMLS_CC);

			/* Consts, temporary variables and references need copying */
			if (IS_CV == IS_CONST) {
				ZVAL_DUP(&generator->value, value);
			} else if (IS_CV == IS_TMP_VAR) {
				ZVAL_COPY_VALUE(&generator->value, value);
            } else if (Z_ISREF_P(value)) {
				ZVAL_DUP(&generator->value, Z_REFVAL_P(value));

			} else {
				if (IS_CV == IS_CV) {
					if (Z_REFCOUNTED_P(value)) Z_ADDREF_P(value);
				}
				ZVAL_COPY_VALUE(&generator->value, value);
			}
		}
	} else {
		/* If no value was specified yield null */
		ZVAL_NULL(&generator->value);
	}

	/* Set the new yielded key */
	if (IS_CV != IS_UNUSED) {

		zval *key = _get_zval_ptr_cv_BP_VAR_R(execute_data, opline->op2.var TSRMLS_CC);

		/* Consts, temporary variables and references need copying */
		if (IS_CV == IS_CONST) {
			ZVAL_DUP(&generator->key, key);
		} else if (IS_CV == IS_TMP_VAR) {
			ZVAL_COPY_VALUE(&generator->key, key);
		} else if (Z_ISREF_P(key)) {
			ZVAL_DUP(&generator->key, Z_REFVAL_P(key));

		} else {
			if (IS_CV == IS_CV) {
				if (Z_REFCOUNTED_P(key)) Z_ADDREF_P(key);
			}
			ZVAL_COPY_VALUE(&generator->key, key);
		}

		if (Z_TYPE(generator->key) == IS_LONG
		    && Z_LVAL(generator->key) > generator->largest_used_integer_key
		) {
			generator->largest_used_integer_key = Z_LVAL(generator->key);
		}
	} else {
		/* If no key was specified we use auto-increment keys */
		generator->largest_used_integer_key++;
		ZVAL_LONG(&generator->key, generator->largest_used_integer_key);
	}

	if (RETURN_VALUE_USED(opline)) {
		/* If the return value of yield is used set the send
		 * target and initialize it to NULL */
		generator->send_target = EX_VAR(opline->result.var);
		ZVAL_NULL(generator->send_target);
	} else {
		generator->send_target = NULL;
	}

	/* We increment to the next op, so we are at the correct position when the
	 * generator is resumed. */
	ZEND_VM_INC_OPCODE();

	/* The GOTO VM uses a local opline variable. We need to set the opline
	 * variable in execute_data so we don't resume at an old position. */
	SAVE_OPLINE();

	ZEND_VM_RETURN();
}

static int ZEND_FASTCALL ZEND_NULL_HANDLER(ZEND_OPCODE_HANDLER_ARGS)
{
	zend_error_noreturn(E_ERROR, "Invalid opcode %d/%d/%d.", OPLINE->opcode, OPLINE->op1_type, OPLINE->op2_type);
	ZEND_VM_NEXT_OPCODE(); /* Never reached */
}


void zend_init_opcodes_handlers(void)
{
  static const opcode_handler_t labels[] = {
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_NOP_SPEC_HANDLER,
  	ZEND_ADD_SPEC_CONST_CONST_HANDLER,
  	ZEND_ADD_SPEC_CONST_TMP_HANDLER,
  	ZEND_ADD_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_SPEC_CONST_CV_HANDLER,
  	ZEND_ADD_SPEC_TMP_CONST_HANDLER,
  	ZEND_ADD_SPEC_TMP_TMP_HANDLER,
  	ZEND_ADD_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_SPEC_TMP_CV_HANDLER,
  	ZEND_ADD_SPEC_VAR_CONST_HANDLER,
  	ZEND_ADD_SPEC_VAR_TMP_HANDLER,
  	ZEND_ADD_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_SPEC_CV_CONST_HANDLER,
  	ZEND_ADD_SPEC_CV_TMP_HANDLER,
  	ZEND_ADD_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_SPEC_CV_CV_HANDLER,
  	ZEND_SUB_SPEC_CONST_CONST_HANDLER,
  	ZEND_SUB_SPEC_CONST_TMP_HANDLER,
  	ZEND_SUB_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SUB_SPEC_CONST_CV_HANDLER,
  	ZEND_SUB_SPEC_TMP_CONST_HANDLER,
  	ZEND_SUB_SPEC_TMP_TMP_HANDLER,
  	ZEND_SUB_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SUB_SPEC_TMP_CV_HANDLER,
  	ZEND_SUB_SPEC_VAR_CONST_HANDLER,
  	ZEND_SUB_SPEC_VAR_TMP_HANDLER,
  	ZEND_SUB_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SUB_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SUB_SPEC_CV_CONST_HANDLER,
  	ZEND_SUB_SPEC_CV_TMP_HANDLER,
  	ZEND_SUB_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SUB_SPEC_CV_CV_HANDLER,
  	ZEND_MUL_SPEC_CONST_CONST_HANDLER,
  	ZEND_MUL_SPEC_CONST_TMP_HANDLER,
  	ZEND_MUL_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_MUL_SPEC_CONST_CV_HANDLER,
  	ZEND_MUL_SPEC_TMP_CONST_HANDLER,
  	ZEND_MUL_SPEC_TMP_TMP_HANDLER,
  	ZEND_MUL_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_MUL_SPEC_TMP_CV_HANDLER,
  	ZEND_MUL_SPEC_VAR_CONST_HANDLER,
  	ZEND_MUL_SPEC_VAR_TMP_HANDLER,
  	ZEND_MUL_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_MUL_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_MUL_SPEC_CV_CONST_HANDLER,
  	ZEND_MUL_SPEC_CV_TMP_HANDLER,
  	ZEND_MUL_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_MUL_SPEC_CV_CV_HANDLER,
  	ZEND_DIV_SPEC_CONST_CONST_HANDLER,
  	ZEND_DIV_SPEC_CONST_TMP_HANDLER,
  	ZEND_DIV_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_DIV_SPEC_CONST_CV_HANDLER,
  	ZEND_DIV_SPEC_TMP_CONST_HANDLER,
  	ZEND_DIV_SPEC_TMP_TMP_HANDLER,
  	ZEND_DIV_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_DIV_SPEC_TMP_CV_HANDLER,
  	ZEND_DIV_SPEC_VAR_CONST_HANDLER,
  	ZEND_DIV_SPEC_VAR_TMP_HANDLER,
  	ZEND_DIV_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_DIV_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_DIV_SPEC_CV_CONST_HANDLER,
  	ZEND_DIV_SPEC_CV_TMP_HANDLER,
  	ZEND_DIV_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_DIV_SPEC_CV_CV_HANDLER,
  	ZEND_MOD_SPEC_CONST_CONST_HANDLER,
  	ZEND_MOD_SPEC_CONST_TMP_HANDLER,
  	ZEND_MOD_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_MOD_SPEC_CONST_CV_HANDLER,
  	ZEND_MOD_SPEC_TMP_CONST_HANDLER,
  	ZEND_MOD_SPEC_TMP_TMP_HANDLER,
  	ZEND_MOD_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_MOD_SPEC_TMP_CV_HANDLER,
  	ZEND_MOD_SPEC_VAR_CONST_HANDLER,
  	ZEND_MOD_SPEC_VAR_TMP_HANDLER,
  	ZEND_MOD_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_MOD_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_MOD_SPEC_CV_CONST_HANDLER,
  	ZEND_MOD_SPEC_CV_TMP_HANDLER,
  	ZEND_MOD_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_MOD_SPEC_CV_CV_HANDLER,
  	ZEND_SL_SPEC_CONST_CONST_HANDLER,
  	ZEND_SL_SPEC_CONST_TMP_HANDLER,
  	ZEND_SL_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SL_SPEC_CONST_CV_HANDLER,
  	ZEND_SL_SPEC_TMP_CONST_HANDLER,
  	ZEND_SL_SPEC_TMP_TMP_HANDLER,
  	ZEND_SL_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SL_SPEC_TMP_CV_HANDLER,
  	ZEND_SL_SPEC_VAR_CONST_HANDLER,
  	ZEND_SL_SPEC_VAR_TMP_HANDLER,
  	ZEND_SL_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SL_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SL_SPEC_CV_CONST_HANDLER,
  	ZEND_SL_SPEC_CV_TMP_HANDLER,
  	ZEND_SL_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SL_SPEC_CV_CV_HANDLER,
  	ZEND_SR_SPEC_CONST_CONST_HANDLER,
  	ZEND_SR_SPEC_CONST_TMP_HANDLER,
  	ZEND_SR_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SR_SPEC_CONST_CV_HANDLER,
  	ZEND_SR_SPEC_TMP_CONST_HANDLER,
  	ZEND_SR_SPEC_TMP_TMP_HANDLER,
  	ZEND_SR_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SR_SPEC_TMP_CV_HANDLER,
  	ZEND_SR_SPEC_VAR_CONST_HANDLER,
  	ZEND_SR_SPEC_VAR_TMP_HANDLER,
  	ZEND_SR_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SR_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SR_SPEC_CV_CONST_HANDLER,
  	ZEND_SR_SPEC_CV_TMP_HANDLER,
  	ZEND_SR_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SR_SPEC_CV_CV_HANDLER,
  	ZEND_CONCAT_SPEC_CONST_CONST_HANDLER,
  	ZEND_CONCAT_SPEC_CONST_TMP_HANDLER,
  	ZEND_CONCAT_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CONCAT_SPEC_CONST_CV_HANDLER,
  	ZEND_CONCAT_SPEC_TMP_CONST_HANDLER,
  	ZEND_CONCAT_SPEC_TMP_TMP_HANDLER,
  	ZEND_CONCAT_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CONCAT_SPEC_TMP_CV_HANDLER,
  	ZEND_CONCAT_SPEC_VAR_CONST_HANDLER,
  	ZEND_CONCAT_SPEC_VAR_TMP_HANDLER,
  	ZEND_CONCAT_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CONCAT_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CONCAT_SPEC_CV_CONST_HANDLER,
  	ZEND_CONCAT_SPEC_CV_TMP_HANDLER,
  	ZEND_CONCAT_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CONCAT_SPEC_CV_CV_HANDLER,
  	ZEND_BW_OR_SPEC_CONST_CONST_HANDLER,
  	ZEND_BW_OR_SPEC_CONST_TMP_HANDLER,
  	ZEND_BW_OR_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_OR_SPEC_CONST_CV_HANDLER,
  	ZEND_BW_OR_SPEC_TMP_CONST_HANDLER,
  	ZEND_BW_OR_SPEC_TMP_TMP_HANDLER,
  	ZEND_BW_OR_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_OR_SPEC_TMP_CV_HANDLER,
  	ZEND_BW_OR_SPEC_VAR_CONST_HANDLER,
  	ZEND_BW_OR_SPEC_VAR_TMP_HANDLER,
  	ZEND_BW_OR_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_OR_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_OR_SPEC_CV_CONST_HANDLER,
  	ZEND_BW_OR_SPEC_CV_TMP_HANDLER,
  	ZEND_BW_OR_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_OR_SPEC_CV_CV_HANDLER,
  	ZEND_BW_AND_SPEC_CONST_CONST_HANDLER,
  	ZEND_BW_AND_SPEC_CONST_TMP_HANDLER,
  	ZEND_BW_AND_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_AND_SPEC_CONST_CV_HANDLER,
  	ZEND_BW_AND_SPEC_TMP_CONST_HANDLER,
  	ZEND_BW_AND_SPEC_TMP_TMP_HANDLER,
  	ZEND_BW_AND_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_AND_SPEC_TMP_CV_HANDLER,
  	ZEND_BW_AND_SPEC_VAR_CONST_HANDLER,
  	ZEND_BW_AND_SPEC_VAR_TMP_HANDLER,
  	ZEND_BW_AND_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_AND_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_AND_SPEC_CV_CONST_HANDLER,
  	ZEND_BW_AND_SPEC_CV_TMP_HANDLER,
  	ZEND_BW_AND_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_AND_SPEC_CV_CV_HANDLER,
  	ZEND_BW_XOR_SPEC_CONST_CONST_HANDLER,
  	ZEND_BW_XOR_SPEC_CONST_TMP_HANDLER,
  	ZEND_BW_XOR_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_XOR_SPEC_CONST_CV_HANDLER,
  	ZEND_BW_XOR_SPEC_TMP_CONST_HANDLER,
  	ZEND_BW_XOR_SPEC_TMP_TMP_HANDLER,
  	ZEND_BW_XOR_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_XOR_SPEC_TMP_CV_HANDLER,
  	ZEND_BW_XOR_SPEC_VAR_CONST_HANDLER,
  	ZEND_BW_XOR_SPEC_VAR_TMP_HANDLER,
  	ZEND_BW_XOR_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_XOR_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_XOR_SPEC_CV_CONST_HANDLER,
  	ZEND_BW_XOR_SPEC_CV_TMP_HANDLER,
  	ZEND_BW_XOR_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_XOR_SPEC_CV_CV_HANDLER,
  	ZEND_BW_NOT_SPEC_CONST_HANDLER,
  	ZEND_BW_NOT_SPEC_CONST_HANDLER,
  	ZEND_BW_NOT_SPEC_CONST_HANDLER,
  	ZEND_BW_NOT_SPEC_CONST_HANDLER,
  	ZEND_BW_NOT_SPEC_CONST_HANDLER,
  	ZEND_BW_NOT_SPEC_TMP_HANDLER,
  	ZEND_BW_NOT_SPEC_TMP_HANDLER,
  	ZEND_BW_NOT_SPEC_TMP_HANDLER,
  	ZEND_BW_NOT_SPEC_TMP_HANDLER,
  	ZEND_BW_NOT_SPEC_TMP_HANDLER,
  	ZEND_BW_NOT_SPEC_VAR_HANDLER,
  	ZEND_BW_NOT_SPEC_VAR_HANDLER,
  	ZEND_BW_NOT_SPEC_VAR_HANDLER,
  	ZEND_BW_NOT_SPEC_VAR_HANDLER,
  	ZEND_BW_NOT_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BW_NOT_SPEC_CV_HANDLER,
  	ZEND_BW_NOT_SPEC_CV_HANDLER,
  	ZEND_BW_NOT_SPEC_CV_HANDLER,
  	ZEND_BW_NOT_SPEC_CV_HANDLER,
  	ZEND_BW_NOT_SPEC_CV_HANDLER,
  	ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
  	ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
  	ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
  	ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
  	ZEND_BOOL_NOT_SPEC_CONST_HANDLER,
  	ZEND_BOOL_NOT_SPEC_TMP_HANDLER,
  	ZEND_BOOL_NOT_SPEC_TMP_HANDLER,
  	ZEND_BOOL_NOT_SPEC_TMP_HANDLER,
  	ZEND_BOOL_NOT_SPEC_TMP_HANDLER,
  	ZEND_BOOL_NOT_SPEC_TMP_HANDLER,
  	ZEND_BOOL_NOT_SPEC_VAR_HANDLER,
  	ZEND_BOOL_NOT_SPEC_VAR_HANDLER,
  	ZEND_BOOL_NOT_SPEC_VAR_HANDLER,
  	ZEND_BOOL_NOT_SPEC_VAR_HANDLER,
  	ZEND_BOOL_NOT_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BOOL_NOT_SPEC_CV_HANDLER,
  	ZEND_BOOL_NOT_SPEC_CV_HANDLER,
  	ZEND_BOOL_NOT_SPEC_CV_HANDLER,
  	ZEND_BOOL_NOT_SPEC_CV_HANDLER,
  	ZEND_BOOL_NOT_SPEC_CV_HANDLER,
  	ZEND_BOOL_XOR_SPEC_CONST_CONST_HANDLER,
  	ZEND_BOOL_XOR_SPEC_CONST_TMP_HANDLER,
  	ZEND_BOOL_XOR_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BOOL_XOR_SPEC_CONST_CV_HANDLER,
  	ZEND_BOOL_XOR_SPEC_TMP_CONST_HANDLER,
  	ZEND_BOOL_XOR_SPEC_TMP_TMP_HANDLER,
  	ZEND_BOOL_XOR_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BOOL_XOR_SPEC_TMP_CV_HANDLER,
  	ZEND_BOOL_XOR_SPEC_VAR_CONST_HANDLER,
  	ZEND_BOOL_XOR_SPEC_VAR_TMP_HANDLER,
  	ZEND_BOOL_XOR_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BOOL_XOR_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BOOL_XOR_SPEC_CV_CONST_HANDLER,
  	ZEND_BOOL_XOR_SPEC_CV_TMP_HANDLER,
  	ZEND_BOOL_XOR_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BOOL_XOR_SPEC_CV_CV_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_CONST_CONST_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_CONST_TMP_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_CONST_CV_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_TMP_CONST_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_TMP_TMP_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_TMP_CV_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_VAR_CONST_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_VAR_TMP_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_CV_CONST_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_CV_TMP_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_IDENTICAL_SPEC_CV_CV_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CONST_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_CONST_TMP_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_CONST_CV_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CONST_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_TMP_TMP_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_TMP_CV_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CONST_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_VAR_TMP_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_CV_CONST_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_CV_TMP_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_NOT_IDENTICAL_SPEC_CV_CV_HANDLER,
  	ZEND_IS_EQUAL_SPEC_CONST_CONST_HANDLER,
  	ZEND_IS_EQUAL_SPEC_CONST_TMP_HANDLER,
  	ZEND_IS_EQUAL_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_EQUAL_SPEC_CONST_CV_HANDLER,
  	ZEND_IS_EQUAL_SPEC_TMP_CONST_HANDLER,
  	ZEND_IS_EQUAL_SPEC_TMP_TMP_HANDLER,
  	ZEND_IS_EQUAL_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_EQUAL_SPEC_TMP_CV_HANDLER,
  	ZEND_IS_EQUAL_SPEC_VAR_CONST_HANDLER,
  	ZEND_IS_EQUAL_SPEC_VAR_TMP_HANDLER,
  	ZEND_IS_EQUAL_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_EQUAL_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_EQUAL_SPEC_CV_CONST_HANDLER,
  	ZEND_IS_EQUAL_SPEC_CV_TMP_HANDLER,
  	ZEND_IS_EQUAL_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_EQUAL_SPEC_CV_CV_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_CONST_CONST_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_CONST_TMP_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_CONST_CV_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_TMP_CONST_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_TMP_TMP_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_TMP_CV_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_VAR_CONST_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_VAR_TMP_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_CV_CONST_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_CV_TMP_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_NOT_EQUAL_SPEC_CV_CV_HANDLER,
  	ZEND_IS_SMALLER_SPEC_CONST_CONST_HANDLER,
  	ZEND_IS_SMALLER_SPEC_CONST_TMP_HANDLER,
  	ZEND_IS_SMALLER_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_SMALLER_SPEC_CONST_CV_HANDLER,
  	ZEND_IS_SMALLER_SPEC_TMP_CONST_HANDLER,
  	ZEND_IS_SMALLER_SPEC_TMP_TMP_HANDLER,
  	ZEND_IS_SMALLER_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_SMALLER_SPEC_TMP_CV_HANDLER,
  	ZEND_IS_SMALLER_SPEC_VAR_CONST_HANDLER,
  	ZEND_IS_SMALLER_SPEC_VAR_TMP_HANDLER,
  	ZEND_IS_SMALLER_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_SMALLER_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_SMALLER_SPEC_CV_CONST_HANDLER,
  	ZEND_IS_SMALLER_SPEC_CV_TMP_HANDLER,
  	ZEND_IS_SMALLER_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_SMALLER_SPEC_CV_CV_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CONST_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_TMP_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_CONST_CV_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CONST_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_TMP_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_TMP_CV_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CONST_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_TMP_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CONST_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_TMP_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_IS_SMALLER_OR_EQUAL_SPEC_CV_CV_HANDLER,
  	ZEND_CAST_SPEC_CONST_HANDLER,
  	ZEND_CAST_SPEC_CONST_HANDLER,
  	ZEND_CAST_SPEC_CONST_HANDLER,
  	ZEND_CAST_SPEC_CONST_HANDLER,
  	ZEND_CAST_SPEC_CONST_HANDLER,
  	ZEND_CAST_SPEC_TMP_HANDLER,
  	ZEND_CAST_SPEC_TMP_HANDLER,
  	ZEND_CAST_SPEC_TMP_HANDLER,
  	ZEND_CAST_SPEC_TMP_HANDLER,
  	ZEND_CAST_SPEC_TMP_HANDLER,
  	ZEND_CAST_SPEC_VAR_HANDLER,
  	ZEND_CAST_SPEC_VAR_HANDLER,
  	ZEND_CAST_SPEC_VAR_HANDLER,
  	ZEND_CAST_SPEC_VAR_HANDLER,
  	ZEND_CAST_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CAST_SPEC_CV_HANDLER,
  	ZEND_CAST_SPEC_CV_HANDLER,
  	ZEND_CAST_SPEC_CV_HANDLER,
  	ZEND_CAST_SPEC_CV_HANDLER,
  	ZEND_CAST_SPEC_CV_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_CONST_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_TMP_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
  	ZEND_QM_ASSIGN_SPEC_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_VAR_VAR_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_VAR_CV_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_UNUSED_UNUSED_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_CV_VAR_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_CV_UNUSED_HANDLER,
  	ZEND_ASSIGN_ADD_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_VAR_VAR_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_VAR_CV_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_UNUSED_UNUSED_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_CV_VAR_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_CV_UNUSED_HANDLER,
  	ZEND_ASSIGN_SUB_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_VAR_VAR_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_VAR_CV_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_UNUSED_UNUSED_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_CV_VAR_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_CV_UNUSED_HANDLER,
  	ZEND_ASSIGN_MUL_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_VAR_VAR_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_VAR_CV_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_UNUSED_UNUSED_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_CV_VAR_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_CV_UNUSED_HANDLER,
  	ZEND_ASSIGN_DIV_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_VAR_VAR_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_VAR_CV_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_UNUSED_UNUSED_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_CV_VAR_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_CV_UNUSED_HANDLER,
  	ZEND_ASSIGN_MOD_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_VAR_VAR_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_VAR_CV_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_UNUSED_UNUSED_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_CV_VAR_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_CV_UNUSED_HANDLER,
  	ZEND_ASSIGN_SL_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_VAR_VAR_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_VAR_CV_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_UNUSED_UNUSED_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_CV_VAR_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_CV_UNUSED_HANDLER,
  	ZEND_ASSIGN_SR_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_VAR_VAR_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_VAR_CV_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_UNUSED_UNUSED_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_CV_VAR_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_CV_UNUSED_HANDLER,
  	ZEND_ASSIGN_CONCAT_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_VAR_VAR_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_VAR_CV_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_UNUSED_UNUSED_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_CV_VAR_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_CV_UNUSED_HANDLER,
  	ZEND_ASSIGN_BW_OR_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_VAR_VAR_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_VAR_CV_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_UNUSED_UNUSED_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_CV_VAR_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_CV_UNUSED_HANDLER,
  	ZEND_ASSIGN_BW_AND_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_VAR_VAR_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_VAR_CV_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_UNUSED_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_CV_VAR_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_CV_UNUSED_HANDLER,
  	ZEND_ASSIGN_BW_XOR_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_PRE_INC_SPEC_VAR_HANDLER,
  	ZEND_PRE_INC_SPEC_VAR_HANDLER,
  	ZEND_PRE_INC_SPEC_VAR_HANDLER,
  	ZEND_PRE_INC_SPEC_VAR_HANDLER,
  	ZEND_PRE_INC_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_PRE_INC_SPEC_CV_HANDLER,
  	ZEND_PRE_INC_SPEC_CV_HANDLER,
  	ZEND_PRE_INC_SPEC_CV_HANDLER,
  	ZEND_PRE_INC_SPEC_CV_HANDLER,
  	ZEND_PRE_INC_SPEC_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_PRE_DEC_SPEC_VAR_HANDLER,
  	ZEND_PRE_DEC_SPEC_VAR_HANDLER,
  	ZEND_PRE_DEC_SPEC_VAR_HANDLER,
  	ZEND_PRE_DEC_SPEC_VAR_HANDLER,
  	ZEND_PRE_DEC_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_PRE_DEC_SPEC_CV_HANDLER,
  	ZEND_PRE_DEC_SPEC_CV_HANDLER,
  	ZEND_PRE_DEC_SPEC_CV_HANDLER,
  	ZEND_PRE_DEC_SPEC_CV_HANDLER,
  	ZEND_PRE_DEC_SPEC_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_POST_INC_SPEC_VAR_HANDLER,
  	ZEND_POST_INC_SPEC_VAR_HANDLER,
  	ZEND_POST_INC_SPEC_VAR_HANDLER,
  	ZEND_POST_INC_SPEC_VAR_HANDLER,
  	ZEND_POST_INC_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_POST_INC_SPEC_CV_HANDLER,
  	ZEND_POST_INC_SPEC_CV_HANDLER,
  	ZEND_POST_INC_SPEC_CV_HANDLER,
  	ZEND_POST_INC_SPEC_CV_HANDLER,
  	ZEND_POST_INC_SPEC_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_POST_DEC_SPEC_VAR_HANDLER,
  	ZEND_POST_DEC_SPEC_VAR_HANDLER,
  	ZEND_POST_DEC_SPEC_VAR_HANDLER,
  	ZEND_POST_DEC_SPEC_VAR_HANDLER,
  	ZEND_POST_DEC_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_POST_DEC_SPEC_CV_HANDLER,
  	ZEND_POST_DEC_SPEC_CV_HANDLER,
  	ZEND_POST_DEC_SPEC_CV_HANDLER,
  	ZEND_POST_DEC_SPEC_CV_HANDLER,
  	ZEND_POST_DEC_SPEC_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_REF_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_REF_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_REF_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_REF_SPEC_CV_CV_HANDLER,
  	ZEND_ECHO_SPEC_CONST_HANDLER,
  	ZEND_ECHO_SPEC_CONST_HANDLER,
  	ZEND_ECHO_SPEC_CONST_HANDLER,
  	ZEND_ECHO_SPEC_CONST_HANDLER,
  	ZEND_ECHO_SPEC_CONST_HANDLER,
  	ZEND_ECHO_SPEC_TMP_HANDLER,
  	ZEND_ECHO_SPEC_TMP_HANDLER,
  	ZEND_ECHO_SPEC_TMP_HANDLER,
  	ZEND_ECHO_SPEC_TMP_HANDLER,
  	ZEND_ECHO_SPEC_TMP_HANDLER,
  	ZEND_ECHO_SPEC_VAR_HANDLER,
  	ZEND_ECHO_SPEC_VAR_HANDLER,
  	ZEND_ECHO_SPEC_VAR_HANDLER,
  	ZEND_ECHO_SPEC_VAR_HANDLER,
  	ZEND_ECHO_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ECHO_SPEC_CV_HANDLER,
  	ZEND_ECHO_SPEC_CV_HANDLER,
  	ZEND_ECHO_SPEC_CV_HANDLER,
  	ZEND_ECHO_SPEC_CV_HANDLER,
  	ZEND_ECHO_SPEC_CV_HANDLER,
  	ZEND_PRINT_SPEC_CONST_HANDLER,
  	ZEND_PRINT_SPEC_CONST_HANDLER,
  	ZEND_PRINT_SPEC_CONST_HANDLER,
  	ZEND_PRINT_SPEC_CONST_HANDLER,
  	ZEND_PRINT_SPEC_CONST_HANDLER,
  	ZEND_PRINT_SPEC_TMP_HANDLER,
  	ZEND_PRINT_SPEC_TMP_HANDLER,
  	ZEND_PRINT_SPEC_TMP_HANDLER,
  	ZEND_PRINT_SPEC_TMP_HANDLER,
  	ZEND_PRINT_SPEC_TMP_HANDLER,
  	ZEND_PRINT_SPEC_VAR_HANDLER,
  	ZEND_PRINT_SPEC_VAR_HANDLER,
  	ZEND_PRINT_SPEC_VAR_HANDLER,
  	ZEND_PRINT_SPEC_VAR_HANDLER,
  	ZEND_PRINT_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_PRINT_SPEC_CV_HANDLER,
  	ZEND_PRINT_SPEC_CV_HANDLER,
  	ZEND_PRINT_SPEC_CV_HANDLER,
  	ZEND_PRINT_SPEC_CV_HANDLER,
  	ZEND_PRINT_SPEC_CV_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMP_SPEC_HANDLER,
  	ZEND_JMPZ_SPEC_CONST_HANDLER,
  	ZEND_JMPZ_SPEC_CONST_HANDLER,
  	ZEND_JMPZ_SPEC_CONST_HANDLER,
  	ZEND_JMPZ_SPEC_CONST_HANDLER,
  	ZEND_JMPZ_SPEC_CONST_HANDLER,
  	ZEND_JMPZ_SPEC_TMP_HANDLER,
  	ZEND_JMPZ_SPEC_TMP_HANDLER,
  	ZEND_JMPZ_SPEC_TMP_HANDLER,
  	ZEND_JMPZ_SPEC_TMP_HANDLER,
  	ZEND_JMPZ_SPEC_TMP_HANDLER,
  	ZEND_JMPZ_SPEC_VAR_HANDLER,
  	ZEND_JMPZ_SPEC_VAR_HANDLER,
  	ZEND_JMPZ_SPEC_VAR_HANDLER,
  	ZEND_JMPZ_SPEC_VAR_HANDLER,
  	ZEND_JMPZ_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_JMPZ_SPEC_CV_HANDLER,
  	ZEND_JMPZ_SPEC_CV_HANDLER,
  	ZEND_JMPZ_SPEC_CV_HANDLER,
  	ZEND_JMPZ_SPEC_CV_HANDLER,
  	ZEND_JMPZ_SPEC_CV_HANDLER,
  	ZEND_JMPNZ_SPEC_CONST_HANDLER,
  	ZEND_JMPNZ_SPEC_CONST_HANDLER,
  	ZEND_JMPNZ_SPEC_CONST_HANDLER,
  	ZEND_JMPNZ_SPEC_CONST_HANDLER,
  	ZEND_JMPNZ_SPEC_CONST_HANDLER,
  	ZEND_JMPNZ_SPEC_TMP_HANDLER,
  	ZEND_JMPNZ_SPEC_TMP_HANDLER,
  	ZEND_JMPNZ_SPEC_TMP_HANDLER,
  	ZEND_JMPNZ_SPEC_TMP_HANDLER,
  	ZEND_JMPNZ_SPEC_TMP_HANDLER,
  	ZEND_JMPNZ_SPEC_VAR_HANDLER,
  	ZEND_JMPNZ_SPEC_VAR_HANDLER,
  	ZEND_JMPNZ_SPEC_VAR_HANDLER,
  	ZEND_JMPNZ_SPEC_VAR_HANDLER,
  	ZEND_JMPNZ_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_JMPNZ_SPEC_CV_HANDLER,
  	ZEND_JMPNZ_SPEC_CV_HANDLER,
  	ZEND_JMPNZ_SPEC_CV_HANDLER,
  	ZEND_JMPNZ_SPEC_CV_HANDLER,
  	ZEND_JMPNZ_SPEC_CV_HANDLER,
  	ZEND_JMPZNZ_SPEC_CONST_HANDLER,
  	ZEND_JMPZNZ_SPEC_CONST_HANDLER,
  	ZEND_JMPZNZ_SPEC_CONST_HANDLER,
  	ZEND_JMPZNZ_SPEC_CONST_HANDLER,
  	ZEND_JMPZNZ_SPEC_CONST_HANDLER,
  	ZEND_JMPZNZ_SPEC_TMP_HANDLER,
  	ZEND_JMPZNZ_SPEC_TMP_HANDLER,
  	ZEND_JMPZNZ_SPEC_TMP_HANDLER,
  	ZEND_JMPZNZ_SPEC_TMP_HANDLER,
  	ZEND_JMPZNZ_SPEC_TMP_HANDLER,
  	ZEND_JMPZNZ_SPEC_VAR_HANDLER,
  	ZEND_JMPZNZ_SPEC_VAR_HANDLER,
  	ZEND_JMPZNZ_SPEC_VAR_HANDLER,
  	ZEND_JMPZNZ_SPEC_VAR_HANDLER,
  	ZEND_JMPZNZ_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_JMPZNZ_SPEC_CV_HANDLER,
  	ZEND_JMPZNZ_SPEC_CV_HANDLER,
  	ZEND_JMPZNZ_SPEC_CV_HANDLER,
  	ZEND_JMPZNZ_SPEC_CV_HANDLER,
  	ZEND_JMPZNZ_SPEC_CV_HANDLER,
  	ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
  	ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
  	ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
  	ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
  	ZEND_JMPZ_EX_SPEC_CONST_HANDLER,
  	ZEND_JMPZ_EX_SPEC_TMP_HANDLER,
  	ZEND_JMPZ_EX_SPEC_TMP_HANDLER,
  	ZEND_JMPZ_EX_SPEC_TMP_HANDLER,
  	ZEND_JMPZ_EX_SPEC_TMP_HANDLER,
  	ZEND_JMPZ_EX_SPEC_TMP_HANDLER,
  	ZEND_JMPZ_EX_SPEC_VAR_HANDLER,
  	ZEND_JMPZ_EX_SPEC_VAR_HANDLER,
  	ZEND_JMPZ_EX_SPEC_VAR_HANDLER,
  	ZEND_JMPZ_EX_SPEC_VAR_HANDLER,
  	ZEND_JMPZ_EX_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_JMPZ_EX_SPEC_CV_HANDLER,
  	ZEND_JMPZ_EX_SPEC_CV_HANDLER,
  	ZEND_JMPZ_EX_SPEC_CV_HANDLER,
  	ZEND_JMPZ_EX_SPEC_CV_HANDLER,
  	ZEND_JMPZ_EX_SPEC_CV_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_CONST_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_TMP_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_TMP_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_TMP_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_TMP_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_TMP_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_VAR_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_VAR_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_VAR_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_VAR_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
  	ZEND_JMPNZ_EX_SPEC_CV_HANDLER,
  	ZEND_CASE_SPEC_CONST_CONST_HANDLER,
  	ZEND_CASE_SPEC_CONST_TMP_HANDLER,
  	ZEND_CASE_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CASE_SPEC_CONST_CV_HANDLER,
  	ZEND_CASE_SPEC_TMP_CONST_HANDLER,
  	ZEND_CASE_SPEC_TMP_TMP_HANDLER,
  	ZEND_CASE_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CASE_SPEC_TMP_CV_HANDLER,
  	ZEND_CASE_SPEC_VAR_CONST_HANDLER,
  	ZEND_CASE_SPEC_VAR_TMP_HANDLER,
  	ZEND_CASE_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CASE_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CASE_SPEC_CV_CONST_HANDLER,
  	ZEND_CASE_SPEC_CV_TMP_HANDLER,
  	ZEND_CASE_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CASE_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SWITCH_FREE_SPEC_VAR_HANDLER,
  	ZEND_SWITCH_FREE_SPEC_VAR_HANDLER,
  	ZEND_SWITCH_FREE_SPEC_VAR_HANDLER,
  	ZEND_SWITCH_FREE_SPEC_VAR_HANDLER,
  	ZEND_SWITCH_FREE_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BRK_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BRK_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BRK_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BRK_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BRK_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CONT_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CONT_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CONT_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CONT_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CONT_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BOOL_SPEC_CONST_HANDLER,
  	ZEND_BOOL_SPEC_CONST_HANDLER,
  	ZEND_BOOL_SPEC_CONST_HANDLER,
  	ZEND_BOOL_SPEC_CONST_HANDLER,
  	ZEND_BOOL_SPEC_CONST_HANDLER,
  	ZEND_BOOL_SPEC_TMP_HANDLER,
  	ZEND_BOOL_SPEC_TMP_HANDLER,
  	ZEND_BOOL_SPEC_TMP_HANDLER,
  	ZEND_BOOL_SPEC_TMP_HANDLER,
  	ZEND_BOOL_SPEC_TMP_HANDLER,
  	ZEND_BOOL_SPEC_VAR_HANDLER,
  	ZEND_BOOL_SPEC_VAR_HANDLER,
  	ZEND_BOOL_SPEC_VAR_HANDLER,
  	ZEND_BOOL_SPEC_VAR_HANDLER,
  	ZEND_BOOL_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BOOL_SPEC_CV_HANDLER,
  	ZEND_BOOL_SPEC_CV_HANDLER,
  	ZEND_BOOL_SPEC_CV_HANDLER,
  	ZEND_BOOL_SPEC_CV_HANDLER,
  	ZEND_BOOL_SPEC_CV_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_INIT_STRING_SPEC_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_CHAR_SPEC_TMP_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_CHAR_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_STRING_SPEC_TMP_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_STRING_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_VAR_SPEC_TMP_TMP_HANDLER,
  	ZEND_ADD_VAR_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_VAR_SPEC_TMP_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_VAR_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ADD_VAR_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_VAR_SPEC_UNUSED_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_BEGIN_SILENCE_SPEC_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_END_SILENCE_SPEC_TMP_HANDLER,
  	ZEND_END_SILENCE_SPEC_TMP_HANDLER,
  	ZEND_END_SILENCE_SPEC_TMP_HANDLER,
  	ZEND_END_SILENCE_SPEC_TMP_HANDLER,
  	ZEND_END_SILENCE_SPEC_TMP_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_CONST_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_TMP_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_FCALL_BY_NAME_SPEC_CV_HANDLER,
  	ZEND_DO_FCALL_SPEC_CONST_HANDLER,
  	ZEND_DO_FCALL_SPEC_CONST_HANDLER,
  	ZEND_DO_FCALL_SPEC_CONST_HANDLER,
  	ZEND_DO_FCALL_SPEC_CONST_HANDLER,
  	ZEND_DO_FCALL_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_DO_FCALL_BY_NAME_SPEC_HANDLER,
  	ZEND_RETURN_SPEC_CONST_HANDLER,
  	ZEND_RETURN_SPEC_CONST_HANDLER,
  	ZEND_RETURN_SPEC_CONST_HANDLER,
  	ZEND_RETURN_SPEC_CONST_HANDLER,
  	ZEND_RETURN_SPEC_CONST_HANDLER,
  	ZEND_RETURN_SPEC_TMP_HANDLER,
  	ZEND_RETURN_SPEC_TMP_HANDLER,
  	ZEND_RETURN_SPEC_TMP_HANDLER,
  	ZEND_RETURN_SPEC_TMP_HANDLER,
  	ZEND_RETURN_SPEC_TMP_HANDLER,
  	ZEND_RETURN_SPEC_VAR_HANDLER,
  	ZEND_RETURN_SPEC_VAR_HANDLER,
  	ZEND_RETURN_SPEC_VAR_HANDLER,
  	ZEND_RETURN_SPEC_VAR_HANDLER,
  	ZEND_RETURN_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_RETURN_SPEC_CV_HANDLER,
  	ZEND_RETURN_SPEC_CV_HANDLER,
  	ZEND_RETURN_SPEC_CV_HANDLER,
  	ZEND_RETURN_SPEC_CV_HANDLER,
  	ZEND_RETURN_SPEC_CV_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_SPEC_HANDLER,
  	ZEND_RECV_INIT_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_RECV_INIT_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_RECV_INIT_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_RECV_INIT_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_RECV_INIT_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SEND_VAL_SPEC_CONST_HANDLER,
  	ZEND_SEND_VAL_SPEC_CONST_HANDLER,
  	ZEND_SEND_VAL_SPEC_CONST_HANDLER,
  	ZEND_SEND_VAL_SPEC_CONST_HANDLER,
  	ZEND_SEND_VAL_SPEC_CONST_HANDLER,
  	ZEND_SEND_VAL_SPEC_TMP_HANDLER,
  	ZEND_SEND_VAL_SPEC_TMP_HANDLER,
  	ZEND_SEND_VAL_SPEC_TMP_HANDLER,
  	ZEND_SEND_VAL_SPEC_TMP_HANDLER,
  	ZEND_SEND_VAL_SPEC_TMP_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SEND_VAR_SPEC_VAR_HANDLER,
  	ZEND_SEND_VAR_SPEC_VAR_HANDLER,
  	ZEND_SEND_VAR_SPEC_VAR_HANDLER,
  	ZEND_SEND_VAR_SPEC_VAR_HANDLER,
  	ZEND_SEND_VAR_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SEND_VAR_SPEC_CV_HANDLER,
  	ZEND_SEND_VAR_SPEC_CV_HANDLER,
  	ZEND_SEND_VAR_SPEC_CV_HANDLER,
  	ZEND_SEND_VAR_SPEC_CV_HANDLER,
  	ZEND_SEND_VAR_SPEC_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SEND_REF_SPEC_VAR_HANDLER,
  	ZEND_SEND_REF_SPEC_VAR_HANDLER,
  	ZEND_SEND_REF_SPEC_VAR_HANDLER,
  	ZEND_SEND_REF_SPEC_VAR_HANDLER,
  	ZEND_SEND_REF_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SEND_REF_SPEC_CV_HANDLER,
  	ZEND_SEND_REF_SPEC_CV_HANDLER,
  	ZEND_SEND_REF_SPEC_CV_HANDLER,
  	ZEND_SEND_REF_SPEC_CV_HANDLER,
  	ZEND_SEND_REF_SPEC_CV_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_NEW_SPEC_HANDLER,
  	ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_NS_FCALL_BY_NAME_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FREE_SPEC_TMP_HANDLER,
  	ZEND_FREE_SPEC_TMP_HANDLER,
  	ZEND_FREE_SPEC_TMP_HANDLER,
  	ZEND_FREE_SPEC_TMP_HANDLER,
  	ZEND_FREE_SPEC_TMP_HANDLER,
  	ZEND_FREE_SPEC_VAR_HANDLER,
  	ZEND_FREE_SPEC_VAR_HANDLER,
  	ZEND_FREE_SPEC_VAR_HANDLER,
  	ZEND_FREE_SPEC_VAR_HANDLER,
  	ZEND_FREE_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_CONST_CONST_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_CONST_TMP_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_CONST_VAR_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_CONST_UNUSED_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_CONST_CV_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_TMP_CONST_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_TMP_TMP_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_TMP_VAR_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_TMP_UNUSED_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_TMP_CV_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_VAR_CONST_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_VAR_TMP_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_VAR_VAR_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_VAR_CV_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_UNUSED_UNUSED_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_UNUSED_CV_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_CV_CONST_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_CV_TMP_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_CV_VAR_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_CV_UNUSED_HANDLER,
  	ZEND_INIT_ARRAY_SPEC_CV_CV_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CONST_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_TMP_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_VAR_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_UNUSED_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_CONST_CV_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CONST_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_TMP_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_VAR_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_UNUSED_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_TMP_CV_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CONST_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_TMP_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_VAR_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CONST_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_TMP_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_VAR_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_UNUSED_HANDLER,
  	ZEND_ADD_ARRAY_ELEMENT_SPEC_CV_CV_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_CONST_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_TMP_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
  	ZEND_INCLUDE_OR_EVAL_SPEC_CV_HANDLER,
  	ZEND_UNSET_VAR_SPEC_CONST_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_VAR_SPEC_CONST_VAR_HANDLER,
  	ZEND_UNSET_VAR_SPEC_CONST_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_VAR_SPEC_TMP_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_VAR_SPEC_TMP_VAR_HANDLER,
  	ZEND_UNSET_VAR_SPEC_TMP_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_VAR_SPEC_VAR_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_VAR_SPEC_VAR_VAR_HANDLER,
  	ZEND_UNSET_VAR_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_VAR_SPEC_CV_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_VAR_SPEC_CV_VAR_HANDLER,
  	ZEND_UNSET_VAR_SPEC_CV_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_DIM_SPEC_VAR_CONST_HANDLER,
  	ZEND_UNSET_DIM_SPEC_VAR_TMP_HANDLER,
  	ZEND_UNSET_DIM_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_DIM_SPEC_VAR_CV_HANDLER,
  	ZEND_UNSET_DIM_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_UNSET_DIM_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_UNSET_DIM_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_DIM_SPEC_UNUSED_CV_HANDLER,
  	ZEND_UNSET_DIM_SPEC_CV_CONST_HANDLER,
  	ZEND_UNSET_DIM_SPEC_CV_TMP_HANDLER,
  	ZEND_UNSET_DIM_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_DIM_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_OBJ_SPEC_VAR_CONST_HANDLER,
  	ZEND_UNSET_OBJ_SPEC_VAR_TMP_HANDLER,
  	ZEND_UNSET_OBJ_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_OBJ_SPEC_VAR_CV_HANDLER,
  	ZEND_UNSET_OBJ_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_UNSET_OBJ_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_UNSET_OBJ_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_OBJ_SPEC_UNUSED_CV_HANDLER,
  	ZEND_UNSET_OBJ_SPEC_CV_CONST_HANDLER,
  	ZEND_UNSET_OBJ_SPEC_CV_TMP_HANDLER,
  	ZEND_UNSET_OBJ_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_UNSET_OBJ_SPEC_CV_CV_HANDLER,
  	ZEND_FE_RESET_SPEC_CONST_HANDLER,
  	ZEND_FE_RESET_SPEC_CONST_HANDLER,
  	ZEND_FE_RESET_SPEC_CONST_HANDLER,
  	ZEND_FE_RESET_SPEC_CONST_HANDLER,
  	ZEND_FE_RESET_SPEC_CONST_HANDLER,
  	ZEND_FE_RESET_SPEC_TMP_HANDLER,
  	ZEND_FE_RESET_SPEC_TMP_HANDLER,
  	ZEND_FE_RESET_SPEC_TMP_HANDLER,
  	ZEND_FE_RESET_SPEC_TMP_HANDLER,
  	ZEND_FE_RESET_SPEC_TMP_HANDLER,
  	ZEND_FE_RESET_SPEC_VAR_HANDLER,
  	ZEND_FE_RESET_SPEC_VAR_HANDLER,
  	ZEND_FE_RESET_SPEC_VAR_HANDLER,
  	ZEND_FE_RESET_SPEC_VAR_HANDLER,
  	ZEND_FE_RESET_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FE_RESET_SPEC_CV_HANDLER,
  	ZEND_FE_RESET_SPEC_CV_HANDLER,
  	ZEND_FE_RESET_SPEC_CV_HANDLER,
  	ZEND_FE_RESET_SPEC_CV_HANDLER,
  	ZEND_FE_RESET_SPEC_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FE_FETCH_SPEC_VAR_HANDLER,
  	ZEND_FE_FETCH_SPEC_VAR_HANDLER,
  	ZEND_FE_FETCH_SPEC_VAR_HANDLER,
  	ZEND_FE_FETCH_SPEC_VAR_HANDLER,
  	ZEND_FE_FETCH_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_EXIT_SPEC_CONST_HANDLER,
  	ZEND_EXIT_SPEC_CONST_HANDLER,
  	ZEND_EXIT_SPEC_CONST_HANDLER,
  	ZEND_EXIT_SPEC_CONST_HANDLER,
  	ZEND_EXIT_SPEC_CONST_HANDLER,
  	ZEND_EXIT_SPEC_TMP_HANDLER,
  	ZEND_EXIT_SPEC_TMP_HANDLER,
  	ZEND_EXIT_SPEC_TMP_HANDLER,
  	ZEND_EXIT_SPEC_TMP_HANDLER,
  	ZEND_EXIT_SPEC_TMP_HANDLER,
  	ZEND_EXIT_SPEC_VAR_HANDLER,
  	ZEND_EXIT_SPEC_VAR_HANDLER,
  	ZEND_EXIT_SPEC_VAR_HANDLER,
  	ZEND_EXIT_SPEC_VAR_HANDLER,
  	ZEND_EXIT_SPEC_VAR_HANDLER,
  	ZEND_EXIT_SPEC_UNUSED_HANDLER,
  	ZEND_EXIT_SPEC_UNUSED_HANDLER,
  	ZEND_EXIT_SPEC_UNUSED_HANDLER,
  	ZEND_EXIT_SPEC_UNUSED_HANDLER,
  	ZEND_EXIT_SPEC_UNUSED_HANDLER,
  	ZEND_EXIT_SPEC_CV_HANDLER,
  	ZEND_EXIT_SPEC_CV_HANDLER,
  	ZEND_EXIT_SPEC_CV_HANDLER,
  	ZEND_EXIT_SPEC_CV_HANDLER,
  	ZEND_EXIT_SPEC_CV_HANDLER,
  	ZEND_FETCH_R_SPEC_CONST_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_R_SPEC_CONST_VAR_HANDLER,
  	ZEND_FETCH_R_SPEC_CONST_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_R_SPEC_TMP_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_R_SPEC_TMP_VAR_HANDLER,
  	ZEND_FETCH_R_SPEC_TMP_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_R_SPEC_VAR_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_R_SPEC_VAR_VAR_HANDLER,
  	ZEND_FETCH_R_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_R_SPEC_CV_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_R_SPEC_CV_VAR_HANDLER,
  	ZEND_FETCH_R_SPEC_CV_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_CONST_CONST_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_CONST_TMP_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_CONST_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_CONST_CV_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_TMP_CONST_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_TMP_TMP_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_TMP_CV_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_VAR_CONST_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_VAR_TMP_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_CV_CONST_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_CV_TMP_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_R_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_R_SPEC_VAR_CONST_HANDLER,
  	ZEND_FETCH_OBJ_R_SPEC_VAR_TMP_HANDLER,
  	ZEND_FETCH_OBJ_R_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_R_SPEC_VAR_CV_HANDLER,
  	ZEND_FETCH_OBJ_R_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_FETCH_OBJ_R_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_FETCH_OBJ_R_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_R_SPEC_UNUSED_CV_HANDLER,
  	ZEND_FETCH_OBJ_R_SPEC_CV_CONST_HANDLER,
  	ZEND_FETCH_OBJ_R_SPEC_CV_TMP_HANDLER,
  	ZEND_FETCH_OBJ_R_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_R_SPEC_CV_CV_HANDLER,
  	ZEND_FETCH_W_SPEC_CONST_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_W_SPEC_CONST_VAR_HANDLER,
  	ZEND_FETCH_W_SPEC_CONST_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_W_SPEC_TMP_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_W_SPEC_TMP_VAR_HANDLER,
  	ZEND_FETCH_W_SPEC_TMP_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_W_SPEC_VAR_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_W_SPEC_VAR_VAR_HANDLER,
  	ZEND_FETCH_W_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_W_SPEC_CV_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_W_SPEC_CV_VAR_HANDLER,
  	ZEND_FETCH_W_SPEC_CV_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_W_SPEC_VAR_CONST_HANDLER,
  	ZEND_FETCH_DIM_W_SPEC_VAR_TMP_HANDLER,
  	ZEND_FETCH_DIM_W_SPEC_VAR_VAR_HANDLER,
  	ZEND_FETCH_DIM_W_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_FETCH_DIM_W_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_W_SPEC_CV_CONST_HANDLER,
  	ZEND_FETCH_DIM_W_SPEC_CV_TMP_HANDLER,
  	ZEND_FETCH_DIM_W_SPEC_CV_VAR_HANDLER,
  	ZEND_FETCH_DIM_W_SPEC_CV_UNUSED_HANDLER,
  	ZEND_FETCH_DIM_W_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_W_SPEC_VAR_CONST_HANDLER,
  	ZEND_FETCH_OBJ_W_SPEC_VAR_TMP_HANDLER,
  	ZEND_FETCH_OBJ_W_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_W_SPEC_VAR_CV_HANDLER,
  	ZEND_FETCH_OBJ_W_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_FETCH_OBJ_W_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_FETCH_OBJ_W_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_W_SPEC_UNUSED_CV_HANDLER,
  	ZEND_FETCH_OBJ_W_SPEC_CV_CONST_HANDLER,
  	ZEND_FETCH_OBJ_W_SPEC_CV_TMP_HANDLER,
  	ZEND_FETCH_OBJ_W_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_W_SPEC_CV_CV_HANDLER,
  	ZEND_FETCH_RW_SPEC_CONST_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_RW_SPEC_CONST_VAR_HANDLER,
  	ZEND_FETCH_RW_SPEC_CONST_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_RW_SPEC_TMP_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_RW_SPEC_TMP_VAR_HANDLER,
  	ZEND_FETCH_RW_SPEC_TMP_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_RW_SPEC_VAR_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_RW_SPEC_VAR_VAR_HANDLER,
  	ZEND_FETCH_RW_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_RW_SPEC_CV_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_RW_SPEC_CV_VAR_HANDLER,
  	ZEND_FETCH_RW_SPEC_CV_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_RW_SPEC_VAR_CONST_HANDLER,
  	ZEND_FETCH_DIM_RW_SPEC_VAR_TMP_HANDLER,
  	ZEND_FETCH_DIM_RW_SPEC_VAR_VAR_HANDLER,
  	ZEND_FETCH_DIM_RW_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_FETCH_DIM_RW_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_RW_SPEC_CV_CONST_HANDLER,
  	ZEND_FETCH_DIM_RW_SPEC_CV_TMP_HANDLER,
  	ZEND_FETCH_DIM_RW_SPEC_CV_VAR_HANDLER,
  	ZEND_FETCH_DIM_RW_SPEC_CV_UNUSED_HANDLER,
  	ZEND_FETCH_DIM_RW_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_RW_SPEC_VAR_CONST_HANDLER,
  	ZEND_FETCH_OBJ_RW_SPEC_VAR_TMP_HANDLER,
  	ZEND_FETCH_OBJ_RW_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_RW_SPEC_VAR_CV_HANDLER,
  	ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_FETCH_OBJ_RW_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_FETCH_OBJ_RW_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_RW_SPEC_UNUSED_CV_HANDLER,
  	ZEND_FETCH_OBJ_RW_SPEC_CV_CONST_HANDLER,
  	ZEND_FETCH_OBJ_RW_SPEC_CV_TMP_HANDLER,
  	ZEND_FETCH_OBJ_RW_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_RW_SPEC_CV_CV_HANDLER,
  	ZEND_FETCH_IS_SPEC_CONST_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_IS_SPEC_CONST_VAR_HANDLER,
  	ZEND_FETCH_IS_SPEC_CONST_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_IS_SPEC_TMP_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_IS_SPEC_TMP_VAR_HANDLER,
  	ZEND_FETCH_IS_SPEC_TMP_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_IS_SPEC_VAR_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_IS_SPEC_VAR_VAR_HANDLER,
  	ZEND_FETCH_IS_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_IS_SPEC_CV_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_IS_SPEC_CV_VAR_HANDLER,
  	ZEND_FETCH_IS_SPEC_CV_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_IS_SPEC_VAR_CONST_HANDLER,
  	ZEND_FETCH_DIM_IS_SPEC_VAR_TMP_HANDLER,
  	ZEND_FETCH_DIM_IS_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_IS_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_IS_SPEC_CV_CONST_HANDLER,
  	ZEND_FETCH_DIM_IS_SPEC_CV_TMP_HANDLER,
  	ZEND_FETCH_DIM_IS_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_IS_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_IS_SPEC_VAR_CONST_HANDLER,
  	ZEND_FETCH_OBJ_IS_SPEC_VAR_TMP_HANDLER,
  	ZEND_FETCH_OBJ_IS_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_IS_SPEC_VAR_CV_HANDLER,
  	ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_FETCH_OBJ_IS_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_FETCH_OBJ_IS_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_IS_SPEC_UNUSED_CV_HANDLER,
  	ZEND_FETCH_OBJ_IS_SPEC_CV_CONST_HANDLER,
  	ZEND_FETCH_OBJ_IS_SPEC_CV_TMP_HANDLER,
  	ZEND_FETCH_OBJ_IS_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_IS_SPEC_CV_CV_HANDLER,
  	ZEND_FETCH_FUNC_ARG_SPEC_CONST_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_FUNC_ARG_SPEC_CONST_VAR_HANDLER,
  	ZEND_FETCH_FUNC_ARG_SPEC_CONST_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_FUNC_ARG_SPEC_TMP_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_FUNC_ARG_SPEC_TMP_VAR_HANDLER,
  	ZEND_FETCH_FUNC_ARG_SPEC_TMP_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_FUNC_ARG_SPEC_VAR_VAR_HANDLER,
  	ZEND_FETCH_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_FUNC_ARG_SPEC_CV_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_FUNC_ARG_SPEC_CV_VAR_HANDLER,
  	ZEND_FETCH_FUNC_ARG_SPEC_CV_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
  	ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_TMP_HANDLER,
  	ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_VAR_HANDLER,
  	ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_FETCH_DIM_FUNC_ARG_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CONST_HANDLER,
  	ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_TMP_HANDLER,
  	ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_VAR_HANDLER,
  	ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_UNUSED_HANDLER,
  	ZEND_FETCH_DIM_FUNC_ARG_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CONST_HANDLER,
  	ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_TMP_HANDLER,
  	ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_FUNC_ARG_SPEC_VAR_CV_HANDLER,
  	ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_FUNC_ARG_SPEC_UNUSED_CV_HANDLER,
  	ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CONST_HANDLER,
  	ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_TMP_HANDLER,
  	ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_FUNC_ARG_SPEC_CV_CV_HANDLER,
  	ZEND_FETCH_UNSET_SPEC_CONST_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_UNSET_SPEC_CONST_VAR_HANDLER,
  	ZEND_FETCH_UNSET_SPEC_CONST_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_UNSET_SPEC_TMP_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_UNSET_SPEC_TMP_VAR_HANDLER,
  	ZEND_FETCH_UNSET_SPEC_TMP_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_UNSET_SPEC_VAR_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_UNSET_SPEC_VAR_VAR_HANDLER,
  	ZEND_FETCH_UNSET_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_UNSET_SPEC_CV_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_UNSET_SPEC_CV_VAR_HANDLER,
  	ZEND_FETCH_UNSET_SPEC_CV_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_UNSET_SPEC_VAR_CONST_HANDLER,
  	ZEND_FETCH_DIM_UNSET_SPEC_VAR_TMP_HANDLER,
  	ZEND_FETCH_DIM_UNSET_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_UNSET_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_UNSET_SPEC_CV_CONST_HANDLER,
  	ZEND_FETCH_DIM_UNSET_SPEC_CV_TMP_HANDLER,
  	ZEND_FETCH_DIM_UNSET_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_UNSET_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CONST_HANDLER,
  	ZEND_FETCH_OBJ_UNSET_SPEC_VAR_TMP_HANDLER,
  	ZEND_FETCH_OBJ_UNSET_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_UNSET_SPEC_VAR_CV_HANDLER,
  	ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_UNSET_SPEC_UNUSED_CV_HANDLER,
  	ZEND_FETCH_OBJ_UNSET_SPEC_CV_CONST_HANDLER,
  	ZEND_FETCH_OBJ_UNSET_SPEC_CV_TMP_HANDLER,
  	ZEND_FETCH_OBJ_UNSET_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_OBJ_UNSET_SPEC_CV_CV_HANDLER,
  	ZEND_FETCH_DIM_TMP_VAR_SPEC_CONST_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_DIM_TMP_VAR_SPEC_TMP_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_CONSTANT_SPEC_CONST_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_CONSTANT_SPEC_VAR_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_FETCH_CONSTANT_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_GOTO_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_GOTO_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_GOTO_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_GOTO_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_GOTO_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_STMT_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_BEGIN_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_FCALL_END_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_EXT_NOP_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_TICKS_SPEC_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
  	ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
  	ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
  	ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
  	ZEND_SEND_VAR_NO_REF_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER,
  	ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER,
  	ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER,
  	ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER,
  	ZEND_SEND_VAR_NO_REF_SPEC_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_CATCH_SPEC_CONST_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_THROW_SPEC_CONST_HANDLER,
  	ZEND_THROW_SPEC_CONST_HANDLER,
  	ZEND_THROW_SPEC_CONST_HANDLER,
  	ZEND_THROW_SPEC_CONST_HANDLER,
  	ZEND_THROW_SPEC_CONST_HANDLER,
  	ZEND_THROW_SPEC_TMP_HANDLER,
  	ZEND_THROW_SPEC_TMP_HANDLER,
  	ZEND_THROW_SPEC_TMP_HANDLER,
  	ZEND_THROW_SPEC_TMP_HANDLER,
  	ZEND_THROW_SPEC_TMP_HANDLER,
  	ZEND_THROW_SPEC_VAR_HANDLER,
  	ZEND_THROW_SPEC_VAR_HANDLER,
  	ZEND_THROW_SPEC_VAR_HANDLER,
  	ZEND_THROW_SPEC_VAR_HANDLER,
  	ZEND_THROW_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_THROW_SPEC_CV_HANDLER,
  	ZEND_THROW_SPEC_CV_HANDLER,
  	ZEND_THROW_SPEC_CV_HANDLER,
  	ZEND_THROW_SPEC_CV_HANDLER,
  	ZEND_THROW_SPEC_CV_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_TMP_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_VAR_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_TMP_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_VAR_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_TMP_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_VAR_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_TMP_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_VAR_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_CONST_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_TMP_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_VAR_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_UNUSED_HANDLER,
  	ZEND_FETCH_CLASS_SPEC_CV_HANDLER,
  	ZEND_CLONE_SPEC_CONST_HANDLER,
  	ZEND_CLONE_SPEC_CONST_HANDLER,
  	ZEND_CLONE_SPEC_CONST_HANDLER,
  	ZEND_CLONE_SPEC_CONST_HANDLER,
  	ZEND_CLONE_SPEC_CONST_HANDLER,
  	ZEND_CLONE_SPEC_TMP_HANDLER,
  	ZEND_CLONE_SPEC_TMP_HANDLER,
  	ZEND_CLONE_SPEC_TMP_HANDLER,
  	ZEND_CLONE_SPEC_TMP_HANDLER,
  	ZEND_CLONE_SPEC_TMP_HANDLER,
  	ZEND_CLONE_SPEC_VAR_HANDLER,
  	ZEND_CLONE_SPEC_VAR_HANDLER,
  	ZEND_CLONE_SPEC_VAR_HANDLER,
  	ZEND_CLONE_SPEC_VAR_HANDLER,
  	ZEND_CLONE_SPEC_VAR_HANDLER,
  	ZEND_CLONE_SPEC_UNUSED_HANDLER,
  	ZEND_CLONE_SPEC_UNUSED_HANDLER,
  	ZEND_CLONE_SPEC_UNUSED_HANDLER,
  	ZEND_CLONE_SPEC_UNUSED_HANDLER,
  	ZEND_CLONE_SPEC_UNUSED_HANDLER,
  	ZEND_CLONE_SPEC_CV_HANDLER,
  	ZEND_CLONE_SPEC_CV_HANDLER,
  	ZEND_CLONE_SPEC_CV_HANDLER,
  	ZEND_CLONE_SPEC_CV_HANDLER,
  	ZEND_CLONE_SPEC_CV_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_CONST_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_TMP_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
  	ZEND_RETURN_BY_REF_SPEC_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_TMP_CONST_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_TMP_TMP_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_TMP_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_TMP_CV_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_VAR_CONST_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_VAR_TMP_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_VAR_CV_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_UNUSED_CV_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_CV_CONST_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_CV_TMP_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_METHOD_CALL_SPEC_CV_CV_HANDLER,
  	ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CONST_HANDLER,
  	ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_TMP_HANDLER,
  	ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_VAR_HANDLER,
  	ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_UNUSED_HANDLER,
  	ZEND_INIT_STATIC_METHOD_CALL_SPEC_CONST_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CONST_HANDLER,
  	ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_TMP_HANDLER,
  	ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_VAR_HANDLER,
  	ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_INIT_STATIC_METHOD_CALL_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_VAR_HANDLER,
  	ZEND_ISSET_ISEMPTY_VAR_SPEC_CONST_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_VAR_HANDLER,
  	ZEND_ISSET_ISEMPTY_VAR_SPEC_TMP_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_VAR_HANDLER,
  	ZEND_ISSET_ISEMPTY_VAR_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_VAR_HANDLER,
  	ZEND_ISSET_ISEMPTY_VAR_SPEC_CV_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CONST_HANDLER,
  	ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_TMP_HANDLER,
  	ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_VAR_CV_HANDLER,
  	ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CONST_HANDLER,
  	ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_TMP_HANDLER,
  	ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_DIM_OBJ_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_PRE_INC_OBJ_SPEC_VAR_CONST_HANDLER,
  	ZEND_PRE_INC_OBJ_SPEC_VAR_TMP_HANDLER,
  	ZEND_PRE_INC_OBJ_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_PRE_INC_OBJ_SPEC_VAR_CV_HANDLER,
  	ZEND_PRE_INC_OBJ_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_PRE_INC_OBJ_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_PRE_INC_OBJ_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_PRE_INC_OBJ_SPEC_UNUSED_CV_HANDLER,
  	ZEND_PRE_INC_OBJ_SPEC_CV_CONST_HANDLER,
  	ZEND_PRE_INC_OBJ_SPEC_CV_TMP_HANDLER,
  	ZEND_PRE_INC_OBJ_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_PRE_INC_OBJ_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_PRE_DEC_OBJ_SPEC_VAR_CONST_HANDLER,
  	ZEND_PRE_DEC_OBJ_SPEC_VAR_TMP_HANDLER,
  	ZEND_PRE_DEC_OBJ_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_PRE_DEC_OBJ_SPEC_VAR_CV_HANDLER,
  	ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_PRE_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_PRE_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_PRE_DEC_OBJ_SPEC_UNUSED_CV_HANDLER,
  	ZEND_PRE_DEC_OBJ_SPEC_CV_CONST_HANDLER,
  	ZEND_PRE_DEC_OBJ_SPEC_CV_TMP_HANDLER,
  	ZEND_PRE_DEC_OBJ_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_PRE_DEC_OBJ_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_POST_INC_OBJ_SPEC_VAR_CONST_HANDLER,
  	ZEND_POST_INC_OBJ_SPEC_VAR_TMP_HANDLER,
  	ZEND_POST_INC_OBJ_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_POST_INC_OBJ_SPEC_VAR_CV_HANDLER,
  	ZEND_POST_INC_OBJ_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_POST_INC_OBJ_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_POST_INC_OBJ_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_POST_INC_OBJ_SPEC_UNUSED_CV_HANDLER,
  	ZEND_POST_INC_OBJ_SPEC_CV_CONST_HANDLER,
  	ZEND_POST_INC_OBJ_SPEC_CV_TMP_HANDLER,
  	ZEND_POST_INC_OBJ_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_POST_INC_OBJ_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_POST_DEC_OBJ_SPEC_VAR_CONST_HANDLER,
  	ZEND_POST_DEC_OBJ_SPEC_VAR_TMP_HANDLER,
  	ZEND_POST_DEC_OBJ_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_POST_DEC_OBJ_SPEC_VAR_CV_HANDLER,
  	ZEND_POST_DEC_OBJ_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_POST_DEC_OBJ_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_POST_DEC_OBJ_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_POST_DEC_OBJ_SPEC_UNUSED_CV_HANDLER,
  	ZEND_POST_DEC_OBJ_SPEC_CV_CONST_HANDLER,
  	ZEND_POST_DEC_OBJ_SPEC_CV_TMP_HANDLER,
  	ZEND_POST_DEC_OBJ_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_POST_DEC_OBJ_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_OBJ_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_OBJ_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_OBJ_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_OBJ_SPEC_VAR_CV_HANDLER,
  	ZEND_ASSIGN_OBJ_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ASSIGN_OBJ_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ASSIGN_OBJ_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_OBJ_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ASSIGN_OBJ_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_OBJ_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_OBJ_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_OBJ_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INSTANCEOF_SPEC_TMP_HANDLER,
  	ZEND_INSTANCEOF_SPEC_TMP_HANDLER,
  	ZEND_INSTANCEOF_SPEC_TMP_HANDLER,
  	ZEND_INSTANCEOF_SPEC_TMP_HANDLER,
  	ZEND_INSTANCEOF_SPEC_TMP_HANDLER,
  	ZEND_INSTANCEOF_SPEC_VAR_HANDLER,
  	ZEND_INSTANCEOF_SPEC_VAR_HANDLER,
  	ZEND_INSTANCEOF_SPEC_VAR_HANDLER,
  	ZEND_INSTANCEOF_SPEC_VAR_HANDLER,
  	ZEND_INSTANCEOF_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_INSTANCEOF_SPEC_CV_HANDLER,
  	ZEND_INSTANCEOF_SPEC_CV_HANDLER,
  	ZEND_INSTANCEOF_SPEC_CV_HANDLER,
  	ZEND_INSTANCEOF_SPEC_CV_HANDLER,
  	ZEND_INSTANCEOF_SPEC_CV_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_DECLARE_FUNCTION_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_RAISE_ABSTRACT_ERROR_SPEC_HANDLER,
  	ZEND_DECLARE_CONST_SPEC_CONST_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_INTERFACE_SPEC_CONST_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_DECLARE_INHERITED_CLASS_DELAYED_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_VERIFY_ABSTRACT_CLASS_SPEC_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_DIM_SPEC_VAR_CONST_HANDLER,
  	ZEND_ASSIGN_DIM_SPEC_VAR_TMP_HANDLER,
  	ZEND_ASSIGN_DIM_SPEC_VAR_VAR_HANDLER,
  	ZEND_ASSIGN_DIM_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_ASSIGN_DIM_SPEC_VAR_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ASSIGN_DIM_SPEC_CV_CONST_HANDLER,
  	ZEND_ASSIGN_DIM_SPEC_CV_TMP_HANDLER,
  	ZEND_ASSIGN_DIM_SPEC_CV_VAR_HANDLER,
  	ZEND_ASSIGN_DIM_SPEC_CV_UNUSED_HANDLER,
  	ZEND_ASSIGN_DIM_SPEC_CV_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CONST_HANDLER,
  	ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_TMP_HANDLER,
  	ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_VAR_CV_HANDLER,
  	ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_UNUSED_CV_HANDLER,
  	ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CONST_HANDLER,
  	ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_TMP_HANDLER,
  	ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ISSET_ISEMPTY_PROP_OBJ_SPEC_CV_CV_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_HANDLE_EXCEPTION_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_USER_OPCODE_SPEC_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_JMP_SET_SPEC_CONST_HANDLER,
  	ZEND_JMP_SET_SPEC_CONST_HANDLER,
  	ZEND_JMP_SET_SPEC_CONST_HANDLER,
  	ZEND_JMP_SET_SPEC_CONST_HANDLER,
  	ZEND_JMP_SET_SPEC_CONST_HANDLER,
  	ZEND_JMP_SET_SPEC_TMP_HANDLER,
  	ZEND_JMP_SET_SPEC_TMP_HANDLER,
  	ZEND_JMP_SET_SPEC_TMP_HANDLER,
  	ZEND_JMP_SET_SPEC_TMP_HANDLER,
  	ZEND_JMP_SET_SPEC_TMP_HANDLER,
  	ZEND_JMP_SET_SPEC_VAR_HANDLER,
  	ZEND_JMP_SET_SPEC_VAR_HANDLER,
  	ZEND_JMP_SET_SPEC_VAR_HANDLER,
  	ZEND_JMP_SET_SPEC_VAR_HANDLER,
  	ZEND_JMP_SET_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_JMP_SET_SPEC_CV_HANDLER,
  	ZEND_JMP_SET_SPEC_CV_HANDLER,
  	ZEND_JMP_SET_SPEC_CV_HANDLER,
  	ZEND_JMP_SET_SPEC_CV_HANDLER,
  	ZEND_JMP_SET_SPEC_CV_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_DECLARE_LAMBDA_FUNCTION_SPEC_CONST_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_ADD_TRAIT_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_BIND_TRAITS_SPEC_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_SEPARATE_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_CONST_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_TMP_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER,
  	ZEND_QM_ASSIGN_VAR_SPEC_CV_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_CONST_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_TMP_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_VAR_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_NULL_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_CV_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_CV_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_CV_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_CV_HANDLER,
  	ZEND_JMP_SET_VAR_SPEC_CV_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_DISCARD_EXCEPTION_SPEC_HANDLER,
  	ZEND_YIELD_SPEC_CONST_CONST_HANDLER,
  	ZEND_YIELD_SPEC_CONST_TMP_HANDLER,
  	ZEND_YIELD_SPEC_CONST_VAR_HANDLER,
  	ZEND_YIELD_SPEC_CONST_UNUSED_HANDLER,
  	ZEND_YIELD_SPEC_CONST_CV_HANDLER,
  	ZEND_YIELD_SPEC_TMP_CONST_HANDLER,
  	ZEND_YIELD_SPEC_TMP_TMP_HANDLER,
  	ZEND_YIELD_SPEC_TMP_VAR_HANDLER,
  	ZEND_YIELD_SPEC_TMP_UNUSED_HANDLER,
  	ZEND_YIELD_SPEC_TMP_CV_HANDLER,
  	ZEND_YIELD_SPEC_VAR_CONST_HANDLER,
  	ZEND_YIELD_SPEC_VAR_TMP_HANDLER,
  	ZEND_YIELD_SPEC_VAR_VAR_HANDLER,
  	ZEND_YIELD_SPEC_VAR_UNUSED_HANDLER,
  	ZEND_YIELD_SPEC_VAR_CV_HANDLER,
  	ZEND_YIELD_SPEC_UNUSED_CONST_HANDLER,
  	ZEND_YIELD_SPEC_UNUSED_TMP_HANDLER,
  	ZEND_YIELD_SPEC_UNUSED_VAR_HANDLER,
  	ZEND_YIELD_SPEC_UNUSED_UNUSED_HANDLER,
  	ZEND_YIELD_SPEC_UNUSED_CV_HANDLER,
  	ZEND_YIELD_SPEC_CV_CONST_HANDLER,
  	ZEND_YIELD_SPEC_CV_TMP_HANDLER,
  	ZEND_YIELD_SPEC_CV_VAR_HANDLER,
  	ZEND_YIELD_SPEC_CV_UNUSED_HANDLER,
  	ZEND_YIELD_SPEC_CV_CV_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_GENERATOR_RETURN_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_CALL_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_FAST_RET_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_RECV_VARIADIC_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_SEND_UNPACK_SPEC_HANDLER,
  	ZEND_NULL_HANDLER
  };
  zend_opcode_handlers = (opcode_handler_t*)labels;
}
static opcode_handler_t zend_vm_get_opcode_handler(zend_uchar opcode, zend_op* op)
{
		static const int zend_vm_decode[] = {
			_UNUSED_CODE, /* 0              */
			_CONST_CODE,  /* 1 = IS_CONST   */
			_TMP_CODE,    /* 2 = IS_TMP_VAR */
			_UNUSED_CODE, /* 3              */
			_VAR_CODE,    /* 4 = IS_VAR     */
			_UNUSED_CODE, /* 5              */
			_UNUSED_CODE, /* 6              */
			_UNUSED_CODE, /* 7              */
			_UNUSED_CODE, /* 8 = IS_UNUSED  */
			_UNUSED_CODE, /* 9              */
			_UNUSED_CODE, /* 10             */
			_UNUSED_CODE, /* 11             */
			_UNUSED_CODE, /* 12             */
			_UNUSED_CODE, /* 13             */
			_UNUSED_CODE, /* 14             */
			_UNUSED_CODE, /* 15             */
			_CV_CODE      /* 16 = IS_CV     */
		};
		return zend_opcode_handlers[opcode * 25 + zend_vm_decode[op->op1_type] * 5 + zend_vm_decode[op->op2_type]];
}

ZEND_API void zend_vm_set_opcode_handler(zend_op* op)
{
	op->handler = zend_vm_get_opcode_handler(zend_user_opcodes[op->opcode], op);
}

ZEND_API int zend_do_fcall(ZEND_OPCODE_HANDLER_ARGS)
{
	return zend_do_fcall_common_helper_SPEC(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);
}

