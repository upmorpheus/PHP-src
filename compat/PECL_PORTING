This document describes the way to port the PECL extensions for <str_size_and_int64>.
After undertaking the steps suggested, the same  PECL extension source should be
compatible with both older and <str_size_and_int64> codebase.

I.   Basic changes in <str_size_and_int64>
 i.   String length
 ii.  Integer types
 iii. Other datatypes
 iv.  Macros
 v.   Functions
II.  Porting steps
 i.    Automatic replacements
 ii.   Compatibility header
 iii.  zend_parse_parameters()
 iv.   Manual code fixes
 v.    Library dependencies
 vi.   spprintf() formats
 vii.  Array API
 viii. Explicit compilation enablement
 ix.   Misccellaneous porting steps
III. Pitfalls
 i.   size_t usage
 ii.  zend_parse_parameters()
 iii. Pointer difference
 iv.  RETURN_STRINGL, RETVAL_STRINGL
 v.   Bitwise operations


========================================
I. Basic changes in <str_size_and_int64>
========================================

For extended information, please look at the compat.h header and the wiki RFC page
https://wiki.php.net/rfc/size_t_and_int64

 i.   String length

	String lengths do no more depend on the firm 'int' datatype. The replacement
	is a platform dependent size_t datatype.

	String length is defined as zend_size_t inside Zend and aliased as php_size_t
	anywhere else. The inclusion of php.h is necessary.

 ii.  Integer types

	Integers do no more depend on the firm 'long' type. Instead a platform
	dependent integer type is used. That datatype is defined dynamically to
	guarantee the consistent 64 bit support.

	Signed integer is defined as zend_int_t, unsigned integer as zend_uint_t
	inside Zend. Both are aliased as php_int_t and php_uint_t anywhere else,
	respectively. The inclusion of php.h is necessary.

 iii. Other datatypes
	zend_off_t  - portable off_t analogue
	zend_stat_t - portable 'struct stat' analogue

	These datatypes are declared to be portable across platforms. Thus, direct
	usage of the functions like fseek, stat, etc. as well as direct usage of 
	off_t and struct stat is strongly not recommended. Instead the portable
	macros should be used.

	zend_fseek - portable fseek equivalent
	zend_ftell - portable ftell equivalent
	zend_lseek - portable lseek equivalent
	zend_fstat - portable fstat equivalent
	zend_stat  - portable stat equivalent

 iv.  Macros
	Z_STRSIZE    - replacement for Z_STRLEN family
	Z_IVAL       - replacement for Z_LVAL family
	Z_I          - initialize signed integer constant
	Z_UI         - initialize unsigned integer constant
	ZEND_INT_MAX, ZEND_INT_MIN, ZEND_UINT_MAX, ZEND_SIZE_MAX 
	IS_INT       - replacement for IS_LONG
	ZVAL_INT     - replacement for ZVAL_LONG
	RETVAL_INT   - RETVAL_LONG
	RETURN_INT   - RETURN_LONG
	ZEND_STRTOL  - portable strtol version
	ZEND_STRTOUL - portable strtoul version
	ZEND_ITOA    - portable itoa version
	ZEND_ATOI    - portable atol version
	ZEND_ABS     - portable abs version

	This macros are safe to use with php_int_t

 v.   Functions

	Various functions became syntactic renames, it concerns functions containing
	the 'long' keyword. The new portable aliases also was added.

	convert_to_int, add_assoc_int, zend_ini_int, etc.

=================
II. Porting steps
=================

 i.   Automatic replacements

	The tool replace.php will automatically replace a number of syntactic changes
	in the old style extension. Note, that only simple cases are processed, for 
	complicated cases the manual intrusion is unavoidable. Still, this tool will
	save a lot of time while porting.

 ii.  Compatibility header

	The compat.h header, once copied into the extension source and included, will
	compensate many of the syntactic differences. The right place for the 
	inclusion might depend on the concrete extension code, while in general it
	might make sense to include it after all the other headers.

 iii. zend_parse_parameters()

	The arg specs 'l', 'L', 's' and 'p' are not available anymore. As their
	replacements 'i', 'I', 'S' and 'P' was invented. The integer specs expect a
	variable of type php_int_t to be passed. The string/path lengths are expected
	to be of type php_size_t.

	A possible way to declare the argument specs were using the ternary operator,
	eq.
	
	#define COMP (PHP_MAJOR_VERSION < 5) || (PHP_MAJOR_VERSION == 5 && PHP_MINOR_VERSION < 6)

	php_int_t i0, i1;
	char *s0, p0;
	php_size_t s0_len, p0_len;

	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, (COMP ? "lLsp" : "iISP"), &i0, &i1, &s0, &s0_len, &p0, &p0_len) == FAILURE) {
		return;
	}


 iv.  Manual code fixes

	While for many extensions the mechanic replacements will do the big job to
	retain the compatibility, the manual code fixes might be necessary. Here are
	especially to mention array API, filesystem API, unsigned string lengths. Also
	this is likely the case for extensions with library dependencies, see also the
	pitfalls section.

	After adjusting the variable types in zpp, the first places you automatically should
	look for are the functions where you pass the parameters. Especially those accepting 
	integers by reference might be broken. If those functions are your own implementations,
	it might make sense you to adapt the function signatures. In case of some library
	functions an intermediate variable of an appropriate type can be used.

 v.   Library dependencies

	Libraries using incompatible data types for string sizes and integers require 
	additional checks to ensure the correct value range. This is easy done as in the
	example below (assumed the function argument is of type php_int_t and the
	dependency library expects a value in integer range)

	if (INT_MAX < input_arg || INT_MIN > input_arg) {
		return;
	}

 vi.  spprintf() formats

	New printf modifier 'p' was implemented to platform independently output
	php_int_t datatype. That modifier can be used with 'd', 'u', 'x' and 'o' printf
	format specs with spprintf, snprintf and the wrapping printf implementations.
	To ensure compatibility, the macros ZEND_INT_FMT and ZEND_UINT_FMT should be 
	used

	php_int_t i0, i1;
	char *s0, p0;
	php_size_t s0_len, p0_len;

	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, (COMPAT ? "lLsp" : "iISP"), &i0, &i1, &s0, &s0_len, &p0, &p0_len) == FAILURE) {
		return;
	}
	if (INT_MAX < i0 || INT_MIN > i0) {
		php_error_docref(NULL TSRMLS_CC, E_WARNING, "Value '" ZEND_INT_FMT "' is out of range", i0);
		return;
	}


	Please note, that the replacement tool will not do automatic replacements for the %ld
	and other specs. It's up to the porter where such replacement were appropriate.
	To ease the process, some automatic still could be used, like here how it could
	be done in vim

	:%s,%ld," ZEND_INT_FMT ",g

 vii. Array API

	Datatype for array indexes was changed to php_uint_t, for key lengths to php_size_t

 viii. Explicit compilation enablement
	
	This is not implemented yet, the build system has to be tweaked for this to happen.
	The idea is, that an extension has to define some macros like PHP_64BIT_COMP to
	be allowed to compile.

 ix.   Misccellaneous porting steps

	In general, any code dealing with string size should use php_size_t, any code dealing
	with integer available in the userspace should use php_int_t. The other relevant
	places are socket APIs, INI settings, global constants, class constants and properties,
	etc.


=============
III. Pitfalls
=============

 i.   size_t usage
	
	php_size_t is mapped to the platform dependent size_t datatype, which is unsigned.
	The following code will not work as maybe expected, when max_len is negative

	char *s0;
	php_size_t s0_len;
	php_int_t max_len;

	if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, (COMPAT ? "sl" : "iS"), &s0, &s0_len, &max_len) == FAILURE) {
		return;
	}
	if (s0_len > max_len) {
		return;
	}

	The reason is, that for the comparsion max_len will be converted to an unsigned value
	which most likely will be PHP_SIZE_MAX. The correct check could look like

	if (max_len >= 0 && s0_len > max_len) {
		return;
	}

	Please note, that php_size_t is used not only for string length with zpp, but also
	widely for array keys and at many other places. Please check the corresponding APIs
	to ensure the datatype needed. Predominantly string size uses php_size_t now.

 ii.  zend_parse_parameters()

	The new integer and string format specs are strictly bound to the php_int_t and
	php_size_t datatypes. Those datatypes have variable sizes on different
	platforms. Especially usage of the old 'long' and 'int' datatypes can lead to
	memory errors and crashes on 64 bit platforms.

 iii. Pointer difference

	When working with pointer arithmetic, the ptrdiff_t type should be used to tell the
	difference between two pointers.

	char *s0 = "hello"
	char *s1 = s0;
	ptrdiff_t d;

	s1++;

	d = s1 - s0; /* Correct datatype to hold the result */

	Should the example happen to scale, like for instance working the bigger strings,
	using a wrong datatype will lead to an overflow. Though be aware that ptrdiff_t is
	signed, so can be negative.

 iv.  RETURN_STRINGL, RETVAL_STRINGL

	RETURN_STRINGL, RETVAL_STRINGL macros now expect php_size_t for the string length.
	While it's theoretically possible to use any other datatype with those macros, the
	explicit attention should be paid that the values arn't negative.

 v.   Bitwise operations

        Especialy some bitshift operations might bring unexpected results when mixing 32 and
	64 bit variables or constants. For example this snippet works different on 32 and
	64 bit platforms

	php_int_t var = 1 << 31;

	While a 32 bit variable can hold bits from 0 to 31, a 64 bit variable can hold bits
	from 0 to 63. So with the snippet above the result the max negative value of 32 bit
	integer. To have it working correct way, an explicit cast

	php_int_t var = (php_int_t)1 << 31;

	or the special macros in case of a constant

	php_int_t var = Z_I(1) << 31;

	can be used.


